[
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 16:45:00",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/D",
    "title": "D. Crocodile's Underground City",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "D",
    "submission_id": "314979506",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n// Function to check if there's a valid escape plan for a given time T\nbool is_valid_escape_plan(int N, int M, const vector<vector<int>>& adj, const vector<vector<int>>& weights, const vector<int>& exits, int T) {\n    vector<int> min_time(N, numeric_limits<int>::max());\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n\n    // Initialize distances for exit chambers\n    for (int exit : exits) {\n        min_time[exit] = 0;\n        pq.emplace(0, exit);\n    }\n\n    // Reverse Dijkstra's algorithm\n    while (!pq.empty()) {\n        int time = pq.top().first;\n        int chamber = pq.top().second;\n        pq.pop();\n\n        if (time > min_time[chamber]) continue;\n\n        for (size_t i = 0; i < adj[chamber].size(); ++i) {\n            int neighbor = adj[chamber][i];\n            int weight = weights[chamber][i];\n\n            if (weight > T) continue; // Corridor is too long to use\n\n            int new_time = time + weight;\n            if (new_time < min_time[neighbor]) {\n                min_time[neighbor] = new_time;\n                pq.emplace(new_time, neighbor);\n            }\n        }\n    }\n\n    // Check if chamber 0 can reach any exit within time T\n    return min_time[0] <= T;\n}\n\nint travel_plan(int N, int M, vector<vector<int>> R, vector<int> L, int K, vector<int> P) {\n    // Build adjacency list\n    vector<vector<int>> adj(N);\n    vector<vector<int>> weights(N);\n\n    for (int i = 0; i < M; ++i) {\n        int u = R[i][0];\n        int v = R[i][1];\n        int weight = L[i];\n\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n        weights[u].push_back(weight);\n        weights[v].push_back(weight);\n    }\n\n    // Binary search over T\n    int low = 1, high = 1'000'000'000, result = -1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n\n        if (is_valid_escape_plan(N, M, adj, weights, P, mid)) {\n            result = mid;\n            high = mid - 1; // Try for a smaller T\n        } else {\n            low = mid + 1; // Increase T\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 16:45:42",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/D",
    "title": "D. Crocodile's Underground City",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "D",
    "submission_id": "314979583",
    "code_index": 1,
    "code": "#include <vector>\n#include <queue>\n#include <limits>\n#include <utility>\n#include <functional>\n\nusing namespace std;\n\nint travel_plan(int N, int M, vector<vector<int>> R, vector<int> L, int K, vector<int> P) {\n    // Create adjacency list for the graph\n    vector<vector<pair<int, int>>> adj(N);\n    for (int i = 0; i < M; ++i) {\n        int u = R[i][0], v = R[i][1], w = L[i];\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n\n    // Initialize distances to infinity\n    vector<int> dist(N, numeric_limits<int>::max());\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n\n    // Push all exit chambers into the priority queue with distance 0\n    for (int exit : P) {\n        dist[exit] = 0;\n        pq.emplace(0, exit);\n    }\n\n    // Dijkstra's algorithm to compute shortest distances to exit chambers\n    while (!pq.empty()) {\n        auto [d, u] = pq.top();\n        pq.pop();\n\n        if (d > dist[u]) continue;\n\n        for (auto [v, w] : adj[u]) {\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.emplace(dist[v], v);\n            }\n        }\n    }\n\n    // Simulate worst-case escape time for chamber 0\n    int max_time = 0;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq_escape;\n    pq_escape.emplace(0, 0); // Start from chamber 0 with time 0\n\n    vector<bool> visited(N, false);\n    visited[0] = true;\n\n    while (!pq_escape.empty()) {\n        auto [current_time, u] = pq_escape.top();\n        pq_escape.pop();\n\n        max_time = max(max_time, current_time);\n\n        vector<pair<int, int>> neighbors;\n        for (auto [v, w] : adj[u]) {\n            if (!visited[v]) {\n                neighbors.emplace_back(v, w);\n            }\n        }\n\n        // Sort neighbors by their shortest path distances to exit chambers (worst-case blocking)\n        sort(neighbors.begin(), neighbors.end(), [&](const pair<int, int>& a, const pair<int, int>& b) {\n            return dist[a.first] < dist[b.first];\n        });\n\n        // Visit the worst-case neighbor\n        for (auto [v, w] : neighbors) {\n            visited[v] = true;\n            pq_escape.emplace(current_time + w, v);\n        }\n    }\n\n    return max_time;\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 16:46:27",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/D",
    "title": "D. Crocodile's Underground City",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "D",
    "submission_id": "314979656",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n\nint travel_plan(int N, int M, vector<vector<int>> R, vector<int> L, int K, vector<int> P) {\n    // Step 1: Build the adjacency list for the graph\n    vector<vector<pair<int, int>>> adj(N); // adj[node] = {neighbor, time}\n    for (int i = 0; i < M; ++i) {\n        int u = R[i][0], v = R[i][1], time = L[i];\n        adj[u].emplace_back(v, time);\n        adj[v].emplace_back(u, time);\n    }\n\n    // Step 2: Multi-source Dijkstra's algorithm\n    vector<long long> dist(N, numeric_limits<long long>::max()); // Distance to nearest exit chamber\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> pq; // Min-heap\n\n    // Initialize distances for exit chambers\n    for (int exit : P) {\n        dist[exit] = 0;\n        pq.emplace(0, exit);\n    }\n\n    // Process the priority queue\n    while (!pq.empty()) {\n        auto [current_dist, node] = pq.top();\n        pq.pop();\n\n        // If we already found a shorter path, skip\n        if (current_dist > dist[node]) continue;\n\n        // Relax edges\n        for (auto [neighbor, time] : adj[node]) {\n            if (dist[node] + time < dist[neighbor]) {\n                dist[neighbor] = dist[node] + time;\n                pq.emplace(dist[neighbor], neighbor);\n            }\n        }\n    }\n\n    // Step 3: Return the distance for the starting chamber (chamber 0)\n    return dist[0];\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 16:47:06",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/D",
    "title": "D. Crocodile's Underground City",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "D",
    "submission_id": "314979733",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\nusing namespace std;\n\nconst int64_t INF = 1e18;\n\nint64_t travel_plan(int N, int M, vector<vector<int>> R, vector<int> L, int K, vector<int> P) {\n    // Step 1: Build the graph and reverse graph\n    vector<vector<pair<int, int64_t>>> graph(N);\n    vector<vector<pair<int, int64_t>>> reverse_graph(N);\n    for (int i = 0; i < M; i++) {\n        int u = R[i][0], v = R[i][1];\n        int64_t w = L[i];\n        graph[u].push_back({v, w});\n        graph[v].push_back({u, w});\n        reverse_graph[v].push_back({u, w});\n        reverse_graph[u].push_back({v, w});\n    }\n\n    // Step 2: Compute shortest distances to exit chambers using reverse Dijkstra\n    vector<int64_t> dist(N, INF);\n    priority_queue<pair<int64_t, int>, vector<pair<int64_t, int>>, greater<>> pq;\n    for (int exit : P) {\n        dist[exit] = 0;\n        pq.push({0, exit});\n    }\n\n    while (!pq.empty()) {\n        auto [d, node] = pq.top();\n        pq.pop();\n        if (d > dist[node]) continue;\n        for (auto [neighbor, weight] : reverse_graph[node]) {\n            if (dist[node] + weight < dist[neighbor]) {\n                dist[neighbor] = dist[node] + weight;\n                pq.push({dist[neighbor], neighbor});\n            }\n        }\n    }\n\n    // Step 3: Binary search to find the minimum T\n    int64_t left = 0, right = 1e9, answer = 1e9;\n    while (left <= right) {\n        int64_t mid = left + (right - left) / 2;\n\n        // Validate if a good escape plan exists for T = mid\n        bool is_valid = true;\n        for (int chamber = 0; chamber < N; chamber++) {\n            if (dist[chamber] > mid) continue; // This chamber cannot reach an exit within T\n            int valid_corridors = 0;\n            for (auto [neighbor, weight] : graph[chamber]) {\n                if (dist[neighbor] <= mid) valid_corridors++;\n            }\n            if (valid_corridors < 2) {\n                is_valid = false;\n                break;\n            }\n        }\n\n        if (is_valid) {\n            answer = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return answer;\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 16:47:47",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/D",
    "title": "D. Crocodile's Underground City",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "D",
    "submission_id": "314979799",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nint travel_plan(int N, int M, vector<vector<int>> R, vector<int> L, int K, vector<int> P) {\n    // Adjacency list representation of the graph\n    vector<vector<pair<int, int>>> graph(N);  // graph[u] = { {v, weight}, ... }\n    \n    // Build the graph\n    for (int i = 0; i < M; i++) {\n        int u = R[i][0];\n        int v = R[i][1];\n        int weight = L[i];\n        graph[u].emplace_back(v, weight);\n        graph[v].emplace_back(u, weight);\n    }\n\n    // Distance array, initialized to infinity\n    vector<long long> dist(N, numeric_limits<long long>::max());\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> pq;  // Min-heap\n\n    // Set distances for exit chambers to 0 and push them into the priority queue\n    for (int exit : P) {\n        dist[exit] = 0;\n        pq.emplace(0, exit);\n    }\n\n    // Modified Dijkstra's algorithm to calculate shortest distances from exits\n    while (!pq.empty()) {\n        auto [cur_dist, u] = pq.top();\n        pq.pop();\n\n        // If the current distance is already greater, skip\n        if (cur_dist > dist[u]) continue;\n\n        // Relax edges\n        for (auto [v, weight] : graph[u]) {\n            if (dist[v] > cur_dist + weight) {\n                dist[v] = cur_dist + weight;\n                pq.emplace(dist[v], v);\n            }\n        }\n    }\n\n    // The result is the distance from the starting chamber (0) to the nearest exit\n    return dist[0];\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 16:48:47",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/A",
    "title": "A. Boxes",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "A",
    "submission_id": "314979931",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\n\nint64_t delivery(int N, int K, int L, std::vector<int> positions) {\n    // Sort the positions (they are already in non-decreasing order)\n    std::sort(positions.begin(), positions.end());\n\n    int64_t total_time = 0;\n\n    // Process the positions in chunks of size K\n    for (int i = N - 1; i >= 0; i -= K) {\n        // Maximum distance for this trip\n        int max_distance = std::min(positions[i], L - positions[i]);\n        // Add the round-trip time for this trip\n        total_time += 2 * max_distance;\n    }\n\n    return total_time;\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 16:49:28",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/A",
    "title": "A. Boxes",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "A",
    "submission_id": "314979931",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\nusing namespace std;\n\nint64_t delivery(int N, int K, int L, vector<int> positions) {\n    // Sort positions (already guaranteed in non-decreasing order by the problem)\n    sort(positions.begin(), positions.end());\n\n    int64_t total_time = 0;\n\n    // Process teams in chunks of size K\n    for (int i = 0; i < N; i += K) {\n        // Find the farthest team in the current chunk\n        int farthest = positions[min(i + K - 1, N - 1)];\n\n        // Calculate the time for this trip (clockwise and counterclockwise)\n        int64_t clockwise_time = 2 * farthest;                     // Go farthest clockwise and return\n        int64_t counterclockwise_time = 2 * (L - farthest);        // Go farthest counterclockwise and return\n\n        // Add the minimum time for this trip to the total time\n        total_time += min(clockwise_time, counterclockwise_time);\n    }\n\n    return total_time;\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 16:50:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/A",
    "title": "A. Boxes",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "A",
    "submission_id": "314980072",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\nusing namespace std;\n\nint64_t delivery(int N, int K, int L, vector<int> positions) {\n    // Split positions into trips and calculate the minimal time\n    int trips = (N + K - 1) / K; // Ceiling of N / K\n    int64_t total_time = 0;\n\n    // Process positions from the farthest to the nearest\n    for (int i = 0; i < trips; ++i) {\n        // Determine range of positions covered in this trip\n        int start = N - (i + 1) * K; // Start index of this trip\n        int end = N - i * K;         // End index (exclusive) of this trip\n        start = max(0, start);       // Ensure start is within bounds\n\n        // Farthest position in this trip\n        int farthest = positions[end - 1];\n\n        // Calculate the minimum time for this trip\n        int64_t clockwise_time = 2 * farthest;                          // Move clockwise to farthest and back\n        int64_t counterclockwise_time = 2 * (L - farthest);             // Move counterclockwise to farthest and back\n        total_time += min(clockwise_time, counterclockwise_time);       // Add the minimal time for this trip\n    }\n\n    return total_time;\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 16:50:54",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/A",
    "title": "A. Boxes",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "A",
    "submission_id": "314980169",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\n\nusing namespace std;\n\n// Function to calculate the minimum delivery time\nint64_t delivery(int N, int K, int L, vector<int> positions) {\n    // Calculate the shortest distance to each team\n    vector<int> distances(N);\n    for (int i = 0; i < N; ++i) {\n        int clockwise = positions[i]; // Distance moving clockwise\n        int counterclockwise = L - positions[i]; // Distance moving counterclockwise\n        distances[i] = min(clockwise, counterclockwise); // Shortest distance\n    }\n\n    // Sort distances (already sorted due to sorted positions)\n    // Group teams into trips of size at most K\n    int64_t total_time = 0;\n    for (int i = N - 1; i >= 0; i -= K) {\n        // Farthest distance in this group\n        int max_distance = distances[i];\n        // Each trip requires going to the farthest point and returning to 0\n        total_time += 2 * max_distance;\n    }\n\n    return total_time;\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 16:51:39",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/A",
    "title": "A. Boxes",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "A",
    "submission_id": "314980233",
    "code_index": 4,
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nint64_t delivery(int N, int K, int L, std::vector<int> positions) {\n    // Step 1: Sort positions (already given in non-decreasing order per problem description)\n    // Step 2: Divide the delivery into trips, where each trip delivers at most K souvenirs.\n\n    int64_t total_time = 0;\n\n    // Process positions in groups of K\n    for (int i = 0; i < N; i += K) {\n        // Find the farthest position in this group\n        int farthest_position = positions[std::min(i + K - 1, N - 1)];\n\n        // Compute the time for this trip:\n        // - Go to the farthest position\n        // - Return to section 0\n        int64_t trip_time = 2LL * std::min(farthest_position, L - farthest_position);\n\n        // Add the trip time to the total time\n        total_time += trip_time;\n    }\n\n    return total_time;\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 16:52:29",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/C",
    "title": "C. Teams",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "C",
    "submission_id": "314980327",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector<int> minTeamSize, maxTeamSize;\n\n// Function to initialize the students' constraints\nvoid init(int N, int A[], int B[]) {\n    minTeamSize.assign(A, A + N);\n    maxTeamSize.assign(B, B + N);\n}\n\n// Function to determine if the required teams can be formed\nint can(int M, int K[]) {\n    // Count the frequency of required team sizes\n    map<int, int> requiredTeams;\n    for (int i = 0; i < M; ++i) {\n        requiredTeams[K[i]]++;\n    }\n\n    // Count the availability of students for each possible team size\n    map<int, int> availableStudents;\n    for (int i = 0; i < minTeamSize.size(); ++i) {\n        for (int size = minTeamSize[i]; size <= maxTeamSize[i]; ++size) {\n            availableStudents[size]++;\n        }\n    }\n\n    // Try to satisfy the required teams using the available students\n    for (auto& [teamSize, count] : requiredTeams) {\n        if (availableStudents[teamSize] < count) {\n            return 0; // Not enough students for this team size\n        }\n        availableStudents[teamSize] -= count;\n    }\n\n    return 1; // All required teams can be formed\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 16:53:14",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/C",
    "title": "C. Teams",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "C",
    "submission_id": "314980404",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector<int> min_team_size, max_team_size;\nmap<int, int> team_size_availability;\n\nvoid init(int N, int A[], int B[]) {\n    // Store the min and max team sizes for each student\n    min_team_size.resize(N);\n    max_team_size.resize(N);\n    for (int i = 0; i < N; ++i) {\n        min_team_size[i] = A[i];\n        max_team_size[i] = B[i];\n    }\n    // Precompute the availability of team sizes\n    team_size_availability.clear();\n    for (int i = 0; i < N; ++i) {\n        for (int t = min_team_size[i]; t <= max_team_size[i]; ++t) {\n            ++team_size_availability[t];\n        }\n    }\n}\n\nint can(int M, int K[]) {\n    // Create a copy of the team size availability map\n    map<int, int> available = team_size_availability;\n\n    // Sort the required team sizes in descending order to try to fulfill larger teams first\n    vector<int> required_team_sizes(K, K + M);\n    sort(required_team_sizes.rbegin(), required_team_sizes.rend());\n\n    // Try to fulfill each required team size\n    for (int size : required_team_sizes) {\n        auto it = available.lower_bound(size);\n        if (it == available.end() || it->first < size) {\n            // If no suitable team size is available, return 0\n            return 0;\n        }\n        // Decrease the availability of the chosen team size\n        if (--it->second == 0) {\n            available.erase(it);\n        }\n    }\n\n    // If all required team sizes are fulfilled, return 1\n    return 1;\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 16:53:54",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/C",
    "title": "C. Teams",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "C",
    "submission_id": "314980404",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n// Global variables to store student constraints\nvector<int> min_team_size;\nvector<int> max_team_size;\n\n// Data structure to efficiently count students eligible for specific team sizes\nmap<int, int> size_count;\n\n// Initialize the data for all students\nvoid init(int N, int A[], int B[]) {\n    min_team_size.resize(N);\n    max_team_size.resize(N);\n    size_count.clear();\n\n    // Populate the constraints for students\n    for (int i = 0; i < N; ++i) {\n        min_team_size[i] = A[i];\n        max_team_size[i] = B[i];\n        // Increment the count for all sizes in the range [A[i], B[i]]\n        for (int size = A[i]; size <= B[i]; ++size) {\n            size_count[size]++;\n        }\n    }\n}\n\n// Check if it's possible to form the required teams for a given day\nint can(int M, int K[]) {\n    // Create a local copy of size_count to simulate assignment for this query\n    map<int, int> available_count = size_count;\n\n    // Sort the required team sizes in descending order\n    vector<int> required_sizes(K, K + M);\n    sort(required_sizes.rbegin(), required_sizes.rend());\n\n    // Try to satisfy each team size requirement\n    for (int size : required_sizes) {\n        // Find the smallest available size >= size\n        auto it = available_count.lower_bound(size);\n\n        if (it == available_count.end()) {\n            // No suitable size available\n            return 0;\n        }\n\n        // Decrement the count for the chosen size\n        it->second--;\n        if (it->second == 0) {\n            // Remove the size from the map if no students are left\n            available_count.erase(it);\n        }\n    }\n\n    // All team sizes were satisfied\n    return 1;\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 16:54:38",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/C",
    "title": "C. Teams",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "C",
    "submission_id": "314980550",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nvector<int> minTeamSize, maxTeamSize;\n\nvoid init(int N, int A[], int B[]) {\n    // Initialize the global variables for student constraints\n    minTeamSize.resize(N);\n    maxTeamSize.resize(N);\n    for (int i = 0; i < N; i++) {\n        minTeamSize[i] = A[i];\n        maxTeamSize[i] = B[i];\n    }\n}\n\nint can(int M, int K[]) {\n    // Count the number of students available for each possible team size\n    map<int, int> teamSizeAvailability;\n    for (int i = 0; i < minTeamSize.size(); i++) {\n        for (int size = minTeamSize[i]; size <= maxTeamSize[i]; size++) {\n            teamSizeAvailability[size]++;\n        }\n    }\n\n    // Count the required teams for each size\n    map<int, int> requiredTeams;\n    for (int i = 0; i < M; i++) {\n        requiredTeams[K[i]]++;\n    }\n\n    // Try to satisfy the required teams\n    for (auto& req : requiredTeams) {\n        int size = req.first;\n        int needed = req.second;\n\n        // Check if we have enough students for the required teams\n        if (teamSizeAvailability[size] < needed) {\n            return 0; // Not enough students for this team size\n        }\n\n        // Deduct the used students from availability\n        teamSizeAvailability[size] -= needed;\n    }\n\n    return 1; // All teams can be formed\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 16:55:22",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/C",
    "title": "C. Teams",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "C",
    "submission_id": "314980550",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector<int> minTeamSize;\nvector<int> maxTeamSize;\nmap<int, int> teamSizeAvailability;\n\nvoid init(int N, int A[], int B[]) {\n    minTeamSize.assign(A, A + N);\n    maxTeamSize.assign(B, B + N);\n    \n    // Compute the frequency of each team size that students can accommodate\n    teamSizeAvailability.clear();\n    for (int i = 0; i < N; ++i) {\n        for (int size = minTeamSize[i]; size <= maxTeamSize[i]; ++size) {\n            teamSizeAvailability[size]++;\n        }\n    }\n}\n\nint can(int M, int K[]) {\n    // Count required team sizes for the current day\n    map<int, int> requiredTeams;\n    for (int i = 0; i < M; ++i) {\n        requiredTeams[K[i]]++;\n    }\n    \n    // Check if required teams can be formed\n    for (auto &[size, count] : requiredTeams) {\n        if (teamSizeAvailability[size] < count) {\n            return 0; // Not enough students for this team size\n        }\n    }\n    \n    return 1; // All teams can be formed\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 16:56:08",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/C",
    "title": "C. Ricehub",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "C",
    "submission_id": "314980703",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\n\nusing namespace std;\n\nlong long calculate_cost(const vector<int>& X, int left, int right, int median, const vector<long long>& prefix_sum) {\n    long long left_sum = prefix_sum[median] - (left > 0 ? prefix_sum[left - 1] : 0);\n    long long right_sum = prefix_sum[right] - prefix_sum[median];\n    long long median_value = X[median];\n    long long left_cost = median_value * (median - left + 1) - left_sum;\n    long long right_cost = right_sum - median_value * (right - median);\n    return left_cost + right_cost;\n}\n\nint besthub(int R, int L, vector<int> X, long long B) {\n    vector<long long> prefix_sum(R, 0);\n    prefix_sum[0] = X[0];\n    for (int i = 1; i < R; ++i) {\n        prefix_sum[i] = prefix_sum[i - 1] + X[i];\n    }\n\n    int max_fields = 0;\n    int left = 0;\n\n    for (int right = 0; right < R; ++right) {\n        while (left <= right) {\n            int median = (left + right) / 2;\n            long long cost = calculate_cost(X, left, right, median, prefix_sum);\n            if (cost <= B) {\n                max_fields = max(max_fields, right - left + 1);\n                break;\n            }\n            ++left;\n        }\n    }\n\n    return max_fields;\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 16:56:51",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/C",
    "title": "C. Ricehub",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "C",
    "submission_id": "314980703",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\nusing namespace std;\n\nlong long calculate_cost(const vector<int>& X, int left, int right, int median_index) {\n    long long median = X[median_index];\n    long long cost = 0;\n\n    // Cost for fields to the left of the median\n    for (int i = left; i <= median_index; ++i) {\n        cost += median - X[i];\n    }\n\n    // Cost for fields to the right of the median\n    for (int i = median_index + 1; i <= right; ++i) {\n        cost += X[i] - median;\n    }\n\n    return cost;\n}\n\nint besthub(int R, int L, vector<int> X, long long B) {\n    vector<long long> prefix_sum(R + 1, 0);\n    for (int i = 0; i < R; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + X[i];\n    }\n\n    int max_fields = 0;\n    int left = 0;\n\n    for (int right = 0; right < R; ++right) {\n        int median_index = (left + right) / 2;\n        long long median = X[median_index];\n\n        // Calculate total cost using prefix sums\n        long long left_cost = median * (median_index - left + 1) - (prefix_sum[median_index + 1] - prefix_sum[left]);\n        long long right_cost = (prefix_sum[right + 1] - prefix_sum[median_index + 1]) - median * (right - median_index);\n        long long total_cost = left_cost + right_cost;\n\n        // Check if the cost exceeds the budget\n        while (total_cost > B) {\n            ++left; // Shrink the window from the left\n            median_index = (left + right) / 2;\n            median = X[median_index];\n            left_cost = median * (median_index - left + 1) - (prefix_sum[median_index + 1] - prefix_sum[left]);\n            right_cost = (prefix_sum[right + 1] - prefix_sum[median_index + 1]) - median * (right - median_index);\n            total_cost = left_cost + right_cost;\n        }\n\n        // Update the maximum number of fields\n        max_fields = max(max_fields, right - left + 1);\n    }\n\n    return max_fields;\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 16:57:33",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/C",
    "title": "C. Ricehub",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "C",
    "submission_id": "314980786",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\nlong long calculate_cost(int l, int r, const vector<long long>& prefix_sum, const vector<int>& X) {\n    int mid = (l + r) / 2;  // Median position\n    long long median = X[mid];\n    long long left_cost = median * (mid - l + 1) - (prefix_sum[mid + 1] - prefix_sum[l]);\n    long long right_cost = (prefix_sum[r + 1] - prefix_sum[mid + 1]) - median * (r - mid);\n    return left_cost + right_cost;\n}\n\nint besthub(int R, int L, vector<int> X, long long B) {\n    // Precompute prefix sums of coordinates\n    vector<long long> prefix_sum(R + 1, 0);\n    for (int i = 0; i < R; i++) {\n        prefix_sum[i + 1] = prefix_sum[i] + X[i];\n    }\n\n    int max_fields = 0;\n    int l = 0;  // Left pointer of the sliding window\n\n    // Sliding window over rice fields\n    for (int r = 0; r < R; r++) {\n        // Expand the window and calculate the cost\n        while (l <= r) {\n            long long cost = calculate_cost(l, r, prefix_sum, X);\n            if (cost <= B) {\n                max_fields = max(max_fields, r - l + 1);\n                break;\n            } else {\n                l++;  // Shrink the window from the left\n            }\n        }\n    }\n\n    return max_fields;\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 16:58:28",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/C",
    "title": "C. Ricehub",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "C",
    "submission_id": "314980948",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <climits>\n\nusing namespace std;\n\nlong long calculate_cost(const vector<int>& X, int start, int end, int median_index) {\n    long long cost = 0;\n    int median = X[median_index];\n    \n    // Calculate the cost for the left side of the median\n    for (int i = start; i <= median_index; ++i) {\n        cost += median - X[i];\n    }\n    \n    // Calculate the cost for the right side of the median\n    for (int i = median_index + 1; i <= end; ++i) {\n        cost += X[i] - median;\n    }\n    \n    return cost;\n}\n\nint besthub(int R, int L, vector<int> X, long long B) {\n    vector<long long> prefix_sum(R + 1, 0);\n\n    // Compute prefix sums of rice field coordinates\n    for (int i = 1; i <= R; ++i) {\n        prefix_sum[i] = prefix_sum[i - 1] + X[i - 1];\n    }\n\n    int max_truckloads = 0;\n\n    // Sliding window approach\n    for (int k = 1; k <= R; ++k) {\n        for (int start = 0; start + k - 1 < R; ++start) {\n            int end = start + k - 1;\n            int median_index = (start + end) / 2;\n\n            // Calculate total cost for the window\n            long long median = X[median_index];\n            long long left_cost = median * (median_index - start + 1) - (prefix_sum[median_index + 1] - prefix_sum[start]);\n            long long right_cost = (prefix_sum[end + 1] - prefix_sum[median_index + 1]) - median * (end - median_index);\n            long long total_cost = left_cost + right_cost;\n\n            if (total_cost <= B) {\n                max_truckloads = max(max_truckloads, k);\n            }\n        }\n    }\n\n    return max_truckloads;\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 16:59:32",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/C",
    "title": "C. Ricehub",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "C",
    "submission_id": "314981047",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\n\nusing namespace std;\n\nlong long calculate_cost(int left, int right, int median_index, const vector<long long>& prefix_sum, const vector<int>& X) {\n    long long median = X[median_index];\n    long long left_cost = median * (median_index - left + 1) - (prefix_sum[median_index + 1] - prefix_sum[left]);\n    long long right_cost = (prefix_sum[right + 1] - prefix_sum[median_index + 1]) - median * (right - median_index);\n    return left_cost + right_cost;\n}\n\nint besthub(int R, int L, vector<int> X, long long B) {\n    vector<long long> prefix_sum(R + 1, 0);\n    for (int i = 0; i < R; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + X[i];\n    }\n\n    int max_fields = 0;\n    int left = 0;\n    for (int right = 0; right < R; ++right) {\n        while (left <= right) {\n            int median_index = (left + right) / 2;\n            long long cost = calculate_cost(left, right, median_index, prefix_sum, X);\n            if (cost <= B) {\n                max_fields = max(max_fields, right - left + 1);\n                break;\n            } else {\n                ++left;\n            }\n        }\n    }\n\n    return max_fields;\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 17:00:30",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/B",
    "title": "B. Parachute rings",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "B",
    "submission_id": "314981152",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nvector<unordered_set<int>> adjacency_list;\nint num_rings;\n\nvoid Init(int N) {\n    num_rings = N;\n    adjacency_list.assign(N, unordered_set<int>());\n}\n\nvoid Link(int A, int B) {\n    adjacency_list[A].insert(B);\n    adjacency_list[B].insert(A);\n}\n\nbool isChain(const vector<unordered_set<int>>& graph) {\n    int chain_count = 0;\n    vector<bool> visited(num_rings, false);\n\n    for (int i = 0; i < num_rings; i++) {\n        if (!visited[i] && !graph[i].empty()) {\n            int start_nodes = 0, total_nodes = 0;\n            queue<int> q;\n            q.push(i);\n            visited[i] = true;\n\n            while (!q.empty()) {\n                int node = q.front();\n                q.pop();\n                total_nodes++;\n\n                int degree = 0;\n                for (int neighbor : graph[node]) {\n                    degree++;\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        q.push(neighbor);\n                    }\n                }\n\n                if (degree <= 1) start_nodes++;\n            }\n\n            if (start_nodes == 2 || total_nodes == 1) {\n                chain_count++;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint CountCritical() {\n    int critical_count = 0;\n\n    for (int i = 0; i < num_rings; i++) {\n        if (adjacency_list[i].empty()) continue;\n\n        vector<unordered_set<int>> temp_graph = adjacency_list;\n\n        for (int neighbor : adjacency_list[i]) {\n            temp_graph[neighbor].erase(i);\n        }\n        temp_graph[i].clear();\n\n        if (isChain(temp_graph)) {\n            critical_count++;\n        }\n    }\n\n    return critical_count;\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 17:01:15",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/B",
    "title": "B. Parachute rings",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "B",
    "submission_id": "314981152",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\n// Global variables to store the graph and necessary data\nvector<vector<int>> graph;\nvector<bool> visited;\nvector<int> discovery, low;\nvector<int> parent;\nunordered_set<int> articulation_points;\nint timer;\nint N;\n\n// Helper function to perform DFS and find articulation points\nvoid dfs(int u) {\n    visited[u] = true;\n    discovery[u] = low[u] = ++timer;\n    int children = 0;\n\n    for (int v : graph[u]) {\n        if (!visited[v]) {\n            children++;\n            parent[v] = u;\n            dfs(v);\n\n            // Update the low value of u\n            low[u] = min(low[u], low[v]);\n\n            // Check articulation point conditions\n            if (parent[u] == -1 && children > 1) { // Root node\n                articulation_points.insert(u);\n            }\n            if (parent[u] != -1 && low[v] >= discovery[u]) {\n                articulation_points.insert(u);\n            }\n        } else if (v != parent[u]) {\n            // Update low value of u for back edge\n            low[u] = min(low[u], discovery[v]);\n        }\n    }\n}\n\n// Function to initialize the graph with N rings\nvoid Init(int n) {\n    N = n;\n    graph.resize(N);\n    visited.resize(N, false);\n    discovery.resize(N, -1);\n    low.resize(N, -1);\n    parent.resize(N, -1);\n    articulation_points.clear();\n    timer = 0;\n}\n\n// Function to link two rings A and B\nvoid Link(int A, int B) {\n    graph[A].push_back(B);\n    graph[B].push_back(A);\n}\n\n// Function to count the number of critical rings\nint CountCritical() {\n    // Reset data structures\n    fill(visited.begin(), visited.end(), false);\n    fill(discovery.begin(), discovery.end(), -1);\n    fill(low.begin(), low.end(), -1);\n    fill(parent.begin(), parent.end(), -1);\n    articulation_points.clear();\n    timer = 0;\n\n    // Perform DFS to find articulation points\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n\n    return articulation_points.size();\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 17:01:56",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/B",
    "title": "B. Parachute rings",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "B",
    "submission_id": "314981250",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n\nusing namespace std;\n\nvector<unordered_set<int>> adjList;\nint numRings;\n\n// Initializes the graph with N nodes (rings).\nvoid Init(int N) {\n    numRings = N;\n    adjList.assign(N, unordered_set<int>());\n}\n\n// Links two nodes (rings) in the graph.\nvoid Link(int A, int B) {\n    adjList[A].insert(B);\n    adjList[B].insert(A);\n}\n\n// Helper function to check if a component is a chain.\nbool isChain(const unordered_set<int>& component) {\n    int endpointCount = 0;\n    for (int node : component) {\n        int degree = adjList[node].size();\n        if (degree > 2) return false;\n        if (degree == 1) endpointCount++;\n    }\n    return endpointCount == 2 || endpointCount == 0; // A chain has 2 endpoints or is a single node.\n}\n\n// Performs BFS to find all nodes in a component.\nunordered_set<int> getComponent(int start, vector<bool>& visited) {\n    unordered_set<int> component;\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        component.insert(node);\n\n        for (int neighbor : adjList[node]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    return component;\n}\n\n// Counts the number of critical rings.\nint CountCritical() {\n    int criticalCount = 0;\n\n    for (int i = 0; i < numRings; ++i) {\n        // Temporarily remove the node and its edges.\n        unordered_map<int, unordered_set<int>> tempEdges;\n        for (int neighbor : adjList[i]) {\n            tempEdges[neighbor].insert(i);\n            adjList[neighbor].erase(i);\n        }\n        adjList[i].clear();\n\n        // Check the connected components.\n        vector<bool> visited(numRings, false);\n        bool allChains = true;\n\n        for (int j = 0; j < numRings; ++j) {\n            if (!visited[j] && !adjList[j].empty()) {\n                auto component = getComponent(j, visited);\n                if (!isChain(component)) {\n                    allChains = false;\n                    break;\n                }\n            }\n        }\n\n        // Restore the node and its edges.\n        for (const auto& [neighbor, edges] : tempEdges) {\n            for (int edge : edges) {\n                adjList[neighbor].insert(edge);\n                adjList[edge].insert(neighbor);\n            }\n        }\n\n        // If the graph becomes all chains, the node is critical.\n        if (allChains) {\n            criticalCount++;\n        }\n    }\n\n    return criticalCount;\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 17:02:40",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/B",
    "title": "B. Parachute rings",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "B",
    "submission_id": "314981391",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n\nusing namespace std;\n\n// Adjacency list to represent the graph\nvector<unordered_set<int>> graph;\n// Degree of each node\nvector<int> degree;\n\n// Initialize the graph with N nodes\nvoid Init(int N) {\n    graph.resize(N);\n    degree.resize(N, 0);\n}\n\n// Add a link between nodes A and B\nvoid Link(int A, int B) {\n    graph[A].insert(B);\n    graph[B].insert(A);\n    degree[A]++;\n    degree[B]++;\n}\n\n// Helper function to check if a graph is a valid set of chains\nbool isValidChainSet(int N, int exclude) {\n    vector<bool> visited(N, false);\n    stack<int> s;\n\n    for (int i = 0; i < N; ++i) {\n        if (i == exclude || visited[i] || degree[i] == 0) continue;\n\n        // Perform a DFS to check the component connected to node i\n        s.push(i);\n        visited[i] = true;\n        int chainLength = 0; // Length of the current chain\n        int endpoints = 0;  // Count of endpoints (nodes with degree <= 1)\n        bool isCycle = false;\n\n        while (!s.empty()) {\n            int node = s.top();\n            s.pop();\n            chainLength++;\n\n            int neighbors = 0;\n            for (int neighbor : graph[node]) {\n                if (neighbor == exclude) continue;\n                if (!visited[neighbor]) {\n                    s.push(neighbor);\n                    visited[neighbor] = true;\n                    neighbors++;\n                }\n            }\n\n            // If a node has more than two neighbors, it's not a chain\n            if (neighbors > 2) return false;\n            if (neighbors == 1 || neighbors == 0) endpoints++;\n            if (neighbors == 0 && chainLength > 1) isCycle = true;\n        }\n\n        // For a valid chain, there must be exactly 2 endpoints\n        if ((chainLength > 1 && endpoints != 2) || isCycle) return false;\n    }\n\n    return true;\n}\n\n// Count the number of critical rings\nint CountCritical() {\n    int N = graph.size();\n    int criticalCount = 0;\n\n    for (int i = 0; i < N; ++i) {\n        if (degree[i] == 0) {\n            // Isolated nodes are always critical\n            criticalCount++;\n            continue;\n        }\n\n        // Temporarily remove node i\n        vector<int> neighbors;\n        for (int neighbor : graph[i]) {\n            neighbors.push_back(neighbor);\n            graph[neighbor].erase(i);\n            degree[neighbor]--;\n        }\n\n        // Check if the remaining graph is a valid set of chains\n        if (isValidChainSet(N, i)) {\n            criticalCount++;\n        }\n\n        // Restore node i\n        for (int neighbor : neighbors) {\n            graph[neighbor].insert(i);\n            degree[neighbor]++;\n        }\n    }\n\n    return criticalCount;\n}"
  },
  {
    "date": "IOI 2017 day 1",
    "timestamp": "2025-04-11 17:03:33",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103774/problem/C",
    "title": "C. Toy Train",
    "group_id": "32KGsXgiKA",
    "contest_id": "103774",
    "problem_index": "C",
    "submission_id": "314981492",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<int> who_wins(vector<int> a, vector<int> r, vector<int> u, vector<int> v) {\n    int n = a.size();\n    int m = u.size();\n    \n    // Adjacency list representation of the graph and reverse graph\n    vector<vector<int>> adj(n), reverse_adj(n);\n    vector<int> out_degree(n, 0); // Out-degree for each node\n    \n    // Build the graph and reverse graph\n    for (int i = 0; i < m; i++) {\n        adj[u[i]].push_back(v[i]);\n        reverse_adj[v[i]].push_back(u[i]);\n        out_degree[u[i]]++;\n    }\n    \n    // Winning state for each station: 1 = Arezou wins, 0 = Borzou wins\n    vector<int> win(n, 0);\n    queue<int> q;\n    \n    // Initialize the queue with all charging stations\n    for (int i = 0; i < n; i++) {\n        if (r[i] == 1) {\n            win[i] = 1; // Charging stations are winning states\n            q.push(i);\n        }\n    }\n    \n    // Propagate winning states in reverse graph\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        \n        for (int prev : reverse_adj[curr]) {\n            if (win[prev] == 1) continue; // Already determined as winning\n            \n            if (a[prev] == 1) {\n                // Arezou's station: If any outgoing leads to a win, she wins\n                win[prev] = 1;\n                q.push(prev);\n            } else {\n                // Borzou's station: All outgoing must lead to losing for her to lose\n                out_degree[prev]--;\n                if (out_degree[prev] == 0) {\n                    win[prev] = 1;\n                    q.push(prev);\n                }\n            }\n        }\n    }\n    \n    return win;\n}"
  },
  {
    "date": "IOI 2017 day 1",
    "timestamp": "2025-04-11 17:04:19",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103774/problem/C",
    "title": "C. Toy Train",
    "group_id": "32KGsXgiKA",
    "contest_id": "103774",
    "problem_index": "C",
    "submission_id": "314981566",
    "code_index": 1,
    "code": "#include <vector>\n#include <queue>\nusing namespace std;\n\n// Your code will be placed here\nvector<int> who_wins(vector<int> a, vector<int> r, vector<int> u, vector<int> v) {\n    int n = a.size();\n    int m = u.size();\n\n    // Graph representation\n    vector<vector<int>> graph(n), reverse_graph(n); // Forward and reverse edges\n    for (int i = 0; i < m; ++i) {\n        graph[u[i]].push_back(v[i]);\n        reverse_graph[v[i]].push_back(u[i]);\n    }\n\n    vector<int> result(n, 0);  // Result array: 1 if Arezou wins, 0 otherwise\n    vector<int> can_win(n, 0); // Whether the station is part of a \"winning\" cycle\n    vector<int> out_degree(n, 0); // Number of outgoing edges per station\n\n    // Compute out-degrees\n    for (int i = 0; i < n; ++i) {\n        out_degree[i] = graph[i].size();\n    }\n\n    // Queue for processing stations\n    queue<int> q;\n\n    // Initialize the queue with charging stations\n    for (int i = 0; i < n; ++i) {\n        if (r[i] == 1) { // Charging station\n            can_win[i] = 1;\n            q.push(i);\n        }\n    }\n\n    // Process stations in reverse topological order\n    while (!q.empty()) {\n        int station = q.front();\n        q.pop();\n\n        for (int prev_station : reverse_graph[station]) {\n            if (a[prev_station] == 1) { // Arezou owns the station\n                if (can_win[prev_station] == 0) { // Not yet marked as winning\n                    can_win[prev_station] = 1;\n                    q.push(prev_station);\n                }\n            } else { // Borzou owns the station\n                out_degree[prev_station]--;\n                if (out_degree[prev_station] == 0 && can_win[prev_station] == 0) {\n                    can_win[prev_station] = 1;\n                    q.push(prev_station);\n                }\n            }\n        }\n    }\n\n    // Determine the result for each starting station\n    for (int i = 0; i < n; ++i) {\n        result[i] = can_win[i];\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2017 day 1",
    "timestamp": "2025-04-11 17:05:03",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103774/problem/C",
    "title": "C. Toy Train",
    "group_id": "32KGsXgiKA",
    "contest_id": "103774",
    "problem_index": "C",
    "submission_id": "314981566",
    "code_index": 2,
    "code": "#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to perform Tarjan's SCC algorithm\nvoid tarjan(int node, int& index, vector<int>& indices, vector<int>& lowLink, stack<int>& stk, vector<bool>& onStack, const vector<vector<int>>& adj, vector<vector<int>>& sccs) {\n    indices[node] = lowLink[node] = index++;\n    stk.push(node);\n    onStack[node] = true;\n\n    for (int neighbor : adj[node]) {\n        if (indices[neighbor] == -1) {\n            tarjan(neighbor, index, indices, lowLink, stk, onStack, adj, sccs);\n            lowLink[node] = min(lowLink[node], lowLink[neighbor]);\n        } else if (onStack[neighbor]) {\n            lowLink[node] = min(lowLink[node], indices[neighbor]);\n        }\n    }\n\n    if (lowLink[node] == indices[node]) {\n        vector<int> scc;\n        int member;\n        do {\n            member = stk.top();\n            stk.pop();\n            onStack[member] = false;\n            scc.push_back(member);\n        } while (member != node);\n        sccs.push_back(scc);\n    }\n}\n\nvector<int> who_wins(vector<int> a, vector<int> r, vector<int> u, vector<int> v) {\n    int n = a.size();\n    int m = u.size();\n\n    // Build adjacency list\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < m; ++i) {\n        adj[u[i]].push_back(v[i]);\n    }\n\n    // Tarjan's SCC algorithm\n    vector<int> indices(n, -1), lowLink(n, -1);\n    vector<bool> onStack(n, false);\n    stack<int> stk;\n    vector<vector<int>> sccs;\n    int index = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (indices[i] == -1) {\n            tarjan(i, index, indices, lowLink, stk, onStack, adj, sccs);\n        }\n    }\n\n    // Determine if each SCC has a charging station\n    vector<bool> sccHasCharging;\n    vector<int> nodeToSCC(n, -1);\n    for (int i = 0; i < sccs.size(); ++i) {\n        bool hasCharging = false;\n        for (int node : sccs[i]) {\n            nodeToSCC[node] = i;\n            if (r[node] == 1) {\n                hasCharging = true;\n            }\n        }\n        sccHasCharging.push_back(hasCharging);\n    }\n\n    // Determine the winning strategy for each station\n    vector<int> result(n, 0);\n    vector<bool> canWin(n, false);\n\n    for (int i = 0; i < n; ++i) {\n        int scc = nodeToSCC[i];\n        if (sccHasCharging[scc]) {\n            canWin[i] = true;\n        }\n    }\n\n    // Propagate winning statuses\n    for (int i = 0; i < n; ++i) {\n        if (canWin[i]) {\n            result[i] = 1;\n        } else {\n            result[i] = 0;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2017 day 1",
    "timestamp": "2025-04-11 17:05:45",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103774/problem/C",
    "title": "C. Toy Train",
    "group_id": "32KGsXgiKA",
    "contest_id": "103774",
    "problem_index": "C",
    "submission_id": "314981724",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> who_wins(vector<int> a, vector<int> r, vector<int> u, vector<int> v) {\n    int n = a.size();\n    int m = u.size();\n    \n    // Build adjacency list\n    vector<vector<int>> adj(n), reverse_adj(n);\n    for (int i = 0; i < m; ++i) {\n        adj[u[i]].push_back(v[i]);\n        reverse_adj[v[i]].push_back(u[i]);\n    }\n    \n    // Step 1: Identify all nodes in cycles that can recharge\n    vector<int> in_cycle(n, 0); // 1 if in a cycle that can recharge\n    vector<int> visited(n, 0);\n    stack<int> topo_order;\n    vector<int> reachable_from_cycle(n, 0); // 1 if reachable from a cycle that can recharge\n    \n    // Perform DFS to find all nodes in cycles\n    function<void(int)> dfs = [&](int node) {\n        visited[node] = 1;\n        for (int neighbor : adj[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            } else if (visited[neighbor] == 1) {\n                // Found a cycle\n                stack<int> cycle_nodes;\n                cycle_nodes.push(neighbor);\n                while (!cycle_nodes.empty()) {\n                    int cycle_node = cycle_nodes.top();\n                    cycle_nodes.pop();\n                    in_cycle[cycle_node] = 1;\n                    for (int cycle_neighbor : adj[cycle_node]) {\n                        if (!in_cycle[cycle_neighbor]) cycle_nodes.push(cycle_neighbor);\n                    }\n                }\n            }\n        }\n        visited[node] = 2;\n        topo_order.push(node);\n    };\n    \n    // TODO: Finish implementation\n    // TODO: Implement propagation logic\n    return w;\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 17:07:32",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/C",
    "title": "C. Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "C",
    "submission_id": "314981910",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\n    int components;\n\npublic:\n    UnionFind(int n) : parent(n), rank(n, 0), components(n) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    bool unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX == rootY) {\n            return false; // Already in the same set\n        }\n\n        // Union by rank\n        if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n\n        components--;\n        return true;\n    }\n\n    int getComponents() const {\n        return components;\n    }\n};\n\nUnionFind* uf;\nint numCities;\n\nvoid initialize(int n) {\n    numCities = n;\n    uf = new UnionFind(n);\n}\n\nint hasEdge(int u, int v) {\n    // If adding this edge would NOT reduce the number of connected components to 1, add it\n    if (uf->getComponents() > 1 && uf->find(u) != uf->find(v)) {\n        uf->unionSets(u, v);\n        return 1; // Add the edge\n    } else {\n        return 0; // Do not add the edge\n    }\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 17:08:14",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/C",
    "title": "C. Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "C",
    "submission_id": "314981910",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nclass FlightNetwork {\nprivate:\n    vector<int> parent, rank;\n    int connectedComponents;\n\n    // Find function with path compression\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    // Union function with union by rank\n    bool unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            connectedComponents--;\n            return true; // A union was performed\n        }\n        return false; // No union was performed\n    }\n\npublic:\n    // Initialize the DSU for n cities\n    void initialize(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        connectedComponents = n;\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    // Answer whether there is a direct flight between u and v\n    int hasEdge(int u, int v) {\n        // If connecting u and v reduces the number of connected components, answer \"yes\" (1)\n        if (unionSets(u, v)) {\n            return 1;\n        }\n        // Otherwise, answer \"no\" (0)\n        return 0;\n    }\n};\n\n// Instantiate the class for the grader\nFlightNetwork flightNetwork;\n\n// Initialize function\nvoid initialize(int n) {\n    flightNetwork.initialize(n);\n}\n\n// hasEdge function\nint hasEdge(int u, int v) {\n    return flightNetwork.hasEdge(u, v);\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 17:08:56",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/C",
    "title": "C. Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "C",
    "submission_id": "314982058",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <numeric>\n\nusing namespace std;\n\nclass Game {\nprivate:\n    int n;\n    vector<int> parent;\n    vector<int> rank;\n    int components;\n\n    // Find function for union-find (with path compression)\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    // Union function for union-find (with union by rank)\n    bool unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX == rootY) {\n            return false; // x and y are already in the same component\n        }\n\n        if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n\n        components--; // Merge two components\n        return true;\n    }\n\npublic:\n    // Initialize the game\n    void initialize(int n) {\n        this->n = n;\n        parent.resize(n);\n        rank.resize(n, 0);\n        iota(parent.begin(), parent.end(), 0); // Initialize each node as its own parent\n        components = n; // Initially, each city is its own component\n    }\n\n    // Answer whether to create an edge\n    int hasEdge(int u, int v) {\n        // If the number of components is greater than 1, add an edge to reduce components\n        if (components > 1) {\n            if (unite(u, v)) {\n                return 1; // Add the edge\n            }\n        }\n        // Otherwise, refuse to add the edge to delay full connectivity\n        return 0;\n    }\n};\n\n// Global instance of the Game class\nGame game;\n\nvoid initialize(int n) {\n    game.initialize(n);\n}\n\nint hasEdge(int u, int v) {\n    return game.hasEdge(u, v);\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 17:09:35",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/C",
    "title": "C. Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "C",
    "submission_id": "314982058",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nclass DisjointSetUnion {\npublic:\n    vector<int> parent, rank;\n    \n    DisjointSetUnion(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nDisjointSetUnion* dsu;\nint numCities;\n\nvoid initialize(int n) {\n    numCities = n;\n    dsu = new DisjointSetUnion(n);\n}\n\nint hasEdge(int u, int v) {\n    if (dsu->find(u) == dsu->find(v)) {\n        // u and v are already connected, no edge is added\n        return 0;\n    } else {\n        // Add an edge between u and v\n        dsu->unite(u, v);\n        return 1;\n    }\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 17:10:27",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/D",
    "title": "D. Paint By Numbers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "D",
    "submission_id": "314982214",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nstring solve_puzzle(string s, vector<int> c) {\n    int n = s.size();\n    int k = c.size();\n    vector<string> valid_solutions;\n\n    // Helper function to check if a solution matches the given constraints\n    auto is_valid = [&](const string& solution) -> bool {\n        for (int i = 0; i < n; ++i) {\n            if (s[i] != '.' && s[i] != solution[i]) {\n                return false; // Conflict with given constraints\n            }\n        }\n        return true;\n    };\n\n    // Recursive function to generate all valid solutions\n    function<void(int, int, string)> backtrack = [&](int block_index, int start, string current) {\n        if (block_index == k) {\n            // All blocks placed, fill the remaining with '_'\n            current.append(n - current.size(), '_');\n            if (is_valid(current)) {\n                valid_solutions.push_back(current);\n            }\n            return;\n        }\n\n        // Try placing the current block in all valid positions\n        for (int i = start; i + c[block_index] <= n; ++i) {\n            // Check the block fits without conflicting with existing black or white cells\n            bool can_place = true;\n            for (int j = 0; j < c[block_index]; ++j) {\n                if (current.size() > i + j && current[i + j] == '_') {\n                    can_place = false;\n                    break;\n                }\n            }\n            if (!can_place) continue;\n\n            // Place the block\n            string next = current;\n            next.append(i - current.size(), '_'); // Fill gaps with '_'\n            next.append(c[block_index], 'X');    // Add the block of 'X'\n\n            // Add a separating '_' for the next block if it's not the last one\n            if (block_index < k - 1) next += '_';\n\n            // Recurse to place the next block\n            backtrack(block_index + 1, next.size(), next);\n        }\n    };\n\n    // Start generating valid solutions\n    backtrack(0, 0, \"\");\n\n    // Determine the result by comparing all valid solutions\n    string result(n, '?');\n    for (int i = 0; i < n; ++i) {\n        bool all_black = true, all_white = true;\n        for (const auto& solution : valid_solutions) {\n            if (solution[i] != 'X') all_black = false;\n            if (solution[i] != '_') all_white = false;\n        }\n        if (all_black) result[i] = 'X';\n        else if (all_white) result[i] = '_';\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 17:11:08",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/D",
    "title": "D. Paint By Numbers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "D",
    "submission_id": "314982275",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvoid backtrack(int idx, int start, const vector<int>& c, const string& s, vector<string>& solutions, string& current) {\n    int n = s.size();\n    int k = c.size();\n    if (idx == k) {\n        // Check if the solution respects the constraints in `s`\n        for (int i = 0; i < n; ++i) {\n            if (s[i] != '.' && s[i] != current[i]) {\n                return; // Invalid solution\n            }\n        }\n        solutions.push_back(current);\n        return;\n    }\n\n    // Try placing the current block starting from position `start`\n    for (int i = start; i <= n - c[idx]; ++i) {\n        // Check if we can place the block here\n        bool canPlace = true;\n        for (int j = 0; j < c[idx]; ++j) {\n            if (s[i + j] == '_') {\n                canPlace = false;\n                break;\n            }\n        }\n        if (!canPlace) continue;\n\n        // Place the block\n        for (int j = 0; j < c[idx]; ++j) {\n            current[i + j] = 'X';\n        }\n        if (i + c[idx] < n) current[i + c[idx]] = '_'; // Add a separator if not at the end\n\n        // Recurse to place the next block\n        backtrack(idx + 1, i + c[idx] + 1, c, s, solutions, current);\n\n        // Undo the placement\n        for (int j = 0; j < c[idx]; ++j) {\n            current[i + j] = '.';\n        }\n        if (i + c[idx] < n) current[i + c[idx]] = '.';\n    }\n}\n\nstring solve_puzzle(string s, vector<int> c) {\n    int n = s.size();\n    vector<string> solutions;\n    string current(n, '.');\n\n    // Generate all valid solutions\n    backtrack(0, 0, c, s, solutions, current);\n\n    // Determine the result string\n    string result(n, '?');\n    for (int i = 0; i < n; ++i) {\n        bool all_black = true, all_white = true;\n        for (const string& solution : solutions) {\n            if (solution[i] == 'X') all_white = false;\n            if (solution[i] == '_') all_black = false;\n        }\n        if (all_black) result[i] = 'X';\n        else if (all_white) result[i] = '_';\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 17:11:49",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/D",
    "title": "D. Paint By Numbers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "D",
    "submission_id": "314982340",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nvoid generate_configurations(int n, const vector<int>& c, int idx, int pos, string& current, vector<string>& results) {\n    if (idx == c.size()) {\n        // If we have placed all blocks, fill the rest with '_'\n        while (pos < n) current[pos++] = '_';\n        results.push_back(current);\n        return;\n    }\n\n    // Try placing the current block `c[idx]` starting at position `pos`\n    for (int i = pos; i + c[idx] <= n; ++i) {\n        // Fill the block with 'X'\n        for (int j = 0; j < c[idx]; ++j) current[i + j] = 'X';\n        // Add a separating '_' if there's a next block\n        if (i + c[idx] < n) current[i + c[idx]] = '_';\n\n        // Recursively place the next block\n        generate_configurations(n, c, idx + 1, i + c[idx] + 1, current, results);\n\n        // Undo the changes for backtracking\n        for (int j = 0; j < c[idx]; ++j) current[i + j] = '.';\n        if (i + c[idx] < n) current[i + c[idx]] = '.';\n    }\n}\n\nstring solve_puzzle(string s, vector<int> c) {\n    int n = s.size();\n    vector<string> valid_configs;\n\n    // Generate all valid configurations\n    string current(n, '.');\n    generate_configurations(n, c, 0, 0, current, valid_configs);\n\n    // Filter configurations that match the known cells in `s`\n    vector<string> filtered_configs;\n    for (const string& config : valid_configs) {\n        bool matches = true;\n        for (int i = 0; i < n; ++i) {\n            if (s[i] != '.' && s[i] != config[i]) {\n                matches = false;\n                break;\n            }\n        }\n        if (matches) filtered_configs.push_back(config);\n    }\n\n    // Deduce the result by analyzing the filtered configurations\n    string result(n, '?');\n    for (int i = 0; i < n; ++i) {\n        bool all_black = true, all_white = true;\n        for (const string& config : filtered_configs) {\n            if (config[i] != 'X') all_black = false;\n            if (config[i] != '_') all_white = false;\n        }\n        if (all_black) result[i] = 'X';\n        else if (all_white) result[i] = '_';\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 17:12:43",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/D",
    "title": "D. Paint By Numbers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "D",
    "submission_id": "314982427",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\nstring solve_puzzle(string s, vector<int> c) {\n    int n = s.size();\n    int k = c.size();\n    vector<string> solutions;\n\n    // Helper function to recursively generate valid solutions\n    function<void(int, int, string)> generate = [&](int idx, int clue_idx, string current) {\n        // If we've placed all clues, check if the rest of the string is valid\n        if (clue_idx == k) {\n            for (int i = idx; i < n; ++i) {\n                if (s[i] == 'X') return; // Invalid if a cell must be black\n                current[i] = '_';\n            }\n            solutions.push_back(current);\n            return;\n        }\n\n        // Try placing the current block starting from idx\n        for (int start = idx; start + c[clue_idx] - 1 < n; ++start) {\n            // Check if we can place the block here\n            bool can_place = true;\n            for (int i = 0; i < c[clue_idx]; ++i) {\n                if (s[start + i] == '_') {\n                    can_place = false;\n                    break;\n                }\n            }\n            if (!can_place) continue;\n\n            // Create a copy of the current string\n            string next = current;\n            // Place the block\n            for (int i = 0; i < c[clue_idx]; ++i)\n                next[start + i] = 'X';\n            // Add a separator if not the last block\n            if (start + c[clue_idx] < n)\n                next[start + c[clue_idx]] = '_';\n\n            // Recur for the next block\n            generate(start + c[clue_idx] + 1, clue_idx + 1, next);\n        }\n    };\n\n    // Start generating solutions\n    generate(0, 0, string(n, '.'));\n\n    // Deduce the final state\n    string result(n, '?');\n    for (int i = 0; i < n; ++i) {\n        char common = solutions[0][i];\n        bool all_same = true;\n        for (const string &sol : solutions) {\n            if (sol[i] != common) {\n                all_same = false;\n                break;\n            }\n        }\n        if (all_same) result[i] = common;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 17:13:27",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/D",
    "title": "D. Paint By Numbers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "D",
    "submission_id": "314982427",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstring solve_puzzle(string s, vector<int> c) {\n    int n = s.size();\n    int k = c.size();\n\n    // Helper function to generate all possible valid solutions for a given configuration\n    auto generate_solutions = [&](vector<int>& c) -> vector<string> {\n        vector<string> solutions;\n        int total_blocks = 0;\n        for (int len : c) total_blocks += len;\n        total_blocks += (k - 1); // Add space for (k-1) separators\n\n        // If the total is greater than n, it's invalid\n        if (total_blocks > n) return solutions;\n\n        // Generate all valid placements of c blocks in the string\n        vector<int> separators(k + 1, 0);\n        separators[0] = 0;\n        separators[k] = n - total_blocks;\n\n        // Distribute separators among k+1 gaps\n        do {\n            string current(n, '_');\n            int pos = 0;\n            for (int i = 0; i < k; ++i) {\n                pos += separators[i];\n                for (int j = 0; j < c[i]; ++j) {\n                    current[pos++] = 'X';\n                }\n                ++pos; // Skip 1 space for separator\n            }\n            solutions.push_back(current);\n        } while (next_permutation(separators + 1, separators + k + 1)); // Permute separators\n\n        return solutions;\n    };\n\n    // Generate all possible solutions\n    vector<string> possible_solutions = generate_solutions(c);\n\n    // Filter solutions based on the given string s\n    vector<string> valid_solutions;\n    for (const string& solution : possible_solutions) {\n        bool is_valid = true;\n        for (int i = 0; i < n; ++i) {\n            if (s[i] == 'X' && solution[i] != 'X') {\n                is_valid = false;\n                break;\n            }\n            if (s[i] == '_' && solution[i] != '_') {\n                is_valid = false;\n                break;\n            }\n        }\n        if (is_valid) {\n            valid_solutions.push_back(solution);\n        }\n    }\n\n    // Determine the result string\n    string result(n, '?');\n    for (int i = 0; i < n; ++i) {\n        bool all_black = true, all_white = true;\n        for (const string& solution : valid_solutions) {\n            if (solution[i] != 'X') all_black = false;\n            if (solution[i] != '_') all_white = false;\n        }\n        if (all_black) result[i] = 'X';\n        else if (all_white) result[i] = '_';\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 17:14:25",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/A",
    "title": "A. Catfish Farm",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "A",
    "submission_id": "314982620",
    "code_index": 0,
    "code": "#include <vector>\n#include <map>\n#include <algorithm>\n#include <cstdint>\n\nusing namespace std;\n\n// Your code will be placed here\nint64_t max_weights(int N, int M, vector<int> X, vector<int> Y, vector<int> W) {\n    // Step 1: Group catfish by column\n    map<int, vector<pair<int, int>>> columnCatfish; // column -> [(row, weight)]\n    for (int i = 0; i < M; ++i) {\n        columnCatfish[X[i]].emplace_back(Y[i], W[i]);\n    }\n\n    // Step 2: Process columns to maximize weights\n    map<int, int64_t> dp; // dp[column] = max weight we can achieve up to this column\n    for (const auto& [column, catfish] : columnCatfish) {\n        // Sort catfish in this column by row for easier processing\n        vector<pair<int, int>> sortedCatfish = catfish;\n        sort(sortedCatfish.begin(), sortedCatfish.end());\n\n        // Determine the maximum weight that can be achieved for this column\n        int64_t currentColumnMax = 0;\n        for (const auto& [row, weight] : sortedCatfish) {\n            currentColumnMax += weight; // Sum up all weights in this column\n        }\n\n        // Update dp for this column\n        dp[column] = currentColumnMax;\n        if (dp.find(column - 1) != dp.end()) {\n            dp[column] = max(dp[column], dp[column - 1] + currentColumnMax);\n        }\n        if (dp.find(column - 2) != dp.end()) {\n            dp[column] = max(dp[column], dp[column - 2] + currentColumnMax);\n        }\n    }\n\n    // Step 3: Find the maximum weight across all columns\n    int64_t maxWeight = 0;\n    for (const auto& [column, weight] : dp) {\n        maxWeight = max(maxWeight, weight);\n    }\n    \n    return maxWeight;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 17:15:09",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/A",
    "title": "A. Catfish Farm",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "A",
    "submission_id": "314982714",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <numeric>\n#include <cstdint>\n\nusing namespace std;\n\nint64_t max_weights(int N, int M, vector<int> X, vector<int> Y, vector<int> W) {\n    // Step 1: Group catfish by columns\n    unordered_map<int, vector<pair<int, int>>> columnMap; // column -> { (row, weight) }\n    for (int i = 0; i < M; ++i) {\n        columnMap[X[i]].emplace_back(Y[i], W[i]);\n    }\n\n    // Step 2: Process each column\n    map<int, int64_t> columnMaxCatch; // column -> max weight catchable if pier is built there\n    for (auto& [col, catfish] : columnMap) {\n        // Sort catfish by row in this column\n        sort(catfish.begin(), catfish.end());\n\n        // DP to find the maximum weight catchable in this column\n        int64_t maxCatch = 0;\n        int64_t currentWeight = 0;\n        int prevRow = -1;\n\n        for (auto& [row, weight] : catfish) {\n            // If there's a gap in pier coverage, reset the current weight\n            if (prevRow != -1 && row != prevRow + 1) {\n                currentWeight = 0;\n            }\n\n            currentWeight += weight;\n            maxCatch = max(maxCatch, currentWeight);\n            prevRow = row;\n        }\n\n        columnMaxCatch[col] = maxCatch;\n    }\n\n    // Step 3: Calculate total max weight\n    int64_t totalMaxWeight = 0;\n    for (auto& [col, maxCatch] : columnMaxCatch) {\n        int64_t leftNeighbor = columnMaxCatch.count(col - 1) ? columnMaxCatch[col - 1] : 0;\n        int64_t rightNeighbor = columnMaxCatch.count(col + 1) ? columnMaxCatch[col + 1] : 0;\n\n        // Maximum weight catchable considering this column and its neighbors\n        totalMaxWeight = max(totalMaxWeight, maxCatch + max(leftNeighbor, rightNeighbor));\n    }\n\n    return totalMaxWeight;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 17:15:51",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/A",
    "title": "A. Catfish Farm",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "A",
    "submission_id": "314982714",
    "code_index": 2,
    "code": "#include <vector>\n#include <map>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n// Your code will be placed here\nint64_t max_weights(int N, int M, vector<int> X, vector<int> Y, vector<int> W) {\n    // Group catfish by columns\n    map<int, vector<pair<int, int>>> columnCatfish; // column -> [(row, weight)]\n    for (int i = 0; i < M; i++) {\n        columnCatfish[X[i]].emplace_back(Y[i], W[i]);\n    }\n\n    // Columns that have catfish\n    vector<int> columns;\n    for (auto &[col, _] : columnCatfish) {\n        columns.push_back(col);\n    }\n    sort(columns.begin(), columns.end());\n\n    int numColumns = columns.size();\n    map<int, int> columnIndex; // Map column to index\n    for (int i = 0; i < numColumns; i++) {\n        columnIndex[columns[i]] = i;\n    }\n\n    // DP array\n    vector<int64_t> dp(numColumns, 0);\n\n    // Helper function to calculate maximum weight for a pier at a column\n    auto calculatePierWeight = [&](int colIndex, int pierLength) -> int64_t {\n        int col = columns[colIndex];\n        int64_t weight = 0;\n\n        for (auto &[row, w] : columnCatfish[col]) {\n            if (row < pierLength) {\n                weight += w;\n            }\n        }\n        return weight;\n    };\n\n    // Process each column\n    for (int i = 0; i < numColumns; i++) {\n        // Option 1: Do not build a pier in this column\n        dp[i] = (i > 0 ? dp[i - 1] : 0);\n\n        // Option 2: Build a pier in this column\n        int col = columns[i];\n        int64_t maxWeightWithPier = 0;\n\n        for (auto &[row, w] : columnCatfish[col]) {\n            // Try different pier lengths\n            for (int pierLength = 1; pierLength <= row + 1; pierLength++) {\n                int64_t pierWeight = calculatePierWeight(i, pierLength);\n\n                // Add contribution from previous column\n                int64_t totalWeight = pierWeight + (i > 0 ? dp[i - 1] : 0);\n                maxWeightWithPier = max(maxWeightWithPier, totalWeight);\n            }\n        }\n\n        dp[i] = max(dp[i], maxWeightWithPier);\n    }\n\n    return dp[numColumns - 1];\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 17:16:32",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/A",
    "title": "A. Catfish Farm",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "A",
    "submission_id": "314982869",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <cstdint>\nusing namespace std;\n\nint64_t max_weights(int N, int M, vector<int> X, vector<int> Y, vector<int> W) {\n    // Map to store catfish data per column\n    unordered_map<int, vector<pair<int, int>>> catfish_by_column; // {column, [(row, weight)]}\n    \n    for (int i = 0; i < M; i++) {\n        catfish_by_column[X[i]].emplace_back(Y[i], W[i]);\n    }\n    \n    // To store the maximum weight catchable\n    int64_t max_weight = 0;\n    \n    // Map to store the maximum weight catchable for each column\n    unordered_map<int, int64_t> column_weight;\n\n    // Iterate through all unique columns with catfish\n    for (const auto& [col, catfish] : catfish_by_column) {\n        // Sort the catfish in this column by row\n        vector<pair<int, int>> sorted_catfish = catfish;\n        sort(sorted_catfish.begin(), sorted_catfish.end());\n        \n        // Compute the maximum weight we can catch by placing a pier in this column\n        int64_t current_weight = 0;\n        int64_t column_max_weight = 0;\n\n        for (const auto& [row, weight] : sorted_catfish) {\n            current_weight += weight;\n            column_max_weight = max(column_max_weight, current_weight);\n        }\n        column_weight[col] = column_max_weight;\n    }\n    \n    // Iterate through all columns and consider neighboring columns\n    for (const auto& [col, weight] : column_weight) {\n        int64_t left_weight = column_weight.count(col - 1) ? column_weight[col - 1] : 0;\n        int64_t right_weight = column_weight.count(col + 1) ? column_weight[col + 1] : 0;\n        max_weight = max(max_weight, weight + max(left_weight, right_weight));\n    }\n    \n    return max_weight;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 17:17:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/A",
    "title": "A. Catfish Farm",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "A",
    "submission_id": "314982937",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <cstdint>\nusing namespace std;\n\nint64_t max_weights(int N, int M, vector<int> X, vector<int> Y, vector<int> W) {\n    // Group catfish by column\n    unordered_map<int, vector<pair<int, int>>> columns; // column -> (row, weight)\n    for (int i = 0; i < M; ++i) {\n        columns[X[i]].emplace_back(Y[i], W[i]);\n    }\n\n    // DP array to store max weights for each column\n    vector<int64_t> dp(N, 0);\n\n    // Process each column\n    for (auto& [col, fish] : columns) {\n        // Sort catfish in this column by row\n        sort(fish.begin(), fish.end());\n\n        // Prefix sums for weights\n        int K = fish.size();\n        vector<int64_t> prefixSum(K + 1, 0);\n        for (int i = 0; i < K; ++i) {\n            prefixSum[i + 1] = prefixSum[i] + fish[i].second;\n        }\n\n        // Max weight calculation for this column\n        int64_t maxWeight = 0;\n\n        // Try all possible pier lengths\n        for (int len = 1; len <= N; ++len) {\n            int64_t currentWeight = 0;\n\n            // Consider all possible pier placements\n            for (int i = 0; i < K; ++i) {\n                int row = fish[i].first;\n\n                // Check if this catfish can be caught\n                if (row >= len) {\n                    // Compute weight contribution\n                    int startIndex = lower_bound(fish.begin(), fish.end(), make_pair(row - len, 0)) - fish.begin();\n                    int endIndex = lower_bound(fish.begin(), fish.end(), make_pair(row, 0)) - fish.begin();\n\n                    currentWeight = prefixSum[endIndex] - prefixSum[startIndex];\n                }\n            }\n\n            maxWeight = max(maxWeight, currentWeight);\n        }\n\n        dp[col] = maxWeight;\n    }\n\n    // Combine results from all columns\n    int64_t result = 0;\n    for (int i = 0; i < N; ++i) {\n        result += dp[i];\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2019 day 2",
    "timestamp": "2025-04-11 17:18:07",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/F",
    "title": "F. Sky Walking",
    "group_id": "32KGsXgiKA",
    "contest_id": "103779",
    "problem_index": "F",
    "submission_id": "314858018",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <unordered_map>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n// Function to calculate the Euclidean distance between two points\ninline int64_t euclidean_distance(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nint64_t min_distance(vector<int> x, vector<int> h, vector<int> l, vector<int> r, vector<int> y, int s, int g) {\n    int n = x.size();\n    int m = l.size();\n    \n    // Adjacency list to store the graph\n    vector<vector<pair<int, int64_t>>> graph(n + m); // n buildings + m skywalks\n    \n    // Connect buildings to skywalks\n    for (int j = 0; j < m; ++j) {\n        int skywalk_node = n + j; // Skywalks are indexed starting from n\n        int left_building = l[j];\n        int right_building = r[j];\n        int skywalk_y = y[j];\n        \n        // Connect skywalk endpoints to their respective buildings\n        int64_t dist_left = euclidean_distance(x[left_building], h[left_building], x[left_building], skywalk_y);\n        int64_t dist_right = euclidean_distance(x[right_building], h[right_building], x[right_building], skywalk_y);\n        \n        graph[left_building].emplace_back(skywalk_node, dist_left);\n        graph[skywalk_node].emplace_back(left_building, dist_left);\n        \n        graph[right_building].emplace_back(skywalk_node, dist_right);\n        graph[skywalk_node].emplace_back(right_building, dist_right);\n        \n        // Connect skywalk to itself for traversal\n        graph[skywalk_node].emplace_back(skywalk_node, 0);\n    }\n    \n    // Connect buildings directly\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (x[i] == x[j]) {\n                int64_t dist = abs(h[i] - h[j]);\n                graph[i].emplace_back(j, dist);\n                graph[j].emplace_back(i, dist);\n            }\n        }\n    }\n    \n    // Dijkstra's algorithm to find the shortest path\n    vector<int64_t> dist(n + m, numeric_limits<int64_t>::max());\n    priority_queue<pair<int64_t, int>, vector<pair<int64_t, int>>, greater<>> pq;\n    \n    dist[s] = 0;\n    pq.emplace(0, s);\n    \n    while (!pq.empty()) {\n        auto [current_dist, current_node] = pq.top();\n        pq.pop();\n        \n        if (current_dist > dist[current_node]) {\n            continue;\n        }\n        \n        for (const auto& [neighbor, weight] : graph[current_node]) {\n            if (dist[current_node] + weight < dist[neighbor]) {\n                dist[neighbor] = dist[current_node] + weight;\n                pq.emplace(dist[neighbor], neighbor);\n            }\n        }\n    }\n    \n    return dist[g] == numeric_limits<int64_t>::max() ? -1 : dist[g];\n}"
  },
  {
    "date": "IOI 2019 day 2",
    "timestamp": "2025-04-11 17:18:50",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/F",
    "title": "F. Sky Walking",
    "group_id": "32KGsXgiKA",
    "contest_id": "103779",
    "problem_index": "F",
    "submission_id": "314983055",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <cmath>\n#include <limits>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = numeric_limits<int64>::max();\n\nint64 min_distance(vector<int> x, vector<int> h, vector<int> l, vector<int> r, vector<int> y, int s, int g) {\n    int n = x.size();\n    int m = l.size();\n    \n    // Map to store graph connections\n    unordered_map<int, vector<pair<int, int64>>> graph; // node -> [(neighbor, weight)]\n\n    // Point indexing\n    int point_index = 0;\n    unordered_map<pair<int, int>, int, hash<pair<int, int>>> point_to_index;\n    auto get_point_index = [&](int px, int py) {\n        pair<int, int> point = {px, py};\n        if (point_to_index.find(point) == point_to_index.end()) {\n            point_to_index[point] = point_index++;\n        }\n        return point_to_index[point];\n    };\n\n    // Add buildings to the graph\n    vector<int> bottom_index(n), top_index(n);\n    for (int i = 0; i < n; i++) {\n        bottom_index[i] = get_point_index(x[i], 0);\n        top_index[i] = get_point_index(x[i], h[i]);\n\n        // Connect bottom to top of the building\n        int64 height = h[i];\n        graph[bottom_index[i]].emplace_back(top_index[i], height);\n        graph[top_index[i]].emplace_back(bottom_index[i], height);\n    }\n\n    // Add skywalks to the graph\n    for (int j = 0; j < m; j++) {\n        int left_building = l[j], right_building = r[j];\n        int y_level = y[j];\n\n        int left_point = get_point_index(x[left_building], y_level);\n        int right_point = get_point_index(x[right_building], y_level);\n\n        // Connect skywalk endpoints\n        int64 length = abs(x[right_building] - x[left_building]);\n        graph[left_point].emplace_back(right_point, length);\n        graph[right_point].emplace_back(left_point, length);\n\n        // Connect skywalk to buildings\n        graph[left_point].emplace_back(top_index[left_building], abs(h[left_building] - y_level));\n        graph[top_index[left_building]].emplace_back(left_point, abs(h[left_building] - y_level));\n\n        graph[right_point].emplace_back(top_index[right_building], abs(h[right_building] - y_level));\n        graph[top_index[right_building]].emplace_back(right_point, abs(h[right_building] - y_level));\n    }\n\n    // Dijkstra's algorithm\n    vector<int64> dist(point_index, INF);\n    priority_queue<pair<int64, int>, vector<pair<int64, int>>, greater<>> pq;\n\n    int start = bottom_index[s];\n    int goal = bottom_index[g];\n    dist[start] = 0;\n    pq.emplace(0, start);\n\n    while (!pq.empty()) {\n        auto [current_dist, u] = pq.top();\n        pq.pop();\n\n        if (current_dist > dist[u]) continue;\n\n        for (auto &[v, weight] : graph[u]) {\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.emplace(dist[v], v);\n            }\n        }\n    }\n\n    return dist[goal] == INF ? -1 : dist[goal];\n}"
  },
  {
    "date": "IOI 2019 day 2",
    "timestamp": "2025-04-11 17:19:34",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/F",
    "title": "F. Sky Walking",
    "group_id": "32KGsXgiKA",
    "contest_id": "103779",
    "problem_index": "F",
    "submission_id": "314983240",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\nstruct Edge {\n    int to;\n    int64_t weight;\n};\n\nint64_t min_distance(vector<int> x, vector<int> h, vector<int> l, vector<int> r, vector<int> y, int s, int g) {\n    int n = x.size(); // Number of buildings\n    int m = y.size(); // Number of skywalks\n    vector<vector<Edge>> graph(n + m); // Adjacency list\n\n    // Connect buildings to skywalks\n    for (int j = 0; j < m; ++j) {\n        int left_building = l[j];\n        int right_building = r[j];\n        int skywalk_index = n + j; // Skywalk index in the graph\n\n        // Connect left endpoint\n        graph[left_building].push_back({skywalk_index, abs(y[j])});\n        graph[skywalk_index].push_back({left_building, abs(y[j])});\n\n        // Connect right endpoint\n        graph[right_building].push_back({skywalk_index, abs(y[j])});\n        graph[skywalk_index].push_back({right_building, abs(y[j])});\n\n        // Connect intermediate buildings if the skywalk crosses them\n        for (int i = left_building + 1; i < right_building; ++i) {\n            if (y[j] <= h[i]) { // Skywalk intersects building `i`\n                graph[i].push_back({skywalk_index, y[j]});\n                graph[skywalk_index].push_back({i, y[j]});\n            }\n        }\n    }\n\n    // Dijkstra's algorithm to find the shortest path\n    vector<int64_t> dist(n + m, LLONG_MAX);\n    priority_queue<pair<int64_t, int>, vector<pair<int64_t, int>>, greater<>> pq;\n\n    dist[s] = 0;\n    pq.push({0, s});\n\n    while (!pq.empty()) {\n        auto [current_dist, current_node] = pq.top();\n        pq.pop();\n\n        if (current_dist > dist[current_node]) continue;\n\n        for (const Edge& edge : graph[current_node]) {\n            int next_node = edge.to;\n            int64_t weight = edge.weight;\n            if (dist[current_node] + weight < dist[next_node]) {\n                dist[next_node] = dist[current_node] + weight;\n                pq.push({dist[next_node], next_node});\n            }\n        }\n    }\n\n    return dist[g] == LLONG_MAX ? -1 : dist[g];\n}"
  },
  {
    "date": "IOI 2019 day 2",
    "timestamp": "2025-04-11 17:20:19",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/F",
    "title": "F. Sky Walking",
    "group_id": "32KGsXgiKA",
    "contest_id": "103779",
    "problem_index": "F",
    "submission_id": "314983341",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef pair<int64, int> PII;\n\nstruct Edge {\n    int to;\n    int64 weight;\n};\n\nint64 min_distance(vector<int> x, vector<int> h, vector<int> l, vector<int> r, vector<int> y, int s, int g) {\n    int n = x.size();\n    int m = l.size();\n    \n    // Graph adjacency list\n    vector<vector<Edge>> graph(n + m);\n\n    // Add edges for skywalk endpoints to buildings\n    for (int j = 0; j < m; ++j) {\n        int left_building = l[j];\n        int right_building = r[j];\n        int skywalk_index = n + j; // Skywalk nodes are indexed from n to n+m-1\n        \n        // Connect left endpoint of skywalk to its building\n        graph[left_building].push_back({skywalk_index, abs(h[left_building] - y[j])});\n        graph[skywalk_index].push_back({left_building, abs(h[left_building] - y[j])});\n        \n        // Connect right endpoint of skywalk to its building\n        graph[right_building].push_back({skywalk_index, abs(h[right_building] - y[j])});\n        graph[skywalk_index].push_back({right_building, abs(h[right_building] - y[j])});\n    }\n\n    // Add edges for skywalks crossing intermediate buildings\n    for (int j = 0; j < m; ++j) {\n        int left_building = l[j];\n        int right_building = r[j];\n        int skywalk_index = n + j;\n        \n        for (int i = left_building + 1; i < right_building; ++i) {\n            if (y[j] <= h[i]) { // Skywalk intersects building i\n                graph[i].push_back({skywalk_index, abs(h[i] - y[j])});\n                graph[skywalk_index].push_back({i, abs(h[i] - y[j])});\n            }\n        }\n    }\n\n    // Add edges between skywalks at the same height and endpoints\n    for (int j1 = 0; j1 < m; ++j1) {\n        for (int j2 = j1 + 1; j2 < m; ++j2) {\n            if (y[j1] == y[j2]) {\n                int skywalk1 = n + j1;\n                int skywalk2 = n + j2;\n                int64 dist = abs(x[l[j1]] - x[l[j2]]);\n                graph[skywalk1].push_back({skywalk2, dist});\n                graph[skywalk2].push_back({skywalk1, dist});\n            }\n        }\n    }\n\n    // Dijkstra's algorithm to find the shortest path\n    vector<int64> dist(n + m, numeric_limits<int64>::max());\n    priority_queue<PII, vector<PII>, greater<PII>> pq;\n\n    dist[s] = 0;\n    pq.push({0, s});\n\n    while (!pq.empty()) {\n        auto [current_dist, u] = pq.top();\n        pq.pop();\n\n        if (current_dist > dist[u]) continue;\n\n        for (const Edge& edge : graph[u]) {\n            int v = edge.to;\n            int64 weight = edge.weight;\n\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    return dist[g] == numeric_limits<int64>::max() ? -1 : dist[g];\n}"
  },
  {
    "date": "IOI 2019 day 2",
    "timestamp": "2025-04-11 17:21:02",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/F",
    "title": "F. Sky Walking",
    "group_id": "32KGsXgiKA",
    "contest_id": "103779",
    "problem_index": "F",
    "submission_id": "314983416",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <unordered_map>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int node;\n    int64_t weight;\n};\n\nint64_t min_distance(vector<int> x, vector<int> h, vector<int> l, vector<int> r, vector<int> y, int s, int g) {\n    int n = x.size(); // Number of buildings\n    int m = l.size(); // Number of skywalks\n    \n    // Graph representation using adjacency list\n    unordered_map<int, vector<Edge>> graph;\n\n    // Add edges between building bottoms and their tops\n    for (int i = 0; i < n; ++i) {\n        int bottom = i; // Bottom node index\n        int top = n + i; // Top node index\n        graph[bottom].push_back({top, h[i]});\n        graph[top].push_back({bottom, h[i]});\n    }\n\n    // Add edges for skywalks\n    for (int j = 0; j < m; ++j) {\n        int left_top = n + l[j]; // Top of left building\n        int right_top = n + r[j]; // Top of right building\n        int skywalk_node = 2 * n + j; // Skywalk node index\n\n        // Connect skywalk to its endpoints\n        graph[skywalk_node].push_back({left_top, abs(y[j] - h[l[j]])});\n        graph[left_top].push_back({skywalk_node, abs(y[j] - h[l[j]])});\n\n        graph[skywalk_node].push_back({right_top, abs(y[j] - h[r[j]])});\n        graph[right_top].push_back({skywalk_node, abs(y[j] - h[r[j]])});\n\n        // Connect endpoints of the skywalk\n        graph[skywalk_node].push_back({skywalk_node, abs(x[r[j]] - x[l[j]])});\n    }\n\n    // Dijkstra's algorithm to find the shortest path\n    int start = s; // Start from the bottom of building s\n    int target = g; // Target is the bottom of building g\n\n    const int64_t INF = numeric_limits<int64_t>::max();\n    unordered_map<int, int64_t> dist; // Distance from start\n    for (const auto& kv : graph) {\n        dist[kv.first] = INF;\n    }\n    dist[start] = 0;\n\n    priority_queue<pair<int64_t, int>, vector<pair<int64_t, int>>, greater<pair<int64_t, int>>> pq;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        auto [current_dist, current_node] = pq.top();\n        pq.pop();\n\n        if (current_dist > dist[current_node]) continue;\n\n        for (const Edge& edge : graph[current_node]) {\n            int next_node = edge.node;\n            int64_t weight = edge.weight;\n\n            if (dist[current_node] + weight < dist[next_node]) {\n                dist[next_node] = dist[current_node] + weight;\n                pq.push({dist[next_node], next_node});\n            }\n        }\n    }\n\n    return dist[target] == INF ? -1 : dist[target];\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 17:21:53",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/E",
    "title": "E. Dancing Elephants",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "E",
    "submission_id": "314983519",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nmultiset<int> elephant_positions;\nint segment_length;\n\n// Initializes the positions of the elephants and the segment length.\nvoid init(int N, int L, vector<int> X) {\n    segment_length = L;\n    for (int position : X) {\n        elephant_positions.insert(position);\n    }\n}\n\n// Updates the position of an elephant, and calculates the minimum number of cameras required.\nint update(int i, int y) {\n    auto it = elephant_positions.begin();\n    advance(it, i); // Find the i-th element in the multiset.\n\n    // Remove the old position of the i-th elephant.\n    elephant_positions.erase(it);\n\n    // Insert the new position of the i-th elephant.\n    elephant_positions.insert(y);\n\n    // Calculate the minimum number of cameras required.\n    int cameras = 0;\n    int current_segment_end = -1;\n\n    for (int position : elephant_positions) {\n        if (current_segment_end < position) {\n            // Start a new segment.\n            cameras++;\n            current_segment_end = position + segment_length;\n        }\n    }\n\n    return cameras;\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 17:22:35",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/E",
    "title": "E. Dancing Elephants",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "E",
    "submission_id": "314983592",
    "code_index": 1,
    "code": "#include <vector>\n#include <algorithm>\n#include <cmath>\n\n// Global variables to store data\nint N, L;\nstd::vector<int> positions;\n\n// Procedure to initialize the problem\nvoid init(int n, int l, std::vector<int> x) {\n    N = n;\n    L = l;\n    positions = x;  // Store the initial positions of elephants\n}\n\n// Procedure to calculate the minimum number of cameras needed\nint update(int i, int y) {\n    // Update the position of the specified elephant\n    positions[i] = y;\n    \n    // Sort the positions after the update\n    std::sort(positions.begin(), positions.end());\n    \n    // Determine the minimum number of cameras needed\n    int cameras = 0;\n    int start = 0;\n    while (start < N) {\n        cameras++;\n        int end = start;\n        while (end + 1 < N && positions[end + 1] - positions[start] <= L) {\n            end++;\n        }\n        start = end + 1;  // Move to the next segment\n    }\n    \n    return cameras;\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 17:23:17",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/E",
    "title": "E. Dancing Elephants",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "E",
    "submission_id": "314983592",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <cmath>\n\nusing namespace std;\n\n// Global variables to store the state\nint N, L;\nvector<int> positions;\n\n// Function to initialize the state\nvoid init(int n, int l, vector<int> x) {\n    N = n;\n    L = l;\n    positions = x;\n}\n\n// Function to calculate the number of cameras needed\nint calculateCameras() {\n    sort(positions.begin(), positions.end());\n    int cameras = 0;\n    int i = 0;\n\n    while (i < N) {\n        cameras++;\n        int range_end = positions[i] + L;\n        while (i < N && positions[i] <= range_end) {\n            i++;\n        }\n    }\n\n    return cameras;\n}\n\n// Function to handle updates and calculate the number of cameras\nint update(int i, int y) {\n    positions[i] = y;\n    return calculateCameras();\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 17:23:57",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/E",
    "title": "E. Dancing Elephants",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "E",
    "submission_id": "314983668",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nmultiset<int> positions; // Stores the positions of elephants\nint L;                  // Length of the segment a camera can cover\n\n// Initialize the data structures with the given input\nvoid init(int N, int l, vector<int> X) {\n    L = l;\n    positions = multiset<int>(X.begin(), X.end()); // Initialize the multiset with sorted positions\n}\n\n// Update the position of elephant i and calculate the minimum number of cameras needed\nint update(int i, int y) {\n    auto it = positions.find(i); // Find the old position of elephant i\n    if (it != positions.end()) {\n        positions.erase(it); // Remove the old position\n    }\n    positions.insert(y); // Insert the new position\n\n    // Calculate the number of cameras needed\n    int cameras = 0;\n    auto current = positions.begin();\n    while (current != positions.end()) {\n        ++cameras; // Start a new camera\n        int start = *current; // Position covered by the current camera\n        while (current != positions.end() && *current <= start + L) {\n            ++current; // Move to the next position within the range\n        }\n    }\n\n    return cameras;\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 17:24:41",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/E",
    "title": "E. Dancing Elephants",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "E",
    "submission_id": "314983863",
    "code_index": 4,
    "code": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Global variables to store the number of elephants, segment length, and their positions\nint N, L;\nvector<int> positions;\n\n// Procedure to initialize the problem\nvoid init(int n, int l, vector<int> x) {\n    N = n;\n    L = l;\n    positions = x;\n}\n\n// Procedure to calculate the minimum number of cameras needed\nint update(int i, int y) {\n    // Update the position of the specified elephant\n    positions[i] = y;\n\n    // Sort the positions to ensure they are in order\n    sort(positions.begin(), positions.end());\n\n    // Calculate the minimum number of cameras needed\n    int cameras = 0;\n    int start = 0;\n\n    while (start < N) {\n        cameras++;\n        int end = start;\n        while (end + 1 < N && positions[end + 1] - positions[start] <= L) {\n            end++;\n        }\n        start = end + 1;\n    }\n\n    return cameras;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 17:25:32",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/A",
    "title": "A. Comparing Plants",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "A",
    "submission_id": "314852613",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <utility>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint n, k;\nvector<int> r;\n\n// Adjacency list for the directed graph\nvector<vector<int>> adj;\n// In-degree for topological sorting\nvector<int> in_degree;\n// Topological order of the plants\nvector<int> topo_order;\n\nvoid init(int k_, vector<int> r_) {\n    k = k_;\n    r = r_;\n    n = r.size();\n\n    // Initialize the adjacency list and in-degree array\n    adj.assign(n, vector<int>());\n    in_degree.assign(n, 0);\n\n    // Build the graph based on the constraints from `r`\n    for (int i = 0; i < n; i++) {\n        for (int j = 1; j < k; j++) {\n            int neighbor = (i + j) % n;\n            if (r[i] > 0) {\n                // Plant at `neighbor` is taller than plant `i`\n                adj[i].push_back(neighbor);\n                in_degree[neighbor]++;\n                r[i]--;\n            }\n        }\n    }\n\n    // Topological sort to determine a valid order\n    queue<int> q;\n    for (int i = 0; i < n; i++) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    topo_order.clear();\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        topo_order.push_back(curr);\n\n        for (int neighbor : adj[curr]) {\n            in_degree[neighbor]--;\n            if (in_degree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\nint compare_plants(int x, int y) {\n    // Find positions of x and y in the topological order\n    unordered_map<int, int> position;\n    for (int i = 0; i < topo_order.size(); i++) {\n        position[topo_order[i]] = i;\n    }\n\n    if (position[x] < position[y]) {\n        return 1; // x is taller than y\n    } else if (position[x] > position[y]) {\n        return -1; // x is shorter than y\n    } else {\n        return 0; // Inconclusive (should not happen with distinct heights)\n    }\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 17:26:09",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/A",
    "title": "A. Comparing Plants",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "A",
    "submission_id": "314984032",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint n, k;\nvector<int> r;\nvector<int> in_degree;\nvector<vector<int>> adj;\nvector<int> height_rank;\n\nvoid init(int k_param, vector<int> r_param) {\n    k = k_param;\n    r = r_param;\n    n = r.size();\n\n    // Initialize adjacency list and in-degree for topological sorting\n    adj.assign(n, vector<int>());\n    in_degree.assign(n, 0);\n\n    // Build the graph based on the r values\n    for (int i = 0; i < n; ++i) {\n        for (int j = 1; j < k; ++j) {\n            int neighbor = (i + j) % n;\n            if (r[i] > 0) {\n                // Plant i has taller neighbors, so neighbor must be taller than i\n                adj[i].push_back(neighbor);\n                in_degree[neighbor]++;\n                r[i]--;\n            }\n        }\n    }\n\n    // Topological sorting to assign height ranks\n    queue<int> q;\n    for (int i = 0; i < n; ++i) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    height_rank.assign(n, 0);\n    int current_rank = n - 1;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        height_rank[node] = current_rank--;\n        for (int neighbor : adj[node]) {\n            in_degree[neighbor]--;\n            if (in_degree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\nint compare_plants(int x, int y) {\n    if (height_rank[x] > height_rank[y]) {\n        return 1; // x is definitely taller than y\n    } else if (height_rank[x] < height_rank[y]) {\n        return -1; // x is definitely shorter than y\n    } else {\n        return 0; // The comparison is inconclusive\n    }\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 17:26:49",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/A",
    "title": "A. Comparing Plants",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "A",
    "submission_id": "314984124",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n// Global variables\nint n, k;\nvector<int> r;\nvector<set<int>> definitely_taller; // Adjacency list for \"definitely taller\" relationships\nvector<set<int>> definitely_shorter; // Adjacency list for \"definitely shorter\" relationships\n\nvoid init(int k_input, vector<int> r_input) {\n    k = k_input;\n    r = r_input;\n    n = r.size();\n    definitely_taller.resize(n);\n    definitely_shorter.resize(n);\n\n    // Determine definite taller/shorter relationships based on r values\n    for (int i = 0; i < n; ++i) {\n        for (int j = 1; j < k; ++j) {\n            int neighbor = (i + j) % n;\n            if (r[i] == 0) {\n                // If r[i] == 0, all neighbors are shorter than plant i\n                definitely_taller[neighbor].insert(i);\n                definitely_shorter[i].insert(neighbor);\n            }\n            if (r[i] == k - 1) {\n                // If r[i] == k-1, all neighbors are taller than plant i\n                definitely_taller[i].insert(neighbor);\n                definitely_shorter[neighbor].insert(i);\n            }\n        }\n    }\n\n    // Propagate relationships using BFS\n    for (int i = 0; i < n; ++i) {\n        // Propagate \"definitely taller\" relationships\n        queue<int> q;\n        for (int taller : definitely_taller[i]) q.push(taller);\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            for (int taller : definitely_taller[curr]) {\n                if (definitely_taller[i].insert(taller).second) {\n                    q.push(taller);\n                }\n            }\n        }\n\n        // Propagate \"definitely shorter\" relationships\n        for (int shorter : definitely_shorter[i]) q.push(shorter);\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            for (int shorter : definitely_shorter[curr]) {\n                if (definitely_shorter[i].insert(shorter).second) {\n                    q.push(shorter);\n                }\n            }\n        }\n    }\n}\n\nint compare_plants(int x, int y) {\n    if (definitely_taller[x].count(y)) {\n        return 1; // x is definitely taller than y\n    }\n    if (definitely_shorter[x].count(y)) {\n        return -1; // x is definitely shorter than y\n    }\n    return 0; // Inconclusive\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 17:27:29",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/A",
    "title": "A. Comparing Plants",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "A",
    "submission_id": "314984186",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <unordered_set>\nusing namespace std;\n\n// Variables to store global data for the problem\nint n, k;\nvector<int> r;\n\n// Adjacency list for directed graph and in-degree array\nvector<vector<int>> graph;\nvector<int> in_degree;\n\n// Topological order and position mapping\nvector<int> topo_order;\nvector<int> plant_position;\n\n// Function to initialize the problem\nvoid init(int k_input, vector<int> r_input) {\n    k = k_input;\n    r = r_input;\n    n = r.size();\n\n    // Initialize the graph and in-degree array\n    graph.assign(n, vector<int>());\n    in_degree.assign(n, 0);\n\n    // Build the graph based on r values\n    for (int i = 0; i < n; ++i) {\n        for (int j = 1; j < k; ++j) {\n            int neighbor = (i + j) % n;\n            if (r[i] > 0) {\n                // Plant i has at least one taller plant in its next k-1 plants\n                graph[neighbor].push_back(i);\n                in_degree[i]++;\n                r[i]--;\n            }\n        }\n    }\n\n    // Perform topological sort\n    queue<int> q;\n    for (int i = 0; i < n; ++i) {\n        if (in_degree[i] == 0) {\n            q.push(i);\n        }\n    }\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n        topo_order.push_back(current);\n\n        for (int neighbor : graph[current]) {\n            in_degree[neighbor]--;\n            if (in_degree[neighbor] == 0) {\n                q.push(neighbor);\n            }\n        }\n    }\n\n    // Create a position mapping for plants in topological order\n    plant_position.assign(n, 0);\n    for (int i = 0; i < n; ++i) {\n        plant_position[topo_order[i]] = i;\n    }\n}\n\n// Function to compare two plants\nint compare_plants(int x, int y) {\n    if (plant_position[x] < plant_position[y]) {\n        return 1;  // x is definitely taller than y\n    } else if (plant_position[x] > plant_position[y]) {\n        return -1; // x is definitely shorter than y\n    } else {\n        return 0;  // Comparison is inconclusive\n    }\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 17:28:20",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/B",
    "title": "B. Scales",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "B",
    "submission_id": "314984292",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Grader functions\nint getHeaviest(int A, int B, int C);\nint getLightest(int A, int B, int C);\nint getMedian(int A, int B, int C);\nint getNextLightest(int A, int B, int C, int D);\nvoid answer(int W[6]);\n\nvoid init(int T) {\n    // Initialization for T test cases (if needed)\n}\n\nvoid orderCoins() {\n    // Start with all 6 coins\n    vector<int> coins = {1, 2, 3, 4, 5, 6};\n    vector<int> ordered;\n\n    // Find the lightest coin and add it to the ordered list\n    int lightest = getLightest(coins[0], coins[1], coins[2]);\n    int median = getMedian(coins[0], coins[1], coins[2]);\n    int heaviers= getHeaviest(coins[0], coins[1], coins[2]);\n\n\n    ordered.push_back(lightest);\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 17:29:02",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/B",
    "title": "B. Scales",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "B",
    "submission_id": "314984381",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function prototypes provided by the grader\nint getHeaviest(int A, int B, int C);\nint getLightest(int A, int B, int C);\nint getMedian(int A, int B, int C);\nint getNextLightest(int A, int B, int C, int D);\nvoid answer(int W[6]);\n\n// Initialization function\nvoid init(int T) {\n    // No global state initialization required for this problem\n}\n\n// Function to order the coins\nvoid orderCoins() {\n    // All six coins: 1, 2, 3, 4, 5, 6\n    vector<int> coins = {1, 2, 3, 4, 5, 6};\n    vector<int> sorted; // This will hold the sorted order of coins\n\n    // Step 1: Find the lightest coin\n    int lightest = getLightest(coins[0], coins[1], coins[2]);\n    for (int i = 3; i < 6; ++i) {\n        lightest = getLightest(lightest, coins[i], coins[(i + 1) % 6]);\n    }\n    sorted.push_back(lightest);\n\n    // Step 2: Find the heaviest coin\n    int heaviest = getHeaviest(coins[0], coins[1], coins[2]);\n    for (int i = 3; i < 6; ++i) {\n        heaviest = getHeaviest(heaviest, coins[i], coins[(i + 1) % 6]);\n    }\n\n    // Remove the lightest and heaviest from consideration\n    vector<int> remaining;\n    for (int coin : coins) {\n        if (coin != lightest && coin != heaviest) {\n            remaining.push_back(coin);\n        }\n    }\n\n    // Step 3: Sort the remaining four coins\n    vector<int> partial_sorted; // Sorted order of the remaining four coins\n    partial_sorted.push_back(remaining[0]); // Start with any coin\n\n    for (int i = 1; i < 4; ++i) {\n        int current = remaining[i];\n        int left = 0, right = partial_sorted.size();\n\n        // Binary insertion sort using the scale\n        while (left < right) {\n            int mid = (left + right) / 2;\n            int mid_coin = partial_sorted[mid];\n\n            // Compare current coin with the mid_coin\n            int median = getMedian(current, mid_coin, heaviest);\n            if (median == current) {\n                right = mid; // Current coin is lighter, go to the left\n            } else {\n                left = mid + 1; // Current coin is heavier, go to the right\n            }\n        }\n        partial_sorted.insert(partial_sorted.begin() + left, current);\n    }\n\n    // Step 4: Combine the results\n    sorted.insert(sorted.end(), partial_sorted.begin(), partial_sorted.end());\n    sorted.push_back(heaviest);\n\n    // Convert sorted vector to array and call answer()\n    int result[6];\n    for (int i = 0; i < 6; ++i) {\n        result[i] = sorted[i];\n    }\n    answer(result);\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 17:29:47",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/B",
    "title": "B. Scales",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "B",
    "submission_id": "314984469",
    "code_index": 2,
    "code": "#include <vector>\nusing namespace std;\n\n// Function prototypes provided by the grader\nint getHeaviest(int A, int B, int C);\nint getLightest(int A, int B, int C);\nint getMedian(int A, int B, int C);\nint getNextLightest(int A, int B, int C, int D);\nvoid answer(int W[6]);\n\n// Initialization function for the number of test cases\nvoid init(int T) {\n    // No specific initialization needed for this problem\n}\n\n// Function to determine the order of coins for a single test case\nvoid orderCoins() {\n    // Step 1: Start with all coins\n    vector<int> coins = {1, 2, 3, 4, 5, 6};\n\n    // Step 2: Identify the lightest and heaviest coin\n    int lightest = getLightest(coins[0], coins[1], coins[2]);\n    int heaviest = getHeaviest(coins[0], coins[1], coins[2]);\n\n    for (int i = 3; i < 6; ++i) {\n        lightest = getLightest(lightest, coins[i], heaviest);\n        heaviest = getHeaviest(lightest, coins[i], heaviest);\n    }\n\n    // Place the lightest and heaviest coins in their respective positions\n    vector<int> sorted(6, 0);\n    sorted[0] = lightest;\n    sorted[5] = heaviest;\n\n    // Step 3: Determine the remaining coins\n    vector<int> remaining;\n    for (int coin : coins) {\n        if (coin != lightest && coin != heaviest) {\n            remaining.push_back(coin);\n        }\n    }\n\n    // Step 4: Sort the remaining coins\n    int mid1 = getMedian(remaining[0], remaining[1], remaining[2]);\n    int mid2 = getNextLightest(remaining[0], remaining[1], remaining[2], lightest);\n    int mid3 = getNextLightest(remaining[0], remaining[1], remaining[2], mid2);\n\n    // Place the sorted coins in the correct positions\n    sorted[1] = mid2;\n    sorted[2] = mid3;\n    sorted[3] = mid1;\n\n    // Step 5: Report the answer\n    int result[6];\n    for (int i = 0; i < 6; ++i) {\n        result[i] = sorted[i];\n    }\n    answer(result);\n}"
  },
  {
    "date": "IOI 2015 day 1",
    "timestamp": "2025-04-11 17:30:35",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103769/problem/B",
    "title": "B. Scales",
    "group_id": "32KGsXgiKA",
    "contest_id": "103769",
    "problem_index": "B",
    "submission_id": "314984469",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Grader functions\nint getHeaviest(int A, int B, int C);\nint getLightest(int A, int B, int C);\nint getMedian(int A, int B, int C);\nint getNextLightest(int A, int B, int C, int D);\nvoid answer(int W[6]);\n\nvoid init(int T) {\n    // No initialization required for this problem.\n}\n\nvoid orderCoins() {\n    // List of all coins\n    vector<int> coins = {1, 2, 3, 4, 5, 6};\n    vector<int> sortedCoins;\n\n    // Step 1: Find the lightest coin\n    int lightest = getLightest(coins[0], coins[1], coins[2]);\n    sortedCoins.push_back(lightest);\n    coins.erase(remove(coins.begin(), coins.end(), lightest), coins.end());\n\n    // Step 2: Find the next lightest coin using getNextLightest\n    while (coins.size() > 1) {\n        int nextLightest = getNextLightest(coins[0], coins[1], coins[2], sortedCoins.back());\n        sortedCoins.push_back(nextLightest);\n        coins.erase(remove(coins.begin(), coins.end(), nextLightest), coins.end());\n    }\n\n    // Step 3: Add the remaining coin (heaviest) to sortedCoins\n    sortedCoins.push_back(coins[0]);\n\n    // Convert sortedCoins to the required format and report the answer\n    int result[6];\n    for (int i = 0; i < 6; i++) {\n        result[i] = sortedCoins[i];\n    }\n    answer(result);\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 17:31:29",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/F",
    "title": "F. Meetings",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "F",
    "submission_id": "314984675",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <deque>\n#include <algorithm>\n#include <cstdint>\n\nusing namespace std;\n\n// Function to compute the sliding window maximum\nvector<int> compute_sliding_window_max(const vector<int>& H, int L, int R) {\n    int n = R - L + 1;\n    vector<int> max_left(n), max_right(n);\n    max_left[0] = H[L];\n    max_right[n - 1] = H[R];\n\n    // Fill max_left and max_right arrays\n    for (int i = 1; i < n; ++i) {\n        max_left[i] = max(max_left[i - 1], H[L + i]);\n        max_right[n - i - 1] = max(max_right[n - i], H[R - i]);\n    }\n\n    return {max_left, max_right};\n}\n\nint64_t calculate_cost(const vector<int>& H, int L, int R, int x, const vector<int>& max_left, const vector<int>& max_right) {\n    int64_t cost = 0;\n\n    // Add costs for mountains to the left of x\n    for (int i = L; i < x; ++i) {\n        cost += max_left[i - L];\n    }\n\n    // Add cost for mountain x itself\n    cost += H[x];\n\n    // Add costs for mountains to the right of x\n    for (int i = x + 1; i <= R; ++i) {\n        cost += max_right[i - L];\n    }\n\n    return cost;\n}\n\nvector<int64_t> minimum_costs(vector<int> H, vector<int> L, vector<int> R) {\n    int Q = L.size();\n    vector<int64_t> results(Q);\n\n    for (int j = 0; j < Q; ++j) {\n        int l = L[j];\n        int r = R[j];\n\n        // Compute sliding window maximums for the range [l, r]\n        vector<int> max_sliding_window = compute_sliding_window_max(H, l, r);\n\n        int64_t min_cost = INT64_MAX;\n\n        // Try each mountain x in range [l, r] as the meeting place\n        for (int x = l; x <= r; ++x) {\n            int64_t current_cost = calculate_cost(H, l, r, x, max_sliding_window.first, max_sliding_window.second);\n            min_cost = min(min_cost, current_cost);\n        }\n\n        results[j] = min_cost;\n    }\n\n    return results;\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 17:32:09",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/F",
    "title": "F. Meetings",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "F",
    "submission_id": "314984675",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\n\nusing namespace std;\n\n// Function to build a Sparse Table for range maximum queries\nvector<vector<int>> buildSparseTable(const vector<int>& H) {\n    int N = H.size();\n    int maxLog = log2(N) + 1;\n    vector<vector<int>> sparseTable(N, vector<int>(maxLog));\n\n    // Initialize table for intervals of length 1\n    for (int i = 0; i < N; ++i) {\n        sparseTable[i][0] = H[i];\n    }\n\n    // Build the table for larger intervals\n    for (int j = 1; (1 << j) <= N; ++j) {\n        for (int i = 0; i + (1 << j) - 1 < N; ++i) {\n            sparseTable[i][j] = max(sparseTable[i][j - 1], sparseTable[i + (1 << (j - 1))][j - 1]);\n        }\n    }\n\n    return sparseTable;\n}\n\n// Function to query the maximum in a range [L, R] using Sparse Table\nint queryMax(const vector<vector<int>>& sparseTable, int L, int R) {\n    int length = R - L + 1;\n    int log = log2(length);\n    return max(sparseTable[L][log], sparseTable[R - (1 << log) + 1][log]);\n}\n\n// Main function to calculate the minimum costs for all meetings\nvector<int64_t> minimum_costs(vector<int> H, vector<int> L, vector<int> R) {\n    int N = H.size();\n    int Q = L.size();\n\n    // Build Sparse Table for range maximum queries\n    vector<vector<int>> sparseTable = buildSparseTable(H);\n\n    vector<int64_t> result(Q);\n\n    // Process each query\n    for (int j = 0; j < Q; ++j) {\n        int Lj = L[j], Rj = R[j];\n        int64_t minCost = INT64_MAX;\n\n        // Iterate over all possible meeting points in the range [Lj, Rj]\n        for (int x = Lj; x <= Rj; ++x) {\n            int64_t cost = 0;\n\n            // Calculate cost for the left side [Lj, x]\n            if (x > Lj) {\n                cost += (x - Lj + 1) * queryMax(sparseTable, Lj, x);\n            }\n\n            // Calculate cost for the right side [x, Rj]\n            if (x < Rj) {\n                cost += (Rj - x + 1) * queryMax(sparseTable, x, Rj);\n            }\n\n            // Add the height of the meeting point itself\n            cost += H[x];\n\n            // Update the minimum cost\n            minCost = min(minCost, cost);\n        }\n\n        // Store the result for this query\n        result[j] = minCost;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 17:32:53",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/F",
    "title": "F. Meetings",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "F",
    "submission_id": "314984821",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\nusing namespace std;\n\n// Precompute sparse table for range maximum queries\nclass SparseTable {\n    vector<vector<int>> st;\n    vector<int> log;\npublic:\n    SparseTable(const vector<int>& arr) {\n        int n = arr.size();\n        int maxLog = 32 - __builtin_clz(n); // log2(n)\n        st.assign(n, vector<int>(maxLog));\n        log.resize(n + 1);\n        \n        // Base case\n        for (int i = 0; i < n; i++) {\n            st[i][0] = arr[i];\n        }\n        \n        // Compute logs\n        for (int i = 2; i <= n; i++) {\n            log[i] = log[i / 2] + 1;\n        }\n        \n        // Build Sparse Table\n        for (int j = 1; (1 << j) <= n; j++) {\n            for (int i = 0; i + (1 << j) <= n; i++) {\n                st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n            }\n        }\n    }\n    \n    // Query the maximum in range [L, R]\n    int query(int L, int R) {\n        int j = log[R - L + 1];\n        return max(st[L][j], st[R - (1 << j) + 1][j]);\n    }\n};\n\nvector<int64_t> minimum_costs(vector<int> H, vector<int> L, vector<int> R) {\n    int N = H.size();\n    int Q = L.size();\n    vector<int64_t> result(Q);\n    \n    // Build Sparse Table for range maximum queries\n    SparseTable sparseTable(H);\n    \n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        int l = L[q], r = R[q];\n        int64_t minCost = INT64_MAX;\n        \n        // Compute prefix and suffix max arrays in range [l, r]\n        vector<int64_t> prefixCost(r - l + 1, 0);\n        vector<int64_t> suffixCost(r - l + 1, 0);\n        \n        // Prefix cost\n        for (int x = l; x <= r; x++) {\n            prefixCost[x - l] = (x == l ? 0 : prefixCost[x - l - 1]) + sparseTable.query(l, x);\n        }\n        \n        // Suffix cost\n        for (int x = r; x >= l; x--) {\n            suffixCost[x - l] = (x == r ? 0 : suffixCost[x - l + 1]) + sparseTable.query(x, r);\n        }\n        \n        // Find the minimum cost by combining prefix and suffix\n        for (int x = l; x <= r; x++) {\n            int64_t cost = (x == l ? 0 : prefixCost[x - l - 1]) + (x == r ? 0 : suffixCost[x - l + 1]) + H[x];\n            minCost = min(minCost, cost);\n        }\n        \n        result[q] = minCost;\n    }\n    \n    return result;\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 17:33:37",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/F",
    "title": "F. Meetings",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "F",
    "submission_id": "314984901",
    "code_index": 3,
    "code": "#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n// Precompute the Sparse Table for RMQ (Range Maximum Query)\nvoid buildSparseTable(const vector<int>& H, vector<vector<int>>& sparseTable) {\n    int N = H.size();\n    int logN = log2(N) + 1;\n\n    sparseTable.assign(N, vector<int>(logN, 0));\n\n    // Initialize Sparse Table for interval length 1\n    for (int i = 0; i < N; i++) {\n        sparseTable[i][0] = H[i];\n    }\n\n    // Fill Sparse Table\n    for (int j = 1; (1 << j) <= N; j++) {\n        for (int i = 0; i + (1 << j) - 1 < N; i++) {\n            sparseTable[i][j] = max(sparseTable[i][j - 1], sparseTable[i + (1 << (j - 1))][j - 1]);\n        }\n    }\n}\n\n// Query the maximum value in range [L, R] using the Sparse Table\nint rangeMaxQuery(const vector<vector<int>>& sparseTable, int L, int R) {\n    int j = log2(R - L + 1);\n    return max(sparseTable[L][j], sparseTable[R - (1 << j) + 1][j]);\n}\n\n// Function to compute the minimum costs for all queries\nvector<long long> minimum_costs(vector<int> H, vector<int> L, vector<int> R) {\n    int N = H.size();\n    int Q = L.size();\n\n    // Build the Sparse Table for range maximum queries\n    vector<vector<int>> sparseTable;\n    buildSparseTable(H, sparseTable);\n\n    vector<long long> result(Q);\n\n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        int left = L[q];\n        int right = R[q];\n        long long minCost = LLONG_MAX;\n\n        // Iterate over all possible meeting points x in [left, right]\n        for (int x = left; x <= right; x++) {\n            long long cost = 0;\n\n            // Left part: [left, x]\n            if (x > left) {\n                cost += (x - left + 1) * rangeMaxQuery(sparseTable, left, x);\n            }\n\n            // Right part: [x, right]\n            if (x < right) {\n                cost += (right - x + 1) * rangeMaxQuery(sparseTable, x, right);\n            }\n\n            // Update the minimum cost\n            minCost = min(minCost, cost);\n        }\n\n        result[q] = minCost;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 17:34:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/F",
    "title": "F. Meetings",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "F",
    "submission_id": "314984901",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nclass SegmentTree {\nprivate:\n    vector<int> tree;\n    int n;\n\n    void build(const vector<int>& heights, int node, int start, int end) {\n        if (start == end) {\n            tree[node] = heights[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(heights, 2 * node + 1, start, mid);\n            build(heights, 2 * node + 2, mid + 1, end);\n            tree[node] = max(tree[2 * node + 1], tree[2 * node + 2]);\n        }\n    }\n\n    int query(int node, int start, int end, int l, int r) {\n        if (r < start || end < l) {\n            return INT_MIN; // Out of range\n        }\n        if (l <= start && end <= r) {\n            return tree[node]; // Fully within range\n        }\n        int mid = (start + end) / 2;\n        int left_max = query(2 * node + 1, start, mid, l, r);\n        int right_max = query(2 * node + 2, mid + 1, end, l, r);\n        return max(left_max, right_max);\n    }\n\npublic:\n    SegmentTree(const vector<int>& heights) {\n        n = heights.size();\n        tree.resize(4 * n);\n        build(heights, 0, 0, n - 1);\n    }\n\n    int range_max(int l, int r) {\n        return query(0, 0, n - 1, l, r);\n    }\n};\n\nvector<long long> minimum_costs(vector<int> H, vector<int> L, vector<int> R) {\n    int N = H.size();\n    int Q = L.size();\n\n    // Initialize the segment tree for range maximum queries\n    SegmentTree seg_tree(H);\n\n    vector<long long> result(Q);\n\n    for (int j = 0; j < Q; ++j) {\n        int l = L[j], r = R[j];\n        long long min_cost = LLONG_MAX;\n\n        // Iterate over all possible meeting points in the range [l, r]\n        for (int x = l; x <= r; ++x) {\n            long long cost = 0;\n\n            // Left part [l, x]\n            if (l <= x) {\n                cost += (long long)(x - l + 1) * seg_tree.range_max(l, x);\n            }\n\n            // Right part [x, r]\n            if (x + 1 <= r) {\n                cost += (long long)(r - x) * seg_tree.range_max(x + 1, r);\n            }\n\n            // Update the minimum cost\n            min_cost = min(min_cost, cost);\n        }\n\n        result[j] = min_cost;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 17:35:20",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/B",
    "title": "B. Connecting Supertrees",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "B",
    "submission_id": "314984186",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <cstring>\nusing namespace std;\n\nvoid build(vector<vector<int>> b);\n\nint construct(vector<vector<int>> p) {\n    int n = p.size();\n    \n    // Check for invalid input conditions\n    for (int i = 0; i < n; ++i) {\n        if (p[i][i] != 1) return 0; // p[i][i] must be 1\n        for (int j = 0; j < n; ++j) {\n            if (p[i][j] != p[j][i]) return 0; // p[i][j] must be symmetric\n            if (p[i][j] > 3) return 0; // p[i][j] must be <= 3\n        }\n    }\n\n    vector<vector<int>> b(n, vector<int>(n, 0)); // Bridge matrix\n\n    // Simple construction logic based on `p`\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (p[i][j] == 0) {\n                // No paths allowed between i and j\n                b[i][j] = 0;\n                b[j][i] = 0;\n            } else if (p[i][j] == 1) {\n                // Exactly 1 path between i and j\n                b[i][j] = 1;\n                b[j][i] = 1;\n            } else if (p[i][j] == 2) {\n                // Exactly 2 paths between i and j\n                // Add intermediate node logic to ensure 2 paths\n                if (n < 2) return 0; // Not enough towers for intermediate nodes\n                b[i][j] = 1;\n                b[j][i] = 1;\n            } else if (p[i][j] == 3) {\n                // Exactly 3 paths between i and j\n                return 0; // Cannot construct 3 paths directly\n            }\n        }\n    }\n\n    // Verify the construction\n    // Simulate paths using BFS or DFS to ensure the number of paths matches `p`\n    // If verification fails, return 0\n\n    // If the construction is valid\n    build(b);\n    return 1;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 17:36:01",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/B",
    "title": "B. Connecting Supertrees",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "B",
    "submission_id": "314985150",
    "code_index": 1,
    "code": "#include <vector>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\nvoid build(vector<vector<int>> b);\n\nint construct(vector<vector<int>> p) {\n    int n = p.size();\n\n    // Check if the matrix p is valid\n    for (int i = 0; i < n; i++) {\n        if (p[i][i] != 1) return 0; // Diagonal must be 1\n        for (int j = 0; j < n; j++) {\n            if (p[i][j] != p[j][i]) return 0; // Symmetry check\n            if (p[i][j] > 3) return 0; // No path requirement can exceed 3\n        }\n    }\n\n    // If p[i][j] > 1 for any i != j, we will need to create additional bridges\n    vector<vector<int>> b(n, vector<int>(n, 0)); // Bridge matrix\n\n    // Attempt to construct the required bridges\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (p[i][j] == 1) {\n                // Exactly 1 path means a direct bridge is needed\n                b[i][j] = 1;\n                b[j][i] = 1;\n            } else if (p[i][j] == 2) {\n                // Exactly 2 paths mean we need an intermediate node\n                // Add a new node if necessary\n                int newNode = n++;\n                b.resize(n, vector<int>(n, 0));\n                for (int k = 0; k < n; k++) {\n                    b[k].resize(n, 0);\n                }\n                b[i][newNode] = 1;\n                b[newNode][i] = 1;\n                b[j][newNode] = 1;\n                b[newNode][j] = 1;\n            } else if (p[i][j] == 3) {\n                // Impossible to have exactly 3 paths in this setup\n                return 0;\n            }\n        }\n    }\n\n    // Validate the resulting bridge network\n    for (int i = 0; i < n; i++) {\n        vector<int> visited(n, 0);\n        queue<pair<int, int>> q;\n        q.push({i, 0}); // Start BFS from node i with distance 0\n        visited[i] = 1;\n        while (!q.empty()) {\n            int node = q.front().first;\n            int dist = q.front().second;\n            q.pop();\n            for (int neighbor = 0; neighbor < n; neighbor++) {\n                if (b[node][neighbor] == 1 && !visited[neighbor]) {\n                    visited[neighbor] = dist + 1;\n                    q.push({neighbor, dist + 1});\n                }\n            }\n        }\n        for (int j = 0; j < n; j++) {\n            if (visited[j] != p[i][j]) return 0; // If the number of paths does not match, return 0\n        }\n    }\n\n    // Call the build function with the constructed bridge network\n    build(b);\n    return 1;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 17:36:43",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/B",
    "title": "B. Connecting Supertrees",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "B",
    "submission_id": "314985228",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// Forward declaration of the build function, which is provided by the grader.\nvoid build(vector<vector<int>> b);\n\nint construct(vector<vector<int>> p) {\n    int n = p.size();\n\n    // Step 1: Validate input matrix `p`\n    for (int i = 0; i < n; ++i) {\n        if (p[i][i] != 1) return 0; // Diagonal elements must be 1\n        for (int j = 0; j < n; ++j) {\n            if (p[i][j] != p[j][i]) return 0; // Matrix must be symmetric\n            if (p[i][j] < 0 || p[i][j] > 3) return 0; // Values must be between 0 and 3\n        }\n    }\n\n    // Step 2: Handle special case where all elements are 1 (fully disconnected graph)\n    bool all_ones = true;\n    for (int i = 0; i < n && all_ones; ++i) {\n        for (int j = 0; j < n && all_ones; ++j) {\n            if (p[i][j] != 1) all_ones = false;\n        }\n    }\n    if (all_ones) {\n        vector<vector<int>> b(n, vector<int>(n, 0)); // No bridges for fully disconnected graph\n        build(b);\n        return 1;\n    }\n\n    // Step 3: Construct the bridge matrix `b`\n    vector<vector<int>> b(n, vector<int>(n, 0));\n\n    // A simple strategy to construct the graph:\n    // - If p[i][j] == 2, we need a \"direct\" connection between i and j to ensure 2 paths.\n    // - If p[i][j] == 3, it is impossible to construct such a graph (return 0).\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (p[i][j] == 1) {\n                // No direct bridge needed, already satisfies 1 path.\n                continue;\n            } else if (p[i][j] == 2) {\n                // Add a direct bridge between i and j\n                b[i][j] = 1;\n                b[j][i] = 1;\n            } else if (p[i][j] == 3) {\n                // It is impossible to satisfy p[i][j] == 3 with the given constraints\n                return 0;\n            }\n        }\n    }\n\n    // Step 4: Validate the constructed bridge matrix `b` against `p`\n    // Perform BFS/DFS to verify the number of paths between each pair of nodes\n    for (int start = 0; start < n; ++start) {\n        vector<int> visited(n, 0);\n        queue<int> q;\n        q.push(start);\n        visited[start] = 1;\n\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            for (int neighbor = 0; neighbor < n; ++neighbor) {\n                if (b[curr][neighbor] && !visited[neighbor]) {\n                    visited[neighbor] = 1;\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        // After BFS, check if the number of paths matches `p[start][...]`\n        for (int end = 0; end < n; ++end) {\n            if ((start != end && visited[end] != (p[start][end] > 0)) || (start == end && visited[end] != 1)) {\n                return 0; // Invalid construction\n            }\n        }\n    }\n\n    // Step 5: Call the build function and return success\n    build(b);\n    return 1;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 17:37:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/B",
    "title": "B. Connecting Supertrees",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "B",
    "submission_id": "314985290",
    "code_index": 3,
    "code": "#include <vector>\n#include <queue>\nusing namespace std;\n\n// Grader-provided function to finalize the bridge construction\nvoid build(vector<vector<int>> b);\n\nint construct(vector<vector<int>> p) {\n    int n = p.size();\n    \n    // Step 1: Validate the input matrix\n    for (int i = 0; i < n; ++i) {\n        if (p[i][i] != 1) return 0; // Diagonal must be 1\n        for (int j = 0; j < n; ++j) {\n            if (p[i][j] != p[j][i]) return 0; // Symmetry check\n            if (p[i][j] > 3) return 0; // Maximum path constraint\n        }\n    }\n    \n    // Step 2: Initialize the adjacency matrix for bridges\n    vector<vector<int>> b(n, vector<int>(n, 0));\n    \n    // Step 3: Handle simple cases\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (p[i][j] == 1) {\n                b[i][j] = b[j][i] = 1; // Direct bridge\n            } else if (p[i][j] == 2) {\n                // Create an intermediate node to form 2 paths\n                int new_node = n++;\n                b.resize(n, vector<int>(n, 0));\n                for (int k = 0; k < n; ++k) {\n                    b[k].resize(n);\n                }\n                b[i][new_node] = b[new_node][i] = 1;\n                b[new_node][j] = b[j][new_node] = 1;\n            } else if (p[i][j] == 3) {\n                // Create two intermediate nodes to form 3 paths\n                int new_node1 = n++;\n                int new_node2 = n++;\n                b.resize(n, vector<int>(n, 0));\n                for (int k = 0; k < n; ++k) {\n                    b[k].resize(n);\n                }\n                b[i][new_node1] = b[new_node1][i] = 1;\n                b[new_node1][new_node2] = b[new_node2][new_node1] = 1;\n                b[new_node2][j] = b[j][new_node2] = 1;\n            }\n        }\n    }\n    \n    // Step 4: Finalize the bridge construction\n    build(b);\n    return 1;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 17:38:08",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/B",
    "title": "B. Connecting Supertrees",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "B",
    "submission_id": "314985348",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\nusing namespace std;\n\n// Function to build the bridges\nvoid build(vector<vector<int>> b);\n\n// Helper function to check if the adjacency matrix satisfies the path requirements\nbool validatePaths(const vector<vector<int>>& b, const vector<vector<int>>& p, int n) {\n    vector<vector<int>> paths(n, vector<int>(n, 0));\n    \n    // Use BFS to count paths between all pairs\n    for (int start = 0; start < n; ++start) {\n        vector<int> visited(n, 0);\n        queue<pair<int, int>> q;\n        q.push({start, 0});\n        visited[start] = 1;\n\n        while (!q.empty()) {\n            int u = q.front().first;\n            int depth = q.front().second;\n            q.pop();\n\n            if (depth > 0) {\n                paths[start][u]++;\n            }\n\n            for (int v = 0; v < n; ++v) {\n                if (b[u][v] && !visited[v]) {\n                    visited[v] = 1;\n                    q.push({v, depth + 1});\n                }\n            }\n        }\n    }\n\n    // Check if paths match the requirements\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (paths[i][j] != p[i][j]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n// Main function to construct bridges\nint construct(vector<vector<int>> p) {\n    int n = p.size();\n\n    // Step 1: Check trivial impossibility cases\n    for (int i = 0; i < n; ++i) {\n        if (p[i][i] != 1) {\n            return 0; // Self-paths must always be exactly 1\n        }\n    }\n\n    // Step 2: Create adjacency matrix for bridges\n    vector<vector<int>> b(n, vector<int>(n, 0));\n\n    // Step 3: Build bridges based on path requirements\n    // This basic approach attempts to satisfy the path requirements greedily.\n    // Note: This implementation is simplified and may not handle all edge cases optimally.\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (p[i][j] > 0 && p[i][j] <= 3) {\n                b[i][j] = b[j][i] = 1;\n            } else if (p[i][j] > 3) {\n                return 0; // Impossible to satisfy requirements with more than 3 paths\n            }\n        }\n    }\n\n    // Step 4: Validate the constructed bridges\n    if (!validatePaths(b, p, n)) {\n        return 0; // If the paths don't match the requirements, return failure\n    }\n\n    // Step 5: Report the solution\n    build(b);\n    return 1;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 17:39:13",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/C",
    "title": "C. Werewolf",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "C",
    "submission_id": "314985465",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvector<int> check_validity(int N, vector<int> X, vector<int> Y, vector<int> S, vector<int> E, vector<int> L, vector<int> R) {\n    int M = X.size();\n    int Q = S.size();\n\n    // Graph representation\n    vector<vector<int>> graph(N);\n    for (int i = 0; i < M; ++i) {\n        graph[X[i]].push_back(Y[i]);\n        graph[Y[i]].push_back(X[i]);\n    }\n\n    // Precompute connected components for ranges [L, R]\n    vector<vector<int>> component(N); // component[i][j] indicates which component city i belongs to for range j\n    vector<int> component_id(N, -1); // Temporary storage for BFS/DFS\n\n    for (int l = 0; l < N; ++l) {\n        fill(component_id.begin(), component_id.end(), -1);\n        int comp = 0;\n\n        for (int i = l; i < N; ++i) {\n            if (component_id[i] == -1) {\n                // BFS/DFS to find all nodes in the same component\n                queue<int> q;\n                q.push(i);\n                component_id[i] = comp;\n\n                while (!q.empty()) {\n                    int u = q.front();\n                    q.pop();\n\n                    for (int v : graph[u]) {\n                        if (v >= l && v <= i && component_id[v] == -1) {\n                            component_id[v] = comp;\n                            q.push(v);\n                        }\n                    }\n                }\n                ++comp;\n            }\n        }\n\n        // Store the component ids for this range\n        for (int i = l; i < N; ++i) {\n            component[i].push_back(component_id[i]);\n        }\n    }\n\n    // Answer queries\n    vector<int> result(Q, 0);\n\n    for (int i = 0; i < Q; ++i) {\n        int start = S[i], end = E[i], l = L[i], r = R[i];\n\n        // Check if start and end are in the same component for range [L, R]\n        if (component[start][r] == component[end][r]) {\n            result[i] = 1;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 17:39:56",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/C",
    "title": "C. Werewolf",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "C",
    "submission_id": "314985544",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvector<int> check_validity(int N, vector<int> X, vector<int> Y, vector<int> S, vector<int> E, vector<int> L, vector<int> R) {\n    // Number of roads (M) and number of queries (Q)\n    int M = X.size();\n    int Q = S.size();\n    \n    // Graph representation\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < M; i++) {\n        adj[X[i]].push_back(Y[i]);\n        adj[Y[i]].push_back(X[i]);\n    }\n\n    // Precomputing connected components for all thresholds\n    vector<int> human_component(N, -1); // Connected components for human form (threshold-based)\n    vector<int> wolf_component(N, -1); // Connected components for wolf form (threshold-based)\n    vector<int> human_threshold(N, -1); // Minimum L threshold for which city is part of human component\n    vector<int> wolf_threshold(N, -1); // Maximum R threshold for which city is part of wolf component\n\n    // BFS to compute connected components\n    auto compute_components = [&](int start_threshold, int end_threshold, vector<int>& component, vector<int>& threshold, bool is_human) {\n        int curr_component = 0;\n        vector<bool> visited(N, false);\n        \n        for (int i = start_threshold; i <= end_threshold; i++) {\n            if (!visited[i]) {\n                queue<int> q;\n                q.push(i);\n                visited[i] = true;\n                component[i] = curr_component;\n                threshold[i] = (is_human ? start_threshold : end_threshold);\n\n                while (!q.empty()) {\n                    int u = q.front();\n                    q.pop();\n                    for (int v : adj[u]) {\n                        if (!visited[v] && ((is_human && v >= start_threshold) || (!is_human && v <= end_threshold))) {\n                            visited[v] = true;\n                            component[v] = curr_component;\n                            threshold[v] = (is_human ? start_threshold : end_threshold);\n                            q.push(v);\n                        }\n                    }\n                }\n                curr_component++;\n            }\n        }\n    };\n\n    // Compute connected components for all thresholds\n    for (int i = 0; i < N; i++) {\n        if (human_component[i] == -1) {\n            compute_components(i, N - 1, human_component, human_threshold, true);\n        }\n        if (wolf_component[i] == -1) {\n            compute_components(0, i, wolf_component, wolf_threshold, false);\n        }\n    }\n\n    // Answering queries\n    vector<int> result(Q, 0);\n    for (int i = 0; i < Q; i++) {\n        int s = S[i], e = E[i], l = L[i], r = R[i];\n\n        // Check if start city `s` can reach a transformation city in `[L[i], R[i]]` in the human subgraph\n        if (human_threshold[s] <= l && human_component[s] == human_component[l]) {\n            // Check if end city `e` can reach a transformation city in `[L[i], R[i]]` in the wolf subgraph\n            if (wolf_threshold[e] >= r && wolf_component[e] == wolf_component[r]) {\n                result[i] = 1;\n            }\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 17:40:36",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/C",
    "title": "C. Werewolf",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "C",
    "submission_id": "314985608",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvector<int> check_validity(int N, vector<int> X, vector<int> Y, vector<int> S, vector<int> E, vector<int> L, vector<int> R) {\n    // Step 1: Build adjacency list for the graph\n    vector<vector<int>> adj(N);\n    int M = X.size();\n    for (int i = 0; i < M; ++i) {\n        adj[X[i]].push_back(Y[i]);\n        adj[Y[i]].push_back(X[i]);\n    }\n\n    // Step 2: Precompute connected components for each range of cities\n    // `components[l][r]` will store the connected component ID for cities in the range [l, r].\n    vector<vector<int>> components(N, vector<int>(N, -1)); // -1 means unvisited\n    int component_id = 0;\n\n    for (int l = 0; l < N; ++l) {\n        vector<bool> visited(N, false);\n        for (int r = l; r < N; ++r) {\n            if (components[l][r] == -1) {\n                queue<int> q;\n                for (int i = l; i <= r; ++i) {\n                    if (!visited[i] && components[l][r] == -1) {\n                        q.push(i);\n                        components[l][r] = component_id;\n                        visited[i] = true;\n                        while (!q.empty()) {\n                            int curr = q.front();\n                            q.pop();\n                            for (int neighbor : adj[curr]) {\n                                if (!visited[neighbor] && neighbor >= l && neighbor <= r) {\n                                    q.push(neighbor);\n                                    visited[neighbor] = true;\n                                    components[l][r] = component_id;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Step 3: Process each query\n    int Q = S.size();\n    vector<int> result(Q, 0); // Default to 0 (impossible)\n    for (int i = 0; i < Q; ++i) {\n        int si = S[i], ei = E[i], li = L[i], ri = R[i];\n        // Check if si and ei are in the same connected component in the range [li, ri]\n        if (components[li][ri] != -1 && components[li][ri] == components[li][ri]) {\n            result[i] = 1; // Possible\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 17:41:16",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/C",
    "title": "C. Werewolf",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "C",
    "submission_id": "314985684",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\nusing namespace std;\n\nvector<int> check_validity(int N, vector<int> X, vector<int> Y, vector<int> S, vector<int> E, vector<int> L, vector<int> R) {\n    int M = X.size(); // Number of roads\n    int Q = S.size(); // Number of queries\n\n    // Adjacency list for the graph\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < M; ++i) {\n        adj[X[i]].push_back(Y[i]);\n        adj[Y[i]].push_back(X[i]);\n    }\n\n    // Result array\n    vector<int> result(Q, 0);\n\n    // BFS function to find connected components within a valid range of nodes\n    auto bfs = [&](int start, vector<bool>& visited, int minCity, int maxCity) -> vector<int> {\n        vector<int> component(N, -1);\n        queue<int> q;\n        q.push(start);\n        visited[start] = true;\n        component[start] = start;\n\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n\n            for (int v : adj[u]) {\n                if (!visited[v] && v >= minCity && v <= maxCity) {\n                    visited[v] = true;\n                    component[v] = start;\n                    q.push(v);\n                }\n            }\n        }\n\n        return component;\n    };\n\n    for (int i = 0; i < Q; ++i) {\n        int s = S[i], e = E[i], l = L[i], r = R[i];\n\n        // Zones: Human Zone, Wolf Zone, and Transformation Zone\n        vector<bool> visitedHuman(N, false), visitedWolf(N, false), visitedTransform(N, false);\n\n        // Compute connected components for human, wolf, and transformation zones\n        vector<int> humanComponent = bfs(s, visitedHuman, l, N - 1); // Human: [L_i, N-1]\n        vector<int> wolfComponent = bfs(e, visitedWolf, 0, r);       // Wolf: [0, R_i]\n        vector<int> transformComponent = bfs(l, visitedTransform, l, r); // Transformation: [L_i, R_i]\n\n        // Check if there exists a valid transformation point\n        bool valid = false;\n        for (int t = l; t <= r; ++t) {\n            if (humanComponent[s] == humanComponent[t] && wolfComponent[e] == wolfComponent[t]) {\n                valid = true;\n                break;\n            }\n        }\n\n        result[i] = valid ? 1 : 0;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 17:42:00",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/C",
    "title": "C. Werewolf",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "C",
    "submission_id": "314985765",
    "code_index": 4,
    "code": "#include <vector>\n#include <queue>\n#include <unordered_map>\nusing namespace std;\n\n// Helper function to compute connected components within a population range\nvoid compute_components(int N, const vector<vector<int>>& adj, vector<int>& component, int start, int end) {\n    int cur_component = 0;\n    vector<bool> visited(N, false);\n    for (int i = start; i <= end; ++i) {\n        if (!visited[i]) {\n            queue<int> q;\n            q.push(i);\n            visited[i] = true;\n            component[i] = cur_component;\n            while (!q.empty()) {\n                int node = q.front();\n                q.pop();\n                for (int neighbor : adj[node]) {\n                    if (!visited[neighbor] && neighbor >= start && neighbor <= end) {\n                        visited[neighbor] = true;\n                        component[neighbor] = cur_component;\n                        q.push(neighbor);\n                    }\n                }\n            }\n            ++cur_component;\n        }\n    }\n}\n\nvector<int> check_validity(int N, vector<int> X, vector<int> Y, vector<int> S, vector<int> E, vector<int> L, vector<int> R) {\n    int M = X.size(), Q = S.size();\n\n    // Build adjacency list for the graph\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < M; ++i) {\n        adj[X[i]].push_back(Y[i]);\n        adj[Y[i]].push_back(X[i]);\n    }\n\n    // Precompute connected components for all possible human and wolf ranges\n    vector<int> human_component(N, -1); // Connected component for human form\n    vector<int> wolf_component(N, -1);  // Connected component for wolf form\n\n    compute_components(N, adj, human_component, 0, N - 1); // Full range for preprocessing\n    compute_components(N, adj, wolf_component, 0, N - 1);  // Full range for preprocessing\n\n    // Answer each query\n    vector<int> result(Q);\n    for (int i = 0; i < Q; ++i) {\n        int start = S[i], end = E[i], lower = L[i], upper = R[i];\n\n        // Check if the start and end cities are reachable within constraints\n        int human_start_component = human_component[start];\n        int wolf_end_component = wolf_component[end];\n\n        if (human_start_component == -1 || wolf_end_component == -1) {\n            result[i] = 0; // Not reachable\n            continue;\n        }\n\n        // Check if there exists a valid transformation city in range [L_i, R_i]\n        bool valid_transformation = false;\n        for (int city = lower; city <= upper; ++city) {\n            if (human_component[city] == human_start_component && wolf_component[city] == wolf_end_component) {\n                valid_transformation = true;\n                break;\n            }\n        }\n\n        result[i] = valid_transformation ? 1 : 0;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 17:43:02",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/E",
    "title": "E. Mosaic",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "E",
    "submission_id": "314985883",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n\nstd::vector<long long> mosaic(\n    std::vector<int> X, \n    std::vector<int> Y,\n    std::vector<int> T, \n    std::vector<int> B,\n    std::vector<int> L, \n    std::vector<int> R\n) {\n    int N = X.size();\n    int Q = T.size();\n\n    // Step 1: Build the mosaic grid based on the rules\n    std::vector<std::vector<int>> grid(N, std::vector<int>(N, 0));\n\n    // Initialize the topmost row and the leftmost column\n    for (int j = 0; j < N; ++j) {\n        grid[0][j] = X[j];\n    }\n    for (int i = 0; i < N; ++i) {\n        grid[i][0] = Y[i];\n    }\n\n    // Fill the rest of the grid\n    for (int i = 1; i < N; ++i) {\n        for (int j = 1; j < N; ++j) {\n            // Apply the coloring rules\n            if (grid[i-1][j] == 0 && grid[i][j-1] == 0) {\n                grid[i][j] = 1; // Black\n            } else {\n                grid[i][j] = 0; // White\n            }\n        }\n    }\n\n    // Step 2: Precompute prefix sums for fast subrectangle queries\n    std::vector<std::vector<long long>> prefixSum(N + 1, std::vector<long long>(N + 1, 0));\n\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            prefixSum[i][j] = grid[i-1][j-1]\n                            + prefixSum[i-1][j]\n                            + prefixSum[i][j-1]\n                            - prefixSum[i-1][j-1];\n        }\n    }\n\n    // Step 3: Answer each query using the prefix sum array\n    std::vector<long long> result(Q);\n    for (int k = 0; k < Q; ++k) {\n        int top = T[k];\n        int bottom = B[k];\n        int left = L[k];\n        int right = R[k];\n\n        long long sum = prefixSum[bottom + 1][right + 1]\n                      - prefixSum[top][right + 1]\n                      - prefixSum[bottom + 1][left]\n                      + prefixSum[top][left];\n        result[k] = sum;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 17:43:44",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/E",
    "title": "E. Mosaic",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "E",
    "submission_id": "314985957",
    "code_index": 1,
    "code": "#include <vector>\nusing namespace std;\n\nvector<long long> mosaic(\n    vector<int> X, \n    vector<int> Y,\n    vector<int> T, \n    vector<int> B,\n    vector<int> L, \n    vector<int> R\n) {\n    int N = X.size();\n    int Q = T.size();\n\n    // Step 1: Construct the mosaic grid\n    vector<vector<int>> grid(N, vector<int>(N, 0));\n    // Fill the first row and first column\n    for (int j = 0; j < N; ++j) {\n        grid[0][j] = X[j];\n    }\n    for (int i = 0; i < N; ++i) {\n        grid[i][0] = Y[i];\n    }\n    // Fill the rest of the grid\n    for (int i = 1; i < N; ++i) {\n        for (int j = 1; j < N; ++j) {\n            if (grid[i-1][j] == 0 && grid[i][j-1] == 0) {\n                grid[i][j] = 1; // Black if both neighbors are white\n            } else {\n                grid[i][j] = 0; // White otherwise\n            }\n        }\n    }\n\n    // Step 2: Compute prefix sums\n    vector<vector<long long>> prefixSum(N + 1, vector<long long>(N + 1, 0));\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            prefixSum[i][j] = grid[i-1][j-1]\n                            + prefixSum[i-1][j]\n                            + prefixSum[i][j-1]\n                            - prefixSum[i-1][j-1];\n        }\n    }\n\n    // Step 3: Answer queries using prefix sums\n    vector<long long> result(Q);\n    for (int k = 0; k < Q; ++k) {\n        int t = T[k], b = B[k], l = L[k], r = R[k];\n        result[k] = prefixSum[b+1][r+1]\n                  - prefixSum[t][r+1]\n                  - prefixSum[b+1][l]\n                  + prefixSum[t][l];\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 17:44:26",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/E",
    "title": "E. Mosaic",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "E",
    "submission_id": "314986044",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nvector<long long> mosaic(\n    vector<int> X, \n    vector<int> Y,\n    vector<int> T, \n    vector<int> B,\n    vector<int> L, \n    vector<int> R\n) {\n    int N = X.size();\n    int Q = T.size();\n    \n    // Step 1: Construct the grid\n    vector<vector<int>> grid(N, vector<int>(N, 0));\n    \n    // Fill the first row and first column\n    for (int j = 0; j < N; ++j) grid[0][j] = X[j];\n    for (int i = 0; i < N; ++i) grid[i][0] = Y[i];\n    \n    // Fill the rest of the grid using the coloring rule\n    for (int i = 1; i < N; ++i) {\n        for (int j = 1; j < N; ++j) {\n            if (grid[i - 1][j] == 0 && grid[i][j - 1] == 0) {\n                grid[i][j] = 1; // Black\n            } else {\n                grid[i][j] = 0; // White\n            }\n        }\n    }\n    \n    // Step 2: Compute prefix sums\n    vector<vector<long long>> prefixSum(N + 1, vector<long long>(N + 1, 0));\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            prefixSum[i][j] = grid[i - 1][j - 1]\n                            + prefixSum[i - 1][j]\n                            + prefixSum[i][j - 1]\n                            - prefixSum[i - 1][j - 1];\n        }\n    }\n    \n    // Step 3: Answer the queries\n    vector<long long> result(Q);\n    for (int k = 0; k < Q; ++k) {\n        int t = T[k], b = B[k], l = L[k], r = R[k];\n        // Convert to 1-based indexing for prefix sum\n        t++; b++; l++; r++;\n        result[k] = prefixSum[b][r]\n                  - prefixSum[t - 1][r]\n                  - prefixSum[b][l - 1]\n                  + prefixSum[t - 1][l - 1];\n    }\n    \n    return result;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 17:45:11",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/E",
    "title": "E. Mosaic",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "E",
    "submission_id": "314986125",
    "code_index": 3,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nstd::vector<long long> mosaic(\n    std::vector<int> X, \n    std::vector<int> Y,\n    std::vector<int> T, \n    std::vector<int> B,\n    std::vector<int> L, \n    std::vector<int> R\n) {\n    int N = X.size();\n    int Q = T.size();\n\n    // Step 1: Build the mosaic grid\n    vector<vector<int>> grid(N, vector<int>(N, 0));\n    for (int j = 0; j < N; ++j) {\n        grid[0][j] = X[j];\n    }\n    for (int i = 0; i < N; ++i) {\n        grid[i][0] = Y[i];\n    }\n    for (int i = 1; i < N; ++i) {\n        for (int j = 1; j < N; ++j) {\n            // Tile (i, j) is black (1) if both neighbors are white (0).\n            if (grid[i - 1][j] == 0 && grid[i][j - 1] == 0) {\n                grid[i][j] = 1;\n            } else {\n                grid[i][j] = 0;\n            }\n        }\n    }\n\n    // Step 2: Compute prefix sum matrix\n    vector<vector<long long>> prefixSum(N + 1, vector<long long>(N + 1, 0));\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            prefixSum[i][j] = grid[i - 1][j - 1]\n                              + prefixSum[i - 1][j]\n                              + prefixSum[i][j - 1]\n                              - prefixSum[i - 1][j - 1];\n        }\n    }\n\n    // Step 3: Answer the queries\n    vector<long long> result(Q);\n    for (int k = 0; k < Q; ++k) {\n        int t = T[k], b = B[k], l = L[k], r = R[k];\n        result[k] = prefixSum[b + 1][r + 1]\n                    - prefixSum[t][r + 1]\n                    - prefixSum[b + 1][l]\n                    + prefixSum[t][l];\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 17:45:52",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/E",
    "title": "E. Mosaic",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "E",
    "submission_id": "314986211",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nvector<long long> mosaic(\n    vector<int> X, \n    vector<int> Y,\n    vector<int> T, \n    vector<int> B,\n    vector<int> L, \n    vector<int> R\n) {\n    int N = X.size();\n    int Q = T.size();\n\n    // Step 1: Construct the grid\n    vector<vector<int>> grid(N, vector<int>(N, 0));\n    grid[0] = X; // First row\n    for (int i = 0; i < N; ++i) {\n        grid[i][0] = Y[i]; // First column\n    }\n    for (int i = 1; i < N; ++i) {\n        for (int j = 1; j < N; ++j) {\n            if (grid[i-1][j] == 0 && grid[i][j-1] == 0) {\n                grid[i][j] = 1; // Black\n            } else {\n                grid[i][j] = 0; // White\n            }\n        }\n    }\n\n    // Step 2: Build 2D prefix sum array\n    vector<vector<long long>> prefix(N, vector<long long>(N, 0));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            prefix[i][j] = grid[i][j];\n            if (i > 0) prefix[i][j] += prefix[i-1][j];\n            if (j > 0) prefix[i][j] += prefix[i][j-1];\n            if (i > 0 && j > 0) prefix[i][j] -= prefix[i-1][j-1];\n        }\n    }\n\n    // Step 3: Answer each query\n    vector<long long> result(Q, 0);\n    for (int k = 0; k < Q; ++k) {\n        int t = T[k], b = B[k], l = L[k], r = R[k];\n        long long sum = prefix[b][r];\n        if (t > 0) sum -= prefix[t-1][r];\n        if (l > 0) sum -= prefix[b][l-1];\n        if (t > 0 && l > 0) sum += prefix[t-1][l-1];\n        result[k] = sum;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2019 day 2",
    "timestamp": "2025-04-11 17:46:42",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/E",
    "title": "E. Vision Program",
    "group_id": "32KGsXgiKA",
    "contest_id": "103779",
    "problem_index": "E",
    "submission_id": "314986315",
    "code_index": 0,
    "code": "#include <vector>\n#include <cmath>\nusing namespace std;\n\n// Your code will be placed here\nvoid construct_network(int H, int W, int K) {\n    vector<int> or_inputs;\n\n    // Iterate over all pairs of pixels in the grid\n    for (int r1 = 0; r1 < H; ++r1) {\n        for (int c1 = 0; c1 < W; ++c1) {\n            for (int r2 = 0; r2 < H; ++r2) {\n                for (int c2 = 0; c2 < W; ++c2) {\n                    // Skip pairs where both pixels are the same\n                    if (r1 == r2 && c1 == c2) continue;\n\n                    // Calculate Manhattan distance\n                    int distance = abs(r1 - r2) + abs(c1 - c2);\n\n                    // If the distance matches K\n                    if (distance == K) {\n                        // Memory indices for the two pixels\n                        int cell1 = r1 * W + c1;\n                        int cell2 = r2 * W + c2;\n\n                        // Add an AND instruction to check if both pixels are black\n                        int and_output = add_and({cell1, cell2});\n\n                        // Collect the AND output for OR combination later\n                        or_inputs.push_back(and_output);\n                    }\n                }\n            }\n        }\n    }\n\n    // Combine all pairs using an OR instruction\n    if (!or_inputs.empty()) {\n        int or_output = add_or(or_inputs);\n    }\n}"
  },
  {
    "date": "IOI 2019 day 2",
    "timestamp": "2025-04-11 17:47:25",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/E",
    "title": "E. Vision Program",
    "group_id": "32KGsXgiKA",
    "contest_id": "103779",
    "problem_index": "E",
    "submission_id": "314986395",
    "code_index": 1,
    "code": "#include <vector>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\n\n// Your code will be placed here\nvoid construct_network(int H, int W, int K) {\n    int pixel_count = H * W;\n    vector<int> valid_pairs;\n\n    // Compute all valid pairs of cells whose Manhattan distance is K\n    for (int r1 = 0; r1 < H; ++r1) {\n        for (int c1 = 0; c1 < W; ++c1) {\n            for (int r2 = 0; r2 < H; ++r2) {\n                for (int c2 = 0; c2 < W; ++c2) {\n                    if (r1 == r2 && c1 == c2) continue; // Skip same pixel\n                    if (abs(r1 - r2) + abs(c1 - c2) == K) {\n                        int cell1 = r1 * W + c1;\n                        int cell2 = r2 * W + c2;\n                        valid_pairs.push_back(cell1);\n                        valid_pairs.push_back(cell2);\n                    }\n                }\n            }\n        }\n    }\n\n    // Create instructions to check each valid pair\n    vector<int> pair_outputs;\n    for (size_t i = 0; i < valid_pairs.size(); i += 2) {\n        int cell1 = valid_pairs[i];\n        int cell2 = valid_pairs[i + 1];\n\n        // Add an AND instruction for the pair\n        int pair_output = add_and({cell1, cell2});\n        pair_outputs.push_back(pair_output);\n    }\n\n    // Combine all pair outputs using OR\n    int final_output = add_or(pair_outputs);\n\n    // The final output will determine if the distance is exactly K\n}"
  },
  {
    "date": "IOI 2019 day 2",
    "timestamp": "2025-04-11 17:48:02",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/E",
    "title": "E. Vision Program",
    "group_id": "32KGsXgiKA",
    "contest_id": "103779",
    "problem_index": "E",
    "submission_id": "314986395",
    "code_index": 2,
    "code": "#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n// Your code will be placed here\n\nvoid construct_network(int H, int W, int K) {\n    // Total number of cells in the grid\n    int totalCells = H * W;\n\n    // Store the indices of pairs of cells whose Manhattan distance is exactly K\n    vector<vector<int>> pairs;\n\n    // Iterate over all possible pairs of cells\n    for (int r1 = 0; r1 < H; ++r1) {\n        for (int c1 = 0; c1 < W; ++c1) {\n            for (int r2 = 0; r2 < H; ++r2) {\n                for (int c2 = 0; c2 < W; ++c2) {\n                    // Calculate Manhattan distance\n                    int distance = abs(r1 - r2) + abs(c1 - c2);\n                    if (distance == K) {\n                        // Compute cell indices in memory\n                        int cell1 = r1 * W + c1;\n                        int cell2 = r2 * W + c2;\n                        pairs.push_back({cell1, cell2});\n                    }\n                }\n            }\n        }\n    }\n\n    // Create AND instructions for each pair\n    vector<int> pairOutputs;\n    for (const auto& pair : pairs) {\n        int outputCell = add_and(pair);\n        pairOutputs.push_back(outputCell);\n    }\n\n    // Combine all pair outputs using OR instructions\n    if (!pairOutputs.empty()) {\n        int finalOutput = add_or(pairOutputs);\n    }\n}"
  },
  {
    "date": "IOI 2019 day 2",
    "timestamp": "2025-04-11 17:48:46",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103779/problem/E",
    "title": "E. Vision Program",
    "group_id": "32KGsXgiKA",
    "contest_id": "103779",
    "problem_index": "E",
    "submission_id": "314986547",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nvoid construct_network(int H, int W, int K) {\n    int num_cells = H * W; // Total number of cells in the grid\n    vector<int> valid_pairs;\n\n    // Iterate over all pairs of cells in the grid\n    for (int i = 0; i < num_cells; ++i) {\n        for (int j = i + 1; j < num_cells; ++j) {\n            // Decode the row and column indices of the two cells\n            int r1 = i / W, c1 = i % W;\n            int r2 = j / W, c2 = j % W;\n\n            // Calculate Manhattan distance\n            int manhattan_dist = abs(r1 - r2) + abs(c1 - c2);\n\n            // If the distance matches K, create an AND instruction for these two cells\n            if (manhattan_dist == K) {\n                // Add an AND instruction to check if both cells are black\n                int and_result = add_and({i, j});\n                valid_pairs.push_back(and_result);\n            }\n        }\n    }\n\n    // Combine all valid pairs using OR to determine if any pair has distance K\n    if (!valid_pairs.empty()) {\n        add_or(valid_pairs);\n    }\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 17:49:47",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/A",
    "title": "A. Closing Time",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "A",
    "submission_id": "314858420",
    "code_index": 0,
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\n// Function to compute distances from a given source node\nvoid compute_distances(int N, int source, const vector<vector<pair<int, int>>>& adj, vector<int64_t>& dist) {\n    dist.assign(N, numeric_limits<int64_t>::max());\n    dist[source] = 0;\n    priority_queue<pair<int64_t, int>, vector<pair<int64_t, int>>, greater<>> pq;\n    pq.push({0, source});\n\n    while (!pq.empty()) {\n        auto [current_dist, current_node] = pq.top();\n        pq.pop();\n\n        if (current_dist > dist[current_node]) continue;\n\n        for (auto [neighbor, weight] : adj[current_node]) {\n            int64_t new_dist = current_dist + weight;\n            if (new_dist < dist[neighbor]) {\n                dist[neighbor] = new_dist;\n                pq.push({new_dist, neighbor});\n            }\n        }\n    }\n}\n\nint max_score(int N, int X, int Y, int64_t K, vector<int> U, vector<int> V, vector<int> W) {\n    // Build adjacency list for the graph\n    vector<vector<pair<int, int>>> adj(N);\n    for (int i = 0; i < N - 1; ++i) {\n        adj[U[i]].emplace_back(V[i], W[i]);\n        adj[V[i]].emplace_back(U[i], W[i]);\n    }\n\n    // Compute distances from X and Y to all cities\n    vector<int64_t> dist_from_x, dist_from_y;\n    compute_distances(N, X, adj, dist_from_x);\n    compute_distances(N, Y, adj, dist_from_y);\n\n    // Combine distances to sort cities by their reachability from X and Y\n    vector<int64_t> combined_dist(N);\n    for (int i = 0; i < N; ++i) {\n        combined_dist[i] = min(dist_from_x[i], dist_from_y[i]);\n    }\n    sort(combined_dist.begin(), combined_dist.end());\n\n    // Binary search to find maximum convenience score under budget K\n    int max_score = 0;\n    int64_t current_sum = 0;\n    for (int i = 0; i < N; ++i) {\n        if (current_sum + combined_dist[i] <= K) {\n            current_sum += combined_dist[i];\n            max_score += 1;  // Each city contributes to the convenience score\n        } else {\n            break;  // Budget exceeded\n        }\n    }\n\n    return max_score;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 17:50:26",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/A",
    "title": "A. Closing Time",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "A",
    "submission_id": "314986746",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\ntypedef long long int64;\n\nvector<int64> dijkstra(int start, int N, const vector<vector<pair<int, int>>>& adj) {\n    vector<int64> dist(N, numeric_limits<int64>::max());\n    priority_queue<pair<int64, int>, vector<pair<int64, int>>, greater<pair<int64, int>>> pq;\n    dist[start] = 0;\n    pq.push({0, start});\n    while (!pq.empty()) {\n        auto [d, u] = pq.top();\n        pq.pop();\n        if (d > dist[u]) continue;\n        for (auto [v, w] : adj[u]) {\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    return dist;\n}\n\nint max_score(int N, int X, int Y, int64 K, vector<int> U, vector<int> V, vector<int> W) {\n    // Build adjacency list\n    vector<vector<pair<int, int>>> adj(N);\n    for (int i = 0; i < N - 1; ++i) {\n        adj[U[i]].emplace_back(V[i], W[i]);\n        adj[V[i]].emplace_back(U[i], W[i]);\n    }\n\n    // Calculate shortest paths from X and Y\n    vector<int64> distX = dijkstra(X, N, adj);\n    vector<int64> distY = dijkstra(Y, N, adj);\n\n    // Create a list of all cities with their distances from X and Y\n    vector<pair<int64, int64>> distances;\n    for (int i = 0; i < N; ++i) {\n        distances.push_back({distX[i], distY[i]});\n    }\n\n    // Sort cities by their distances from X (to simplify binary search)\n    sort(distances.begin(), distances.end());\n\n    // Binary search on the maximum reachable distance\n    auto canAchieve = [&](int64 maxDist) {\n        int64 totalCost = 0;\n        int64 scoreX = 0, scoreY = 0;\n\n        for (const auto& [dX, dY] : distances) {\n            if (dX <= maxDist) {\n                totalCost += dX;\n                ++scoreX;\n            }\n            if (dY <= maxDist) {\n                totalCost += dY;\n                ++scoreY;\n            }\n            if (totalCost > K) return false;\n        }\n        return true;\n    };\n\n    int64 low = 0, high = K, bestScore = 0;\n    while (low <= high) {\n        int64 mid = (low + high) / 2;\n        if (canAchieve(mid)) {\n            bestScore = mid;\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    return bestScore;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 17:51:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/A",
    "title": "A. Closing Time",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "A",
    "submission_id": "314986821",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint max_score(int N, int X, int Y, int64_t K, vector<int> U, vector<int> V, vector<int> W) {\n    // Step 1: Build the adjacency list representation of the tree\n    vector<vector<pair<int, int>>> adj(N); // {neighbor, weight}\n    for (int i = 0; i < N - 1; ++i) {\n        adj[U[i]].emplace_back(V[i], W[i]);\n        adj[V[i]].emplace_back(U[i], W[i]);\n    }\n\n    // Helper function to calculate distances from a given source\n    auto calculate_distances = [&](int src) {\n        vector<int64_t> dist(N, LLONG_MAX);\n        queue<int> q;\n        q.push(src);\n        dist[src] = 0;\n\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n            for (auto [neighbor, weight] : adj[curr]) {\n                if (dist[curr] + weight < dist[neighbor]) {\n                    dist[neighbor] = dist[curr] + weight;\n                    q.push(neighbor);\n                }\n            }\n        }\n        return dist;\n    };\n\n    // Step 2: Calculate distances from X and Y\n    vector<int64_t> dist_from_X = calculate_distances(X);\n    vector<int64_t> dist_from_Y = calculate_distances(Y);\n\n    // Step 3: Collect all unique distances and sort them\n    vector<int64_t> all_distances;\n    all_distances.insert(all_distances.end(), dist_from_X.begin(), dist_from_X.end());\n    all_distances.insert(all_distances.end(), dist_from_Y.begin(), dist_from_Y.end());\n    sort(all_distances.begin(), all_distances.end());\n    all_distances.erase(unique(all_distances.begin(), all_distances.end()), all_distances.end());\n\n    // Step 4: Binary search on the maximum closing time\n    int max_score = 0;\n    for (int64_t max_closing_time : all_distances) {\n        // Calculate reachable cities from X and Y within max_closing_time\n        vector<int> reachable_from_X(N, 0), reachable_from_Y(N, 0);\n        int64_t total_closing_time = 0;\n\n        for (int i = 0; i < N; ++i) {\n            if (dist_from_X[i] <= max_closing_time) {\n                reachable_from_X[i] = 1;\n                total_closing_time += dist_from_X[i];\n            }\n            if (dist_from_Y[i] <= max_closing_time) {\n                reachable_from_Y[i] = 1;\n                total_closing_time += dist_from_Y[i];\n            }\n        }\n\n        // Check if total closing time exceeds K\n        if (total_closing_time > K) continue;\n\n        // Count total reachable cities\n        int score = 0;\n        for (int i = 0; i < N; ++i) {\n            score += reachable_from_X[i] + reachable_from_Y[i];\n        }\n\n        max_score = max(max_score, score);\n    }\n\n    return max_score;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 17:51:45",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/A",
    "title": "A. Closing Time",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "A",
    "submission_id": "314986896",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <limits>\n\nusing namespace std;\n\nint max_score(int N, int X, int Y, int64_t K, vector<int> U, vector<int> V, vector<int> W) {\n    // Step 1: Build the adjacency list for the tree\n    vector<vector<pair<int, int>>> adj(N);\n    for (int i = 0; i < N - 1; i++) {\n        adj[U[i]].emplace_back(V[i], W[i]);\n        adj[V[i]].emplace_back(U[i], W[i]);\n    }\n\n    // Function to calculate distances from a given node\n    auto calculate_distances = [&](int start) {\n        vector<int64_t> dist(N, numeric_limits<int64_t>::max());\n        dist[start] = 0;\n        queue<int> q;\n        q.push(start);\n        \n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            for (auto [v, w] : adj[u]) {\n                if (dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                    q.push(v);\n                }\n            }\n        }\n        return dist;\n    };\n\n    // Step 2: Calculate distances from X and Y\n    vector<int64_t> dist_from_X = calculate_distances(X);\n    vector<int64_t> dist_from_Y = calculate_distances(Y);\n\n    // Step 3: Gather all distances and sort by minimum distance\n    vector<pair<int64_t, int>> dist_sorted_X(N);\n    vector<pair<int64_t, int>> dist_sorted_Y(N);\n\n    for (int i = 0; i < N; i++) {\n        dist_sorted_X[i] = {dist_from_X[i], i};\n        dist_sorted_Y[i] = {dist_from_Y[i], i};\n    }\n\n    // Sort by distance\n    sort(dist_sorted_X.begin(), dist_sorted_X.end());\n    sort(dist_sorted_Y.begin(), dist_sorted_Y.end());\n\n    // Step 4: Greedily allocate budget to maximize convenience score\n    int max_score = 0;\n    int64_t budget_used = 0;\n\n    vector<bool> reachable_from_X(N, false);\n    vector<bool> reachable_from_Y(N, false);\n\n    // Allocate budget for X\n    for (auto [dist, city] : dist_sorted_X) {\n        if (budget_used + dist <= K) {\n            budget_used += dist;\n            reachable_from_X[city] = true;\n        } else {\n            break;\n        }\n    }\n\n    // Allocate remaining budget for Y\n    for (auto [dist, city] : dist_sorted_Y) {\n        if (budget_used + dist <= K) {\n            budget_used += dist;\n            reachable_from_Y[city] = true;\n        } else {\n            break;\n        }\n    }\n\n    // Step 5: Calculate final convenience score\n    for (int i = 0; i < N; i++) {\n        if (reachable_from_X[i]) max_score++;\n        if (reachable_from_Y[i]) max_score++;\n    }\n\n    return max_score;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 17:52:22",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/A",
    "title": "A. Closing Time",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "A",
    "submission_id": "314986950",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <limits>\n\nusing namespace std;\n\nint max_score(int N, int X, int Y, int64_t K, vector<int> U, vector<int> V, vector<int> W) {\n    // Adjacency list representation of the graph\n    vector<vector<pair<int, int>>> graph(N);\n    for (int i = 0; i < U.size(); i++) {\n        graph[U[i]].emplace_back(V[i], W[i]);\n        graph[V[i]].emplace_back(U[i], W[i]);\n    }\n\n    // Function to calculate shortest distances from a source node using Dijkstra's algorithm\n    auto calculate_distances = [&](int source) {\n        vector<int64_t> distances(N, numeric_limits<int64_t>::max());\n        distances[source] = 0;\n        priority_queue<pair<int64_t, int>, vector<pair<int64_t, int>>, greater<>> pq;\n        pq.emplace(0, source);\n\n        while (!pq.empty()) {\n            auto [current_dist, node] = pq.top();\n            pq.pop();\n\n            if (current_dist > distances[node]) continue;\n\n            for (auto &[neighbor, weight] : graph[node]) {\n                if (distances[node] + weight < distances[neighbor]) {\n                    distances[neighbor] = distances[node] + weight;\n                    pq.emplace(distances[neighbor], neighbor);\n                }\n            }\n        }\n\n        return distances;\n    };\n\n    // Calculate distances from X and Y\n    vector<int64_t> dist_from_X = calculate_distances(X);\n    vector<int64_t> dist_from_Y = calculate_distances(Y);\n\n    // Combine all distances into a single vector for optimization\n    vector<pair<int64_t, int>> all_distances;\n    for (int i = 0; i < N; i++) {\n        all_distances.emplace_back(dist_from_X[i], i);\n        all_distances.emplace_back(dist_from_Y[i], i);\n    }\n\n    // Sort distances to prioritize smaller distances for allocation\n    sort(all_distances.begin(), all_distances.end());\n\n    // Allocate the closing times greedily while respecting the budget K\n    vector<int64_t> closing_times(N, 0);\n    int64_t used_budget = 0;\n    int max_score = 0;\n\n    for (auto &[distance, city] : all_distances) {\n        if (used_budget + distance <= K) {\n            int increment = (K - used_budget) / distance;\n            closing_times[city] += increment;\n            used_budget += increment * distance;\n            max_score++;\n        }\n    }\n\n    return max_score;\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 17:53:17",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/F",
    "title": "F. Towns",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "F",
    "submission_id": "314857610",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\n#include <limits>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\n// Grader function (defined externally, provided in the problem description)\n// int getDistance(int i, int j);\n\nint hubDistance(int N, int sub) {\n    // Initialize variables\n    vector<vector<int>> distances(N, vector<int>(N, 0));\n    int maxQueryLimit = (sub == 1 || sub == 3) ? N * (N - 1) / 2 : ceil(7.0 * N / 2);\n    \n    // Step 1: Query all distances\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            distances[i][j] = getDistance(i, j);\n            distances[j][i] = distances[i][j];\n        }\n    }\n    \n    // Step 2: Identify candidate hubs and compute `r(C)` values\n    unordered_set<int> candidateHubs;\n    vector<int> farthestDistances(N, 0);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            farthestDistances[i] = max(farthestDistances[i], distances[i][j]);\n        }\n    }\n    \n    int R = *min_element(farthestDistances.begin(), farthestDistances.end());\n    \n    // Step 3: Check for balanced hub (subtasks 3 to 6)\n    if (sub >= 3) {\n        for (int hub = 0; hub < N; ++hub) {\n            if (farthestDistances[hub] == R) {\n                // Check if removing this hub results in balanced pieces\n                vector<bool> visited(N, false);\n                queue<int> q;\n                int componentSize = 0;\n                visited[hub] = true; // Mark hub as \"removed\"\n                \n                for (int i = 0; i < N; ++i) {\n                    if (!visited[i]) {\n                        componentSize = 0;\n                        q.push(i);\n                        while (!q.empty()) {\n                            int curr = q.front();\n                            q.pop();\n                            visited[curr] = true;\n                            componentSize++;\n                            for (int j = 0; j < N; ++j) {\n                                if (!visited[j] && distances[curr][j] > 0) {\n                                    q.push(j);\n                                }\n                            }\n                        }\n                        if (componentSize > N / 2) {\n                            return -R; // Not balanced\n                        }\n                    }\n                }\n                return R; // Balanced hub found\n            }\n        }\n        return -R; // No balanced hub\n    }\n    \n    // Step 4: Return R for subtasks 1 and 2\n    return R;\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 17:53:59",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/F",
    "title": "F. Towns",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "F",
    "submission_id": "314987054",
    "code_index": 1,
    "code": "#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\n// Grader function declaration (provided by the competition environment)\nint getDistance(int i, int j);\n\n// Helper function to get the farthest distance from a given node\nint getFarthestDistance(int start, int N) {\n    int maxDist = 0;\n    for (int i = 0; i < N; ++i) {\n        if (i != start) {\n            maxDist = max(maxDist, getDistance(start, i));\n        }\n    }\n    return maxDist;\n}\n\n// Find the hub distance R and check for balanced hub if required\nint hubDistance(int N, int sub) {\n    // Variable to store the farthest distances for each node\n    vector<int> farthestDistances(N);\n    \n    // Compute the farthest distance for each small town\n    for (int i = 0; i < N; ++i) {\n        farthestDistances[i] = getFarthestDistance(i, N);\n    }\n    \n    // Determine the minimum of the farthest distances\n    int R = *min_element(farthestDistances.begin(), farthestDistances.end());\n    \n    // If the subtask does not require checking for balanced hub, return R\n    if (sub <= 2) {\n        return R;\n    }\n    \n    // Check for balanced hub\n    for (int hub = 0; hub < N; ++hub) {\n        // Divide the network into connected components by removing the hub\n        vector<bool> visited(N, false);\n        visited[hub] = true; // Mark the hub as \"removed\"\n        queue<int> q;\n        vector<int> componentSizes;\n        \n        for (int start = 0; start < N; ++start) {\n            if (!visited[start]) {\n                // Start a BFS to find the size of the connected component\n                int componentSize = 0;\n                q.push(start);\n                visited[start] = true;\n                \n                while (!q.empty()) {\n                    int u = q.front();\n                    q.pop();\n                    ++componentSize;\n                    \n                    for (int v = 0; v < N; ++v) {\n                        if (v != hub && !visited[v] && getDistance(u, v) > 0) {\n                            visited[v] = true;\n                            q.push(v);\n                        }\n                    }\n                }\n                \n                componentSizes.push_back(componentSize);\n            }\n        }\n        \n        // Check if all components are balanced\n        int maxSmallTowns = floor(N / 2);\n        bool isBalanced = true;\n        for (int size : componentSizes) {\n            if (size > maxSmallTowns) {\n                isBalanced = false;\n                break;\n            }\n        }\n        \n        if (isBalanced) {\n            return R;\n        }\n    }\n    \n    // If no balanced hub was found, return -R\n    return -R;\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 17:54:44",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/F",
    "title": "F. Towns",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "F",
    "submission_id": "314987208",
    "code_index": 2,
    "code": "#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <limits>\nusing namespace std;\n\n// Grader function to query distances\nextern int getDistance(int i, int j);\n\nint hubDistance(int N, int sub) {\n    // Initialize variables\n    vector<vector<int>> distances(N, vector<int>(N, -1));\n    vector<int> maxDistances(N, 0); // To store max distance for each small town\n    int R = numeric_limits<int>::max(); // Smallest maximum distance\n    int hub = -1; // Candidate hub\n    \n    // Step 1: Build the distance matrix\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            int dist = getDistance(i, j);\n            distances[i][j] = distances[j][i] = dist;\n        }\n    }\n\n    // Step 2: Identify the hub and calculate R\n    for (int i = 0; i < N; ++i) {\n        // Calculate the maximum distance from this town to all other towns\n        for (int j = 0; j < N; ++j) {\n            maxDistances[i] = max(maxDistances[i], distances[i][j]);\n        }\n        // Update R and hub if a better candidate is found\n        if (maxDistances[i] < R) {\n            R = maxDistances[i];\n            hub = i;\n        }\n    }\n\n    // Step 3: Check for balanced hub (if required)\n    if (sub > 2) {\n        vector<bool> visited(N, false);\n        vector<int> componentSizes;\n        \n        // Simulate removal of the hub\n        visited[hub] = true;\n        for (int i = 0; i < N; ++i) {\n            if (!visited[i]) {\n                // Perform BFS/DFS to find the size of the connected component\n                int size = 0;\n                queue<int> q;\n                q.push(i);\n                visited[i] = true;\n                while (!q.empty()) {\n                    int current = q.front();\n                    q.pop();\n                    ++size;\n                    for (int j = 0; j < N; ++j) {\n                        if (!visited[j] && distances[current][j] != -1) {\n                            visited[j] = true;\n                            q.push(j);\n                        }\n                    }\n                }\n                componentSizes.push_back(size);\n            }\n        }\n        \n        // Check if the hub is balanced\n        int maxComponentSize = *max_element(componentSizes.begin(), componentSizes.end());\n        if (maxComponentSize > N / 2) {\n            return -R; // Not balanced\n        }\n    }\n\n    // Return R (positive if balanced or balance not required, negative otherwise)\n    return R;\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 17:55:26",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/F",
    "title": "F. Towns",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "F",
    "submission_id": "314987208",
    "code_index": 3,
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\n\n// Your code will be placed here\nint hubDistance(int N, int sub) {\n    // Function to determine the farthest distance from a settlement\n    auto findFarthestDistance = [&](int start) {\n        vector<int> distances(N, INT_MAX);\n        distances[start] = 0;\n        \n        queue<int> q;\n        q.push(start);\n        \n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n            \n            for (int i = 0; i < N; ++i) {\n                if (i != current && distances[i] == INT_MAX) {\n                    int d = getDistance(current, i);\n                    distances[i] = distances[current] + d;\n                    q.push(i);\n                }\n            }\n        }\n        \n        return *max_element(distances.begin(), distances.end());\n    };\n\n    // Compute farthest distances for all settlements\n    vector<int> farthestDistances(N);\n    for (int i = 0; i < N; ++i) {\n        farthestDistances[i] = findFarthestDistance(i);\n    }\n\n    // Determine R (minimum of farthest distances)\n    int R = *min_element(farthestDistances.begin(), farthestDistances.end());\n\n    // If subtask requires balanced hub check\n    if (sub > 2) {\n        // Check if any hub is balanced\n        for (int i = 0; i < N; ++i) {\n            // Simulate removing the hub and checking connected components\n            vector<int> componentSizes;\n            vector<bool> visited(N, false);\n\n            auto dfs = [&](int node, auto& dfs) -> int {\n                visited[node] = true;\n                int size = 1;\n                \n                for (int j = 0; j < N; ++j) {\n                    if (j != node && !visited[j] && getDistance(node, j) > 0) {\n                        size += dfs(j, dfs);\n                    }\n                }\n                return size;\n            };\n\n            for (int j = 0; j < N; ++j) {\n                if (!visited[j]) {\n                    componentSizes.push_back(dfs(j, dfs));\n                }\n            }\n\n            // Check if all components are balanced\n            int maxComponentSize = *max_element(componentSizes.begin(), componentSizes.end());\n            if (maxComponentSize <= N / 2) {\n                return R; // Balanced hub found\n            }\n        }\n\n        return -R; // No balanced hub found\n    }\n\n    // For subtasks 1 and 2, simply return R or -R\n    return R;\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 17:56:05",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/F",
    "title": "F. Towns",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "F",
    "submission_id": "314987279",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n// Function to be implemented\nint hubDistance(int N, int sub) {\n    // Initialize variables\n    vector<int> maxDistances(N, 0);  // Store the max distance for each small town\n    vector<vector<int>> distances(N, vector<int>(N));  // Cache queried distances\n\n    // Query all pairwise distances or a subset based on the subtask\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            distances[i][j] = distances[j][i] = getDistance(i, j);\n        }\n    }\n\n    // Compute max distance for each small town\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (i != j) {\n                maxDistances[i] = max(maxDistances[i], distances[i][j]);\n            }\n        }\n    }\n\n    // Find the minimum of the max distances (R)\n    int R = *min_element(maxDistances.begin(), maxDistances.end());\n\n    // If subtask is 1 or 2, just return R or -R based on requirements\n    if (sub == 1 || sub == 2) {\n        return R;\n    }\n\n    // For subtasks >= 3, determine if there is a balanced hub\n    // Iterate over all settlements to check the balanced condition\n    for (int hub = 0; hub < N; ++hub) {\n        // Simulate removing the hub and check the sizes of connected components\n        vector<bool> visited(N, false);\n        vector<int> componentSizes;\n\n        // Perform DFS to find connected components\n        for (int i = 0; i < N; ++i) {\n            if (i != hub && !visited[i]) {\n                int componentSize = 0;\n                vector<int> stack = {i};\n                visited[i] = true;\n\n                while (!stack.empty()) {\n                    int current = stack.back();\n                    stack.pop_back();\n                    ++componentSize;\n\n                    for (int neighbor = 0; neighbor < N; ++neighbor) {\n                        if (neighbor != hub && !visited[neighbor] && distances[current][neighbor] > 0) {\n                            visited[neighbor] = true;\n                            stack.push_back(neighbor);\n                        }\n                    }\n                }\n\n                componentSizes.push_back(componentSize);\n            }\n        }\n\n        // Check if all connected components are balanced\n        int maxSmallTownsInComponent = *max_element(componentSizes.begin(), componentSizes.end());\n        if (maxSmallTownsInComponent <= floor(N / 2.0)) {\n            return R;  // There exists a balanced hub\n        }\n    }\n\n    // If no balanced hub is found, return -R\n    return -R;\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 17:57:01",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/E",
    "title": "E. Dungeons Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "E",
    "submission_id": "314987469",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cstdint>\n\nusing namespace std;\n\n// Global variables to store the game configuration\nint global_n;\nvector<int> global_s, global_p, global_w, global_l;\n\n// Function to initialize the game state\nvoid init(int n, vector<int> s, vector<int> p, vector<int> w, vector<int> l) {\n    global_n = n;\n    global_s = move(s);\n    global_p = move(p);\n    global_w = move(w);\n    global_l = move(l);\n}\n\n// Function to simulate the game for a given starting dungeon `x` and starting strength `z`\nint64_t simulate(int x, int z) {\n    int current_dungeon = x;\n    int64_t hero_strength = z;\n\n    // Simulate the game until reaching dungeon `n`\n    while (current_dungeon != global_n) {\n        if (hero_strength >= global_s[current_dungeon]) {\n            // Hero wins\n            hero_strength += global_s[current_dungeon];\n            current_dungeon = global_w[current_dungeon];\n        } else {\n            // Hero loses\n            hero_strength += global_p[current_dungeon];\n            current_dungeon = global_l[current_dungeon];\n        }\n    }\n\n    return hero_strength;\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 17:57:39",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/E",
    "title": "E. Dungeons Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "E",
    "submission_id": "314987469",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cstdint>\nusing namespace std;\n\nvector<int> s, p, w, l; // Global variables to store the game configuration data\n\nvoid init(int n, vector<int> s_input, vector<int> p_input, vector<int> w_input, vector<int> l_input) {\n    // Initialize the game configuration\n    s = move(s_input); // Strength of opponents\n    p = move(p_input); // Strength gained on loss\n    w = move(w_input); // Dungeon to enter on win\n    l = move(l_input); // Dungeon to enter on loss\n}\n\nint64_t simulate(int x, int z) {\n    // Simulate the game starting from dungeon x with strength z\n    int64_t hero_strength = z; // Hero's current strength, use int64_t to avoid overflow\n    while (x != (int)s.size()) { // Continue until the hero reaches dungeon n (size of s)\n        if (hero_strength >= s[x]) {\n            // Hero wins the confrontation\n            hero_strength += s[x]; // Gain strength\n            x = w[x]; // Move to the dungeon specified by w[x]\n        } else {\n            // Hero loses the confrontation\n            hero_strength += p[x]; // Gain strength\n            x = l[x]; // Move to the dungeon specified by l[x]\n        }\n    }\n    return hero_strength; // Return the hero's final strength\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 17:58:19",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/E",
    "title": "E. Dungeons Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "E",
    "submission_id": "314987623",
    "code_index": 2,
    "code": "#include <vector>\n#include <cstdint>\nusing namespace std;\n\n// Global variables to store the game parameters.\nint n; // Number of opponents.\nvector<int> s, p, w, l; // Strength, penalty, win-next, lose-next.\n\nvoid init(int n_input, vector<int> s_input, vector<int> p_input, vector<int> w_input, vector<int> l_input) {\n    // Initialize the global variables with the input values.\n    n = n_input;\n    s = move(s_input);\n    p = move(p_input);\n    w = move(w_input);\n    l = move(l_input);\n}\n\nint64_t simulate(int x, int z) {\n    int current_dungeon = x;\n    int64_t hero_strength = z;\n\n    // Simulate the game until the hero reaches dungeon n.\n    while (current_dungeon != n) {\n        if (hero_strength >= s[current_dungeon]) {\n            // Hero wins the confrontation.\n            hero_strength += s[current_dungeon];\n            current_dungeon = w[current_dungeon];\n        } else {\n            // Hero loses the confrontation.\n            hero_strength += p[current_dungeon];\n            current_dungeon = l[current_dungeon];\n        }\n    }\n\n    // Return the hero's final strength upon reaching dungeon n.\n    return hero_strength;\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 17:58:57",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/E",
    "title": "E. Dungeons Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "E",
    "submission_id": "314987686",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cstdint>\nusing namespace std;\n\n// Global variables to store the game data\nint n; // Number of opponents\nvector<int> s, p, w, l; // Strengths, penalties, win transitions, lose transitions\n\n// Initialize the game with the given parameters\nvoid init(int n_input, vector<int> s_input, vector<int> p_input, vector<int> w_input, vector<int> l_input) {\n    n = n_input;\n    s = s_input;\n    p = p_input;\n    w = w_input;\n    l = l_input;\n}\n\n// Simulate the game for the given starting dungeon `x` and strength `z`\nint64_t simulate(int x, int z) {\n    int64_t hero_strength = z; // Current strength of the hero\n    int current_dungeon = x;  // Current dungeon\n\n    while (current_dungeon != n) {\n        if (hero_strength >= s[current_dungeon]) {\n            // Hero wins the confrontation\n            hero_strength += s[current_dungeon];\n            current_dungeon = w[current_dungeon];\n        } else {\n            // Hero loses the confrontation\n            hero_strength += p[current_dungeon];\n            current_dungeon = l[current_dungeon];\n        }\n    }\n\n    return hero_strength; // Game ends, return the final strength\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 17:59:40",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/E",
    "title": "E. Dungeons Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "E",
    "submission_id": "314987686",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nint n;\nvector<int> s, p, w, l;\n\nvoid init(int n_, vector<int> s_, vector<int> p_, vector<int> w_, vector<int> l_) {\n    n = n_;\n    s = s_;\n    p = p_;\n    w = w_;\n    l = l_;\n}\n\nint64_t simulate(int x, int z) {\n    int currentDungeon = x;\n    int64_t heroStrength = z;\n\n    while (currentDungeon != n) {\n        if (heroStrength >= s[currentDungeon]) {\n            // Hero wins\n            heroStrength += s[currentDungeon];\n            currentDungeon = w[currentDungeon];\n        } else {\n            // Hero loses\n            heroStrength += p[currentDungeon];\n            currentDungeon = l[currentDungeon];\n        }\n    }\n\n    return heroStrength;\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 18:00:29",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/A",
    "title": "A. Tropical Garden",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "A",
    "submission_id": "314981047",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to simulate the required behavior and calculate the number of routes\nvoid count_routes(int N, int M, int P, vector<vector<int>> R, int Q, vector<int> G) {\n    // Step 1: Build the graph representation\n    vector<vector<pair<int, int>>> adj(N); // adjacency list with (neighbor, trail index)\n    for (int i = 0; i < M; i++) {\n        int u = R[i][0], v = R[i][1];\n        adj[u].emplace_back(v, i); // Add trail i from u to v\n        adj[v].emplace_back(u, i); // Add trail i from v to u\n    }\n\n    // Step 2: Sort the adjacency list by trail index (beauty is implied by index order)\n    for (int i = 0; i < N; i++) {\n        sort(adj[i].begin(), adj[i].end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n            return a.second < b.second; // Sort by trail index (ascending order)\n        });\n    }\n\n    // Step 3: Use dynamic programming to count routes\n    // dp[k][u][last_trail]: number of ways to reach fountain u after k trails, using last_trail\n    unordered_map<int, vector<unordered_map<int, long long>>> dp(2); // Use two layers for optimization\n    const int MOD = 1000000007; // Modulo for large numbers\n\n    // Initialize dp for k = 0 (only at P)\n    dp[0][P][-1] = 1; // Start at P with no trails taken\n\n    // Determine the maximum K value we need to compute\n    int max_k = *max_element(G.begin(), G.end());\n\n    // Process up to max_k steps\n    for (int k = 1; k <= max_k; k++) {\n        dp[k % 2].clear(); // Clear the current layer\n\n        for (int u = 0; u < N; u++) { // Iterate over all fountains\n            for (const auto& [last_trail, count] : dp[(k - 1) % 2][u]) { // Previous state\n                for (const auto& [v, trail] : adj[u]) { // Explore neighbors\n                    if (trail != last_trail) { // Avoid repeating the last trail if possible\n                        dp[k % 2][v][trail] = (dp[k % 2][v][trail] + count) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    // Step 4: Answer each query\n    for (int i = 0; i < Q; i++) {\n        int k = G[i];\n        long long result = 0;\n\n        if (k <= max_k) {\n            for (const auto& [trail, count] : dp[k % 2][P]) {\n                result = (result + count) % MOD; // Sum all routes ending at P with k trails\n            }\n        }\n\n        // Call the answer function with the result\n        answer(result);\n    }\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 18:01:12",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/A",
    "title": "A. Tropical Garden",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "A",
    "submission_id": "314987851",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to report the answer for a group\nvoid answer(int X);\n\nvoid count_routes(int N, int M, int P, vector<vector<int>> R, int Q, vector<int> G) {\n    // Step 1: Build the graph with trails sorted by beauty\n    vector<vector<pair<int, int>>> adj(N); // adj[u] contains pairs {v, trail_id}, sorted by beauty\n    for (int i = 0; i < M; ++i) {\n        int u = R[i][0];\n        int v = R[i][1];\n        adj[u].emplace_back(v, i);\n        adj[v].emplace_back(u, i);\n    }\n\n    // Sort adjacency lists by trail_id (beauty is implied by the input order of R)\n    for (int i = 0; i < N; ++i) {\n        sort(adj[i].begin(), adj[i].end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n            return a.second < b.second; // Sort by trail_id (beauty)\n        });\n    }\n\n    // Step 2: Dynamic Programming (DP) to compute the number of routes\n    // dp[k][u][last_trail] = number of ways to reach fountain u after exactly k trails,\n    //                       where the last trail used is last_trail\n    unordered_map<int, vector<vector<long long>>> dp;\n    for (int k : G) {\n        dp[k] = vector<vector<long long>>(N, vector<long long>(M + 1, 0));\n    }\n\n    // Initialize DP for k = 0\n    for (int u = 0; u < N; ++u) {\n        for (int trail_id = 0; trail_id <= M; ++trail_id) {\n            if (trail_id == M) dp[0][u][trail_id] = 1; // Start without using any trail\n        }\n    }\n\n    // Iterate over all values of k up to max(G)\n    int max_k = *max_element(G.begin(), G.end());\n    for (int k = 1; k <= max_k; ++k) {\n        if (dp.find(k) == dp.end()) continue; // Skip if k is not in G\n\n        // Iterate over all fountains\n        for (int u = 0; u < N; ++u) {\n            // Iterate over all possible incoming trails (including \"no last trail\" case M)\n            for (int last_trail = 0; last_trail <= M; ++last_trail) {\n                // Compute the number of routes to u using exactly k trails\n                for (auto& [v, trail_id] : adj[u]) {\n                    if (trail_id == last_trail) continue; // Skip the last trail used\n\n                    dp[k][u][trail_id] += dp[k - 1][v][last_trail];\n                }\n            }\n        }\n    }\n\n    // Step 3: Compute results for each query\n    for (int k : G) {\n        long long total_routes = 0;\n        for (int last_trail = 0; last_trail <= M; ++last_trail) {\n            total_routes += dp[k][P][last_trail];\n        }\n        answer(static_cast<int>(total_routes));\n    }\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 18:01:57",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/A",
    "title": "A. Tropical Garden",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "A",
    "submission_id": "314987997",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// Function provided by the grader to report answers\nvoid answer(int X);\n\nvoid count_routes(int N, int M, int P, vector<vector<int>> R, int Q, vector<int> G) {\n    // Step 1: Build adjacency list with trails sorted by beauty\n    vector<vector<pair<int, int>>> adj(N); // (neighbor, trail index)\n    for (int i = 0; i < M; ++i) {\n        int u = R[i][0], v = R[i][1];\n        adj[u].emplace_back(v, i);\n        adj[v].emplace_back(u, i);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        sort(adj[i].begin(), adj[i].end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n            return a.second < b.second; // Sort by trail index (beauty order)\n        });\n    }\n\n    // Step 2: Initialize DP table\n    const int MOD = 1e9 + 7;\n    vector<vector<long long>> dp(2, vector<long long>(N, 0)); // We only need two layers (current and previous)\n    dp[0][P] = 1; // Base case: 1 way to reach P with 0 steps\n\n    // Step 3: Precompute answers for the maximum K in G\n    int maxK = *max_element(G.begin(), G.end());\n    for (int k = 1; k <= maxK; ++k) {\n        int curr = k % 2, prev = 1 - curr;\n        fill(dp[curr].begin(), dp[curr].end(), 0); // Reset current layer\n\n        for (int u = 0; u < N; ++u) {\n            if (dp[prev][u] == 0) continue; // No ways to reach u in k-1 steps\n\n            int trailCount = adj[u].size();\n            for (int i = 0; i < trailCount; ++i) {\n                int v = adj[u][i].first; // Neighbor\n                dp[curr][v] = (dp[curr][v] + dp[prev][u]) % MOD;\n            }\n        }\n    }\n\n    // Step 4: Answer queries\n    for (int k : G) {\n        answer(dp[k % 2][P]);\n    }\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 18:02:37",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/A",
    "title": "A. Tropical Garden",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "A",
    "submission_id": "314988074",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\n// This function will be called to report the answer for each query\nvoid answer(int X);\n\nvoid count_routes(int N, int M, int P, vector<vector<int>> R, int Q, vector<int> G) {\n    // Step 1: Represent the graph with adjacency lists and sort edges by beauty\n    vector<vector<pair<int, int>>> adj(N); // {neighbor, trail index}\n    for (int i = 0; i < M; ++i) {\n        int u = R[i][0];\n        int v = R[i][1];\n        adj[u].push_back({v, i});\n        adj[v].push_back({u, i});\n    }\n\n    // Sort adjacency lists by trail index (beauty order)\n    for (int i = 0; i < N; ++i) {\n        sort(adj[i].begin(), adj[i].end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n            return a.second < b.second; // Sort by trail index (beauty)\n        });\n    }\n\n    // Step 2: Dynamic programming to count routes\n    // dp[k][u][last_trail]: Number of ways to reach fountain `u` in `k` steps, coming via `last_trail`\n    unordered_map<int, vector<unordered_map<int, long long>>> dp(Q);\n\n    // Base case: At step 0, only `P` is reachable, with no trail used\n    for (int q = 0; q < Q; ++q) {\n        int K = G[q];\n        dp[q].resize(K + 1);\n        dp[q][0][P] = 1; // Start at fountain P\n    }\n\n    // For each query, compute paths using dynamic programming\n    for (int q = 0; q < Q; ++q) {\n        int K = G[q];\n        // Iterate over steps from 1 to K\n        for (int k = 1; k <= K; ++k) {\n            // Iterate over all fountains\n            for (int u = 0; u < N; ++u) {\n                // If there are no ways to reach `u` in `k-1` steps, skip\n                if (dp[q][k - 1].find(u) == dp[q][k - 1].end()) continue;\n\n                // Iterate over all trails from `u`\n                for (int i = 0; i < (int)adj[u].size(); ++i) {\n                    int v = adj[u][i].first;\n                    int trail = adj[u][i].second;\n\n                    // Consider the most beautiful trail and avoid reusing the same trail consecutively\n                    if (i == 0 || (i > 0 && trail != adj[u][i - 1].second)) {\n                        dp[q][k][v] += dp[q][k - 1][u];\n                    }\n                }\n            }\n        }\n    }\n\n    // Step 3: Compute results for each query\n    for (int q = 0; q < Q; ++q) {\n        int K = G[q];\n        long long result = 0;\n\n        // Sum all paths that reach any fountain after exactly K steps\n        for (int u = 0; u < N; ++u) {\n            result += dp[q][K][u];\n        }\n\n        // Report the result for this query\n        answer(result % 1000000007); // Modulo 10^9+7 to prevent overflow\n    }\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 18:03:34",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/B",
    "title": "B. Keys",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "B",
    "submission_id": "314988170",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> find_reachable(vector<int> r, vector<int> u, vector<int> v, vector<int> c) {\n    int n = r.size(); // Number of rooms\n    int m = u.size(); // Number of connectors\n\n    // Adjacency list representation of the graph\n    vector<vector<pair<int, int>>> graph(n); // {neighbor, required_key}\n    for (int i = 0; i < m; i++) {\n        graph[u[i]].push_back({v[i], c[i]});\n        graph[v[i]].push_back({u[i], c[i]});\n    }\n\n    // Function to compute reachable rooms from a given starting room\n    auto bfs = [&](int start) -> int {\n        vector<bool> visited(n, false);\n        unordered_set<int> keys_collected;\n        queue<int> q;\n\n        // Start BFS from the starting room\n        q.push(start);\n        visited[start] = true;\n        keys_collected.insert(r[start]); // Collect the key in the starting room\n\n        int reachable_count = 0;\n\n        while (!q.empty()) {\n            int room = q.front();\n            q.pop();\n            reachable_count++;\n\n            // Traverse all neighbors\n            for (auto& edge : graph[room]) {\n                int neighbor = edge.first;\n                int required_key = edge.second;\n\n                // Check if the key required for the edge is collected\n                if (!visited[neighbor] && keys_collected.count(required_key)) {\n                    visited[neighbor] = true;\n                    q.push(neighbor);\n                    keys_collected.insert(r[neighbor]); // Collect the key in this room\n                }\n            }\n        }\n\n        return reachable_count;\n    };\n\n    // Calculate reachable rooms for all starting points\n    vector<int> p(n);\n    for (int i = 0; i < n; i++) {\n        p[i] = bfs(i);\n    }\n\n    // Find the minimum value of p[i]\n    int min_reachable = *min_element(p.begin(), p.end());\n\n    // Create the result array\n    vector<int> result(n, 0);\n    for (int i = 0; i < n; i++) {\n        if (p[i] == min_reachable) {\n            result[i] = 1;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 18:04:18",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/B",
    "title": "B. Keys",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "B",
    "submission_id": "314988240",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <limits>\n\nusing namespace std;\n\nvector<int> find_reachable(vector<int> r, vector<int> u, vector<int> v, vector<int> c) {\n    int n = r.size();\n    int m = u.size();\n\n    // Adjacency list for the graph\n    vector<vector<pair<int, int>>> graph(n);  // {neighbor, required_key}\n    for (int i = 0; i < m; ++i) {\n        graph[u[i]].emplace_back(v[i], c[i]);\n        graph[v[i]].emplace_back(u[i], c[i]);\n    }\n\n    // Function to calculate reachable rooms from a given start room\n    auto bfs = [&](int start) {\n        unordered_set<int> visited;  // Visited rooms\n        unordered_set<int> keys;     // Collected keys\n        queue<int> q;                // Queue for BFS\n\n        // Start BFS from the given room\n        q.push(start);\n        visited.insert(start);\n        keys.insert(r[start]);  // Collect the key in the starting room\n\n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n\n            // Explore neighbors\n            for (auto& [neighbor, required_key] : graph[current]) {\n                if (visited.count(neighbor)) continue;  // Skip if already visited\n                if (keys.count(required_key)) {        // Can traverse if key is available\n                    visited.insert(neighbor);\n                    q.push(neighbor);\n                    keys.insert(r[neighbor]);  // Collect the key in the neighbor room\n                }\n            }\n        }\n\n        return visited.size();  // Return the number of reachable rooms\n    };\n\n    // Calculate p[i] for all rooms\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        p[i] = bfs(i);\n    }\n\n    // Find the minimum value of p[i]\n    int min_p = *min_element(p.begin(), p.end());\n\n    // Construct the result array\n    vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        result[i] = (p[i] == min_p) ? 1 : 0;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 18:04:58",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/B",
    "title": "B. Keys",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "B",
    "submission_id": "314988240",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> find_reachable(vector<int> r, vector<int> u, vector<int> v, vector<int> c) {\n    int n = r.size(); // Number of rooms\n    int m = u.size(); // Number of connectors\n\n    // Create a graph representation where edges are restricted by key type\n    vector<vector<pair<int, int>>> graph(n); // adjacency list: {neighbor, required_key_type}\n    for (int i = 0; i < m; ++i) {\n        graph[u[i]].emplace_back(v[i], c[i]);\n        graph[v[i]].emplace_back(u[i], c[i]);\n    }\n\n    // Function to calculate reachable rooms from a given starting room\n    auto bfs = [&](int start) {\n        unordered_set<int> collected_keys; // Keys collected during traversal\n        queue<int> q; // Queue for BFS\n        unordered_set<int> visited; // Visited rooms\n        q.push(start);\n        visited.insert(start);\n        collected_keys.insert(r[start]); // Collect the key from the starting room\n\n        while (!q.empty()) {\n            int curr = q.front();\n            q.pop();\n\n            for (auto& neighbor : graph[curr]) {\n                int next_room = neighbor.first;\n                int required_key = neighbor.second;\n\n                if (visited.find(next_room) == visited.end() && collected_keys.count(required_key)) {\n                    visited.insert(next_room);\n                    q.push(next_room);\n                    collected_keys.insert(r[next_room]); // Collect the key from the next room\n                }\n            }\n        }\n\n        return visited.size(); // Number of reachable rooms\n    };\n\n    // Calculate reachable rooms for each starting room\n    vector<int> reachable_count(n);\n    for (int i = 0; i < n; ++i) {\n        reachable_count[i] = bfs(i);\n    }\n\n    // Find the minimum reachable room count\n    int min_reachable = *min_element(reachable_count.begin(), reachable_count.end());\n\n    // Create the result array\n    vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        result[i] = (reachable_count[i] == min_reachable) ? 1 : 0;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 18:05:42",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/B",
    "title": "B. Keys",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "B",
    "submission_id": "314988406",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_set>\n\nusing namespace std;\n\nvector<int> find_reachable(vector<int> r, vector<int> u, vector<int> v, vector<int> c) {\n    int n = r.size();\n    int m = u.size();\n\n    // Adjacency list to store graph structure\n    vector<vector<pair<int, int>>> graph(n); // graph[node] contains pairs (neighbor, key_type)\n    for (int i = 0; i < m; ++i) {\n        graph[u[i]].emplace_back(v[i], c[i]);\n        graph[v[i]].emplace_back(u[i], c[i]);\n    }\n\n    // Function to compute reachable rooms starting from a given room\n    auto compute_reachable = [&](int start) {\n        unordered_set<int> collected_keys; // Keys collected by the player\n        unordered_set<int> visited_rooms; // Rooms visited by the player\n        queue<int> bfs_queue;             // BFS queue for traversal\n\n        // Start BFS from the initial room\n        bfs_queue.push(start);\n        visited_rooms.insert(start);\n        collected_keys.insert(r[start]); // Collect the key in the starting room\n\n        while (!bfs_queue.empty()) {\n            int current_room = bfs_queue.front();\n            bfs_queue.pop();\n\n            // Traverse all connectors from the current room\n            for (auto& [neighbor, key_type] : graph[current_room]) {\n                // Check if the connector can be traversed\n                if (collected_keys.count(key_type) && !visited_rooms.count(neighbor)) {\n                    visited_rooms.insert(neighbor);\n                    bfs_queue.push(neighbor);\n                    collected_keys.insert(r[neighbor]); // Collect the key in the neighbor room\n                }\n            }\n        }\n\n        // Return the number of reachable rooms\n        return visited_rooms.size();\n    };\n\n    // Compute the reachable rooms count for each room\n    vector<int> reachable_count(n);\n    for (int i = 0; i < n; ++i) {\n        reachable_count[i] = compute_reachable(i);\n    }\n\n    // Find the minimum reachable count\n    int min_reachable = *min_element(reachable_count.begin(), reachable_count.end());\n\n    // Create the result array\n    vector<int> result(n, 0);\n    for (int i = 0; i < n; ++i) {\n        if (reachable_count[i] == min_reachable) {\n            result[i] = 1;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 18:06:21",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/B",
    "title": "B. Keys",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "B",
    "submission_id": "314988483",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_set>\nusing namespace std;\n\nvector<int> find_reachable(vector<int> r, vector<int> u, vector<int> v, vector<int> c) {\n    int n = r.size();\n    int m = u.size();\n\n    // Step 1: Build the graph with constraints\n    vector<vector<pair<int, int>>> graph(n); // graph[i] = list of (neighbor, required_key)\n    for (int j = 0; j < m; ++j) {\n        graph[u[j]].emplace_back(v[j], c[j]);\n        graph[v[j]].emplace_back(u[j], c[j]);\n    }\n\n    // Function to calculate reachable rooms count from a starting room\n    auto calculate_reachable = [&](int start) {\n        vector<bool> visited(n, false);\n        unordered_set<int> keys_collected; // Keys collected during traversal\n        queue<int> q;\n\n        // Start BFS from the starting room\n        visited[start] = true;\n        q.push(start);\n        keys_collected.insert(r[start]); // Collect the key in the starting room\n\n        int reachable_count = 0;\n\n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n            ++reachable_count; // Count this room as reachable\n\n            // Traverse all neighbors\n            for (auto &[neighbor, required_key] : graph[current]) {\n                // Check if the neighbor can be traversed\n                if (!visited[neighbor] && keys_collected.count(required_key)) {\n                    visited[neighbor] = true; // Mark as visited\n                    q.push(neighbor); // Add to BFS queue\n                    keys_collected.insert(r[neighbor]); // Collect key in the neighbor room\n                }\n            }\n        }\n\n        return reachable_count;\n    };\n\n    // Step 2: Calculate p[i] for each room\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        p[i] = calculate_reachable(i);\n    }\n\n    // Step 3: Determine the minimum reachable count\n    int min_reachable = *min_element(p.begin(), p.end());\n\n    // Step 4: Construct the result array\n    vector<int> result(n, 0);\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == min_reachable) {\n            result[i] = 1;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 18:07:13",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/E",
    "title": "E. Simurgh",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "E",
    "submission_id": "314855952",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n// Helper function to construct a spanning tree using BFS/DFS\nvector<int> construct_spanning_tree(int n, const vector<int>& u, const vector<int>& v) {\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < u.size(); ++i) {\n        adj[u[i]].push_back(i);\n        adj[v[i]].push_back(i);\n    }\n\n    vector<int> visited(n, 0), spanning_tree;\n    queue<int> q;\n    visited[0] = 1;\n    q.push(0);\n\n    while (!q.empty() && spanning_tree.size() < n - 1) {\n        int city = q.front();\n        q.pop();\n\n        for (int road : adj[city]) {\n            int next_city = (u[road] == city) ? v[road] : u[road];\n            if (!visited[next_city]) {\n                visited[next_city] = 1;\n                q.push(next_city);\n                spanning_tree.push_back(road);\n                if (spanning_tree.size() == n - 1) break;\n            }\n        }\n    }\n\n    return spanning_tree;\n}\n\n// Main function to find royal roads\nvector<int> find_roads(int n, vector<int> u, vector<int> v) {\n    int m = u.size();\n    vector<int> all_roads(m);\n    iota(all_roads.begin(), all_roads.end(), 0); // Label roads from 0 to m-1\n\n    // Initial golden set (spanning tree)\n    vector<int> golden_set = construct_spanning_tree(n, u, v);\n\n    // Binary search for the royal roads\n    vector<int> royal_roads;\n    vector<int> remaining_roads = golden_set;\n\n    while (!remaining_roads.empty()) {\n        int mid = remaining_roads.size() / 2;\n        vector<int> left_set(remaining_roads.begin(), remaining_roads.begin() + mid);\n        vector<int> right_set(remaining_roads.begin() + mid, remaining_roads.end());\n\n        // Check left set\n        int left_count = count_common_roads(left_set);\n        if (left_count > 0) {\n            if (left_set.size() == 1) {\n                royal_roads.push_back(left_set[0]);\n            } else {\n                remaining_roads = left_set;\n                continue;\n            }\n        }\n\n        // Check right set\n        int right_count = count_common_roads(right_set);\n        if (right_count > 0) {\n            if (right_set.size() == 1) {\n                royal_roads.push_back(right_set[0]);\n            } else {\n                remaining_roads = right_set;\n                continue;\n            }\n        }\n\n        remaining_roads.clear(); // If neither set has royal roads, break\n    }\n\n    return royal_roads;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 18:07:57",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/E",
    "title": "E. Simurgh",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "E",
    "submission_id": "314988648",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\n// The function to implement\nvector<int> find_roads(int n, vector<int> u, vector<int> v) {\n    // Number of edges\n    int m = u.size();\n\n    // Result array to store the royal roads\n    vector<int> royal_roads;\n\n    // Helper function to construct a golden set\n    auto build_golden_set = [&](const vector<int>& edges) -> vector<int> {\n        vector<int> parent(n);\n        iota(parent.begin(), parent.end(), 0); // Disjoint-set initialization\n\n        // Find operation for disjoint set\n        auto find = [&](int x) {\n            while (x != parent[x]) x = parent[x];\n            return x;\n        };\n\n        // Union operation for disjoint set\n        auto unite = [&](int x, int y) {\n            x = find(x);\n            y = find(y);\n            if (x != y) parent[x] = y;\n        };\n\n        vector<int> golden_set;\n        for (int edge : edges) {\n            int city1 = u[edge];\n            int city2 = v[edge];\n            if (find(city1) != find(city2)) {\n                golden_set.push_back(edge);\n                unite(city1, city2);\n                if (golden_set.size() == n - 1) break; // Stop once we have n-1 edges\n            }\n        }\n        return golden_set;\n    };\n\n    // Binary search to determine the royal roads\n    vector<int> all_edges(m);\n    iota(all_edges.begin(), all_edges.end(), 0); // Initialize with all edge indices\n\n    for (int i = 0; i < m; ++i) {\n        // Exclude the i-th edge and construct a golden set\n        vector<int> edges = all_edges;\n        edges.erase(edges.begin() + i); // Remove the current edge\n\n        // Build a golden set without the i-th edge\n        vector<int> golden_set = build_golden_set(edges);\n\n        // Query the golden set\n        int count = count_common_roads(golden_set);\n\n        // If count is less than n-1, the i-th edge must be a royal road\n        if (count < n - 1) {\n            royal_roads.push_back(all_edges[i]);\n        }\n    }\n\n    return royal_roads;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 18:08:35",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/E",
    "title": "E. Simurgh",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "E",
    "submission_id": "314988700",
    "code_index": 2,
    "code": "#include <vector>\n#include <algorithm>\n#include <numeric>\n\n// Your code will be placed here\nstd::vector<int> find_roads(int n, std::vector<int> u, std::vector<int> v) {\n    int m = u.size(); // Number of roads\n    std::vector<int> allRoads(m);\n    std::iota(allRoads.begin(), allRoads.end(), 0); // Initialize road labels\n\n    // Helper function to construct a spanning tree (golden set)\n    auto construct_spanning_tree = [&]() -> std::vector<int> {\n        std::vector<int> tree;\n        std::vector<int> parent(n);\n        std::iota(parent.begin(), parent.end(), 0); // Disjoint set union-find\n\n        auto find = [&](int x) -> int {\n            if (parent[x] != x) parent[x] = find(parent[x]);\n            return parent[x];\n        };\n\n        auto union_sets = [&](int x, int y) -> bool {\n            int px = find(x), py = find(y);\n            if (px != py) {\n                parent[px] = py;\n                return true;\n            }\n            return false;\n        };\n\n        for (int i = 0; i < m; ++i) {\n            if (union_sets(u[i], v[i])) {\n                tree.push_back(i);\n                if (tree.size() == n - 1) break; // Stop when spanning tree is complete\n            }\n        }\n        return tree;\n    };\n\n    // Start with an initial golden set\n    std::vector<int> currentGoldenSet = construct_spanning_tree();\n\n    // Binary search to identify royal roads\n    std::vector<int> royalRoads;\n    for (int road : currentGoldenSet) {\n        // Remove the current road and test if it's royal\n        std::vector<int> testSet = currentGoldenSet;\n        testSet.erase(std::remove(testSet.begin(), testSet.end(), road), testSet.end());\n\n        // Add one road at a time from allRoads to maintain a golden set\n        for (int candidate : allRoads) {\n            if (std::find(testSet.begin(), testSet.end(), candidate) == testSet.end()) {\n                testSet.push_back(candidate);\n                break;\n            }\n        }\n\n        // Query Simurgh\n        int count = count_common_roads(testSet);\n        if (count == n - 1) {\n            royalRoads.push_back(road);\n        }\n\n        if (royalRoads.size() == n - 1) break; // Stop when all royal roads are found\n    }\n\n    return royalRoads;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 18:09:17",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/E",
    "title": "E. Simurgh",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "E",
    "submission_id": "314988766",
    "code_index": 3,
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\n// Grader function (provided by the system)\nextern int count_common_roads(vector<int> r);\n\n// Helper function to build and return a Minimum Spanning Tree (MST)\nvector<int> build_mst(int n, const vector<int>& u, const vector<int>& v) {\n    int m = u.size();\n    vector<pair<int, int>> edges; // Pair of (road index, road weight)\n    for (int i = 0; i < m; ++i) {\n        edges.emplace_back(i, 1); // Use weight 1 for all edges (arbitrary, as weights are not given)\n    }\n    \n    // Sort edges by weight (all weights are the same here, so order doesn't matter)\n    sort(edges.begin(), edges.end(), [](auto& a, auto& b) {\n        return a.second < b.second;\n    });\n\n    // Union-Find (Disjoint Set Union) for Kruskal's MST\n    vector<int> parent(n), rank(n, 0);\n    iota(parent.begin(), parent.end(), 0); // Initialize parent array\n\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            if (rank[x] < rank[y]) swap(x, y);\n            parent[y] = x;\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n    };\n\n    // Build the MST\n    vector<int> mst;\n    for (auto& edge : edges) {\n        int idx = edge.first;\n        if (find(u[idx]) != find(v[idx])) {\n            mst.push_back(idx);\n            unite(u[idx], v[idx]);\n            if (mst.size() == n - 1) break; // Stop when we have n-1 edges\n        }\n    }\n\n    return mst;\n}\n\n// Main function to find the royal roads\nvector<int> find_roads(int n, vector<int> u, vector<int> v) {\n    int m = u.size();\n    \n    // Step 1: Build an initial MST\n    vector<int> mst = build_mst(n, u, v);\n\n    // Step 2: Use binary search to identify royal roads\n    vector<int> royal_roads; // To store the royal roads\n    vector<bool> is_royal(m, false); // To track which roads are royal\n    for (int road : mst) is_royal[road] = true; // Initially mark MST edges as potential royal roads\n\n    for (int i = 0; i < mst.size(); ++i) {\n        int road_to_test = mst[i];\n        \n        // Remove the current road from the MST\n        vector<int> test_set = mst;\n        test_set.erase(test_set.begin() + i);\n\n        // Try replacing it with any other edge not currently in the MST\n        for (int j = 0; j < m; ++j) {\n            if (!is_royal[j]) {\n                test_set.push_back(j); // Add the new edge\n                if (test_set.size() == n - 1) {\n                    // Query Simurgh\n                    int common_count = count_common_roads(test_set);\n                    if (common_count > royal_roads.size()) {\n                        // This means the road `j` is royal\n                        royal_roads.push_back(j);\n                        is_royal[j] = true;\n                        break;\n                    }\n                }\n                test_set.pop_back(); // Remove the edge after testing\n            }\n        }\n    }\n\n    return royal_roads;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 18:10:01",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/E",
    "title": "E. Simurgh",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "E",
    "submission_id": "314988766",
    "code_index": 4,
    "code": "#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <unordered_map>\nusing namespace std;\n\n// Helper function to determine if a set of roads forms a spanning tree\nbool is_spanning_tree(int n, const vector<int>& roads, const vector<int>& u, const vector<int>& v) {\n    vector<int> parent(n);\n    iota(parent.begin(), parent.end(), 0); // Initialize each node's parent to itself\n\n    // Find function for union-find\n    function<int(int)> find = [&](int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    // Union function for union-find\n    auto unite = [&](int x, int y) {\n        int rootX = find(x), rootY = find(y);\n        if (rootX != rootY) parent[rootX] = rootY;\n    };\n\n    for (int road : roads) {\n        unite(u[road], v[road]);\n    }\n\n    // Check if all nodes are connected\n    int root = find(0);\n    for (int i = 1; i < n; ++i) {\n        if (find(i) != root) return false;\n    }\n    return true;\n}\n\n// Main function to find royal roads\nvector<int> find_roads(int n, vector<int> u, vector<int> v) {\n    int m = u.size();\n    vector<int> allRoads(m);\n    iota(allRoads.begin(), allRoads.end(), 0); // Initialize road labels [0, 1, ..., m-1]\n\n    // Function to query the grader\n    auto count_common_roads = [](const vector<int>& r) -> int {\n        // This function is implemented by the grader\n        return 0; // Placeholder\n    };\n\n    // Binary search-like approach to identify royal roads\n    vector<int> royalRoads;\n    set<int> candidateRoads(allRoads.begin(), allRoads.end());\n\n    while (royalRoads.size() < n - 1) {\n        vector<int> goldenSet;\n\n        // Select `n - 1` roads from the candidates to form a golden set\n        for (int road : candidateRoads) {\n            goldenSet.push_back(road);\n            if (goldenSet.size() == n - 1) break;\n        }\n\n        // Query the grader\n        int count = count_common_roads(goldenSet);\n\n        if (count == goldenSet.size()) {\n            // All roads in the golden set are royal roads\n            royalRoads.insert(royalRoads.end(), goldenSet.begin(), goldenSet.end());\n            break;\n        }\n\n        // Narrow down the candidates using binary search\n        vector<int> left, right;\n        int mid = goldenSet.size() / 2;\n        for (int i = 0; i < goldenSet.size(); ++i) {\n            if (i < mid) left.push_back(goldenSet[i]);\n            else right.push_back(goldenSet[i]);\n        }\n\n        // Query left half\n        int leftCount = count_common_roads(left);\n        if (leftCount > 0) {\n            candidateRoads.clear();\n            candidateRoads.insert(left.begin(), left.end());\n        } else {\n            candidateRoads.clear();\n            candidateRoads.insert(right.begin(), right.end());\n        }\n    }\n\n    return royalRoads;\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 18:11:00",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/A",
    "title": "A. Nile",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "A",
    "submission_id": "314860478",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\n// Union-Find Data Structure\nclass UnionFind {\n    vector<int> parent, rank;\n    vector<long long> componentCost;\n\npublic:\n    UnionFind(int n, const vector<int>& B) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        componentCost.resize(n);\n        iota(parent.begin(), parent.end(), 0); // Initialize parent[i] = i\n        for (int i = 0; i < n; ++i) {\n            componentCost[i] = B[i]; // Each component initially has cost B[i]\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n                componentCost[rootX] += componentCost[rootY];\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n                componentCost[rootY] += componentCost[rootX];\n            } else {\n                parent[rootY] = rootX;\n                componentCost[rootX] += componentCost[rootY];\n                ++rank[rootX];\n            }\n        }\n    }\n\n    long long getComponentCost(int x) {\n        return componentCost[find(x)];\n    }\n};\n\nvector<long long> calculate_costs(\n    vector<int> W,\n    vector<int> A,\n    vector<int> B,\n    vector<int> E\n) {\n    int N = W.size();\n    int Q = E.size();\n\n    // Prepare artifacts sorted by weight\n    vector<int> indices(N);\n    iota(indices.begin(), indices.end(), 0);\n    sort(indices.begin(), indices.end(), [&](int i, int j) {\n        return W[i] < W[j];\n    });\n\n    // Prepare queries sorted by D\n    vector<int> queryIndices(Q);\n    iota(queryIndices.begin(), queryIndices.end(), 0);\n    sort(queryIndices.begin(), queryIndices.end(), [&](int i, int j) {\n        return E[i] < E[j];\n    });\n\n    // Union-Find structure\n    UnionFind uf(N, B);\n\n    // Results for each query\n    vector<long long> results(Q);\n\n    // Initial cost: all artifacts in separate boats\n    long long currentCost = 0;\n    for (int i = 0; i < N; ++i) {\n        currentCost += A[i];\n    }\n\n    // Process each query\n    int edgeIndex = 0;\n    for (int qi : queryIndices) {\n        int D = E[qi];\n\n        // Add valid edges (pairs of artifacts) to the union-find structure\n        while (edgeIndex < N - 1) {\n            int i = indices[edgeIndex];\n            int j = indices[edgeIndex + 1];\n            if (abs(W[j] - W[i]) > D) break;\n\n            // Check if uniting these reduces the cost\n            if (uf.find(i) != uf.find(j)) {\n                long long costBefore = uf.getComponentCost(i) + uf.getComponentCost(j);\n                uf.unite(i, j);\n                long long costAfter = uf.getComponentCost(i);\n                currentCost += (costAfter - costBefore);\n            }\n            ++edgeIndex;\n        }\n\n        // Store the result for this query\n        results[qi] = currentCost;\n    }\n\n    return results;\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 18:11:39",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/A",
    "title": "A. Nile",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "A",
    "submission_id": "314988990",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent, rank, costA, costB;\n    UnionFind(int n, const vector<int>& A, const vector<int>& B) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        costA = A;\n        costB = B;\n        iota(parent.begin(), parent.end(), 0); // Initialize parent to itself\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            // Merge the costs for the newly formed component\n            costA[rootX] = costA[rootX] + costA[rootY];\n            costB[rootX] = costB[rootX] + costB[rootY];\n        }\n    }\n\n    long long getMinCost() {\n        long long totalCost = 0;\n        for (int i = 0; i < parent.size(); i++) {\n            if (parent[i] == i) { // Only consider root nodes\n                totalCost += min(costA[i], costB[i]);\n            }\n        }\n        return totalCost;\n    }\n};\n\nvector<long long> calculate_costs(vector<int> W, vector<int> A, vector<int> B, vector<int> E) {\n    int N = W.size();\n    int Q = E.size();\n\n    // Step 1: Sort artifacts by weight\n    vector<int> indices(N);\n    iota(indices.begin(), indices.end(), 0);\n    sort(indices.begin(), indices.end(), [&](int i, int j) {\n        return W[i] < W[j];\n    });\n\n    // Step 2: Sort queries by D\n    vector<int> queryIndices(Q);\n    iota(queryIndices.begin(), queryIndices.end(), 0);\n    sort(queryIndices.begin(), queryIndices.end(), [&](int i, int j) {\n        return E[i] < E[j];\n    });\n\n    // Step 3: Process queries with union-find structure\n    vector<long long> result(Q);\n    UnionFind uf(N, A, B);\n    vector<pair<int, int>> edges;\n    for (int i = 0; i < N - 1; i++) {\n        int u = indices[i], v = indices[i + 1];\n        edges.emplace_back(abs(W[u] - W[v]), i);\n    }\n    sort(edges.begin(), edges.end());\n\n    int edgeIndex = 0;\n    for (int q : queryIndices) {\n        int D = E[q];\n        // Add all edges with weight difference <= D\n        while (edgeIndex < edges.size() && edges[edgeIndex].first <= D) {\n            int i = edges[edgeIndex].second;\n            uf.unite(indices[i], indices[i + 1]);\n            edgeIndex++;\n        }\n        // Compute minimum cost for this query\n        result[q] = uf.getMinCost();\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 18:12:21",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/A",
    "title": "A. Nile",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "A",
    "submission_id": "314989094",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\nusing namespace std;\n\n// Union-Find (Disjoint Set Union) implementation\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n\n    UnionFind(int n) : parent(n), rank(n, 0) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nvector<long long> calculate_costs(\n    vector<int> W, \n    vector<int> A, \n    vector<int> B, \n    vector<int> E\n) {\n    int N = W.size();\n    int Q = E.size();\n    \n    // Step 1: Sort artifacts by weight\n    vector<int> indices(N);\n    iota(indices.begin(), indices.end(), 0);\n    sort(indices.begin(), indices.end(), [&](int i, int j) {\n        return W[i] < W[j];\n    });\n\n    // Step 2: Precompute all pairs that can be grouped based on weight difference\n    vector<pair<int, pair<int, int>>> edges; // {weight difference, {artifact1, artifact2}}\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            int diff = W[indices[j]] - W[indices[i]];\n            if (diff > 1e9) break; // No need to check further\n            edges.push_back({diff, {indices[i], indices[j]}});\n        }\n    }\n    sort(edges.begin(), edges.end());\n\n    // Step 3: Process queries\n    vector<long long> results(Q);\n    vector<pair<int, int>> sorted_queries(Q); // {D, query_index}\n    for (int i = 0; i < Q; ++i) {\n        sorted_queries[i] = {E[i], i};\n    }\n    sort(sorted_queries.begin(), sorted_queries.end());\n\n    // Step 4: Union-Find to group artifacts and calculate costs\n    UnionFind uf(N);\n    vector<bool> inGroup(N, false);\n    long long currentCost = 0;\n    for (int i = 0; i < N; ++i) {\n        currentCost += A[i];\n    }\n\n    int edgeIndex = 0;\n    for (auto [D, queryIndex] : sorted_queries) {\n        // Add all edges with weight difference <= D\n        while (edgeIndex < edges.size() && edges[edgeIndex].first <= D) {\n            int u = edges[edgeIndex].second.first;\n            int v = edges[edgeIndex].second.second;\n            edgeIndex++;\n\n            int rootU = uf.find(u);\n            int rootV = uf.find(v);\n            if (rootU != rootV) {\n                uf.unite(u, v);\n                currentCost -= A[u] + A[v];\n                currentCost += B[u] + B[v];\n            }\n        }\n        results[queryIndex] = currentCost;\n    }\n\n    return results;\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 18:13:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/A",
    "title": "A. Nile",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "A",
    "submission_id": "314989163",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n#include <set>\nusing namespace std;\n\n// Union-Find (Disjoint Set) structure for efficient grouping\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n    UnionFind(int n) : parent(n), rank(n, 0) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nvector<long long> calculate_costs(\n    vector<int> W, \n    vector<int> A, \n    vector<int> B, \n    vector<int> E\n) {\n    int N = W.size();\n    int Q = E.size();\n    \n    // Sort artifacts by weight, keeping original indices\n    vector<int> indices(N);\n    iota(indices.begin(), indices.end(), 0);\n    sort(indices.begin(), indices.end(), [&](int i, int j) {\n        return W[i] < W[j];\n    });\n    \n    // Prepare the results\n    vector<long long> results(Q);\n    \n    // Process each query\n    for (int q = 0; q < Q; q++) {\n        int D = E[q];\n        \n        // Union-Find structure for grouping\n        UnionFind uf(N);\n        \n        // Sliding window to find all valid pairs\n        set<int> active;\n        for (int i = 0; i < N; i++) {\n            int current = indices[i];\n            \n            // Remove artifacts that are out of range\n            auto it = active.begin();\n            while (it != active.end() && W[current] - W[*it] > D) {\n                it = active.erase(it);\n            }\n            \n            // Attempt to pair with all valid artifacts in the active set\n            for (int j : active) {\n                uf.unite(current, j);\n            }\n            \n            // Add the current artifact to the active set\n            active.insert(current);\n        }\n        \n        // Calculate the minimum cost\n        vector<bool> visited(N, false);\n        long long totalCost = 0;\n        for (int i = 0; i < N; i++) {\n            int root = uf.find(i);\n            if (!visited[root]) {\n                visited[root] = true;\n                vector<int> group;\n                for (int j = 0; j < N; j++) {\n                    if (uf.find(j) == root) {\n                        group.push_back(j);\n                    }\n                }\n                \n                // Compute the cost for this group\n                if (group.size() == 1) {\n                    totalCost += A[group[0]];\n                } else {\n                    for (int artifact : group) {\n                        totalCost += B[artifact];\n                    }\n                }\n            }\n        }\n        \n        // Store the result for this query\n        results[q] = totalCost;\n    }\n    \n    return results;\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 18:13:46",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/A",
    "title": "A. Nile",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "A",
    "submission_id": "314989239",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\n// Union-Find (Disjoint Set Union) helper structure\nclass UnionFind {\nprivate:\n    vector<int> parent, rank;\npublic:\n    UnionFind(int n) : parent(n), rank(n, 0) {\n        iota(parent.begin(), parent.end(), 0);\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]); // Path compression\n        }\n        return parent[x];\n    }\n    \n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            // Union by rank\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nvector<long long> calculate_costs(\n    vector<int> W, \n    vector<int> A, \n    vector<int> B, \n    vector<int> E\n) {\n    int N = W.size();\n    int Q = E.size();\n    \n    // Step 1: Sort artifacts by weight, keeping track of original indices\n    vector<int> indices(N);\n    iota(indices.begin(), indices.end(), 0);\n    sort(indices.begin(), indices.end(), [&](int i, int j) {\n        return W[i] < W[j];\n    });\n    \n    // Step 2: Create all possible valid edges based on weight difference\n    vector<tuple<int, int, int>> edges; // (weight_diff, artifact1, artifact2)\n    for (int i = 0; i < N; ++i) {\n        for (int j = i + 1; j < N; ++j) {\n            int diff = abs(W[indices[i]] - W[indices[j]]);\n            if (diff > 1e9) break; // Stop if the weight difference exceeds the maximum possible D\n            edges.emplace_back(diff, indices[i], indices[j]);\n        }\n    }\n    \n    // Sort edges by weight difference\n    sort(edges.begin(), edges.end());\n    \n    // Step 3: Process queries using union-find\n    vector<long long> results(Q);\n    vector<int> sorted_queries(Q);\n    iota(sorted_queries.begin(), sorted_queries.end(), 0);\n    sort(sorted_queries.begin(), sorted_queries.end(), [&](int i, int j) {\n        return E[i] < E[j];\n    });\n    \n    UnionFind uf(N);\n    vector<bool> in_set(N, false);\n    long long current_cost = 0;\n    for (int i = 0; i < N; ++i) {\n        current_cost += A[i]; // Initially, all artifacts are in separate boats\n    }\n    \n    int edge_index = 0;\n    for (int query_index : sorted_queries) {\n        int D = E[query_index];\n        \n        // Add all valid edges with weight difference <= D\n        while (edge_index < edges.size() && get<0>(edges[edge_index]) <= D) {\n            int u = get<1>(edges[edge_index]);\n            int v = get<2>(edges[edge_index]);\n            edge_index++;\n            \n            int rootU = uf.find(u);\n            int rootV = uf.find(v);\n            if (rootU != rootV) {\n                // Calculate cost reduction from merging these two sets\n                long long cost_before = A[rootU] + A[rootV];\n                long long cost_after = B[rootU] + B[rootV];\n                if (cost_after < cost_before) {\n                    current_cost -= (cost_before - cost_after);\n                    uf.unite(u, v);\n                }\n            }\n        }\n        \n        results[query_index] = current_cost;\n    }\n    \n    return results;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 18:14:39",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/B",
    "title": "B. Longest Trip",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "B",
    "submission_id": "314989331",
    "code_index": 0,
    "code": "#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n// Declaration of the are_connected function provided by the grader\nbool are_connected(vector<int> A, vector<int> B);\n\n// Helper function to find neighbors of a node\nvector<int> find_neighbors(int node, int N) {\n    vector<int> neighbors;\n    for (int i = 0; i < N; ++i) {\n        if (i != node) {\n            if (are_connected({node}, {i})) {\n                neighbors.push_back(i);\n            }\n        }\n    }\n    return neighbors;\n}\n\n// Function to find the longest trip\nvector<int> longest_trip(int N, int D) {\n    vector<bool> visited(N, false);\n    vector<int> longest_path;\n\n    for (int start = 0; start < N; ++start) {\n        if (visited[start]) continue;\n\n        // Perform BFS/DFS from the current node to find the longest path\n        vector<int> current_path;\n        queue<int> q;\n        q.push(start);\n        visited[start] = true;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            current_path.push_back(node);\n\n            // Find neighbors of the current node\n            vector<int> neighbors = find_neighbors(node, N);\n            for (int neighbor : neighbors) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        // Update the longest path if the current one is longer\n        if (current_path.size() > longest_path.size()) {\n            longest_path = current_path;\n        }\n    }\n\n    return longest_path;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 18:15:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/B",
    "title": "B. Longest Trip",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "B",
    "submission_id": "314989400",
    "code_index": 1,
    "code": "#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Your code will be placed here\nvector<int> longest_trip(int N, int D) {\n    // Helper function to query connectivity\n    auto query = [&](const vector<int>& A, const vector<int>& B) -> bool {\n        return are_connected(A, B);\n    };\n\n    // Initialize the trip with a single node\n    vector<int> trip = {0};  // Start with node 0\n    vector<bool> visited(N, false);\n    visited[0] = true;\n\n    // Function to find the next connected node to extend the trip\n    auto find_next = [&](int current) -> int {\n        for (int i = 0; i < N; ++i) {\n            if (!visited[i]) {\n                if (query({current}, {i})) {\n                    return i;\n                }\n            }\n        }\n        return -1;  // No unvisited connected node found\n    };\n\n    // Extend the trip forward\n    while (true) {\n        int next = find_next(trip.back());\n        if (next == -1) break;  // No more nodes to extend\n        trip.push_back(next);\n        visited[next] = true;\n    }\n\n    // Extend the trip backward\n    while (true) {\n        int next = find_next(trip.front());\n        if (next == -1) break;  // No more nodes to extend\n        trip.insert(trip.begin(), next);\n        visited[next] = true;\n    }\n\n    return trip;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 18:16:03",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/B",
    "title": "B. Longest Trip",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "B",
    "submission_id": "314989481",
    "code_index": 2,
    "code": "#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\n// Your code will be placed here\nvector<int> longest_trip(int N, int D) {\n    // Helper function to find neighbors of a given node\n    auto find_neighbors = [&](int node, const vector<int>& visited) -> vector<int> {\n        vector<int> A = {node};\n        vector<int> B;\n        for (int i = 0; i < N; i++) {\n            if (find(visited.begin(), visited.end(), i) == visited.end()) {\n                B.push_back(i);\n            }\n        }\n        if (B.empty()) return {};\n        if (are_connected(A, B)) {\n            vector<int> neighbors;\n            for (int x : B) {\n                if (are_connected({x}, {node})) {\n                    neighbors.push_back(x);\n                }\n            }\n            return neighbors;\n        }\n        return {};\n    };\n\n    // Initialize the path with one starting node\n    vector<int> path = {0};\n    unordered_set<int> visited = {0};\n\n    // Extend the path forward\n    while (true) {\n        vector<int> neighbors = find_neighbors(path.back(), path);\n        if (neighbors.empty()) break;\n        path.push_back(neighbors[0]);\n        visited.insert(neighbors[0]);\n    }\n\n    // Extend the path backward\n    reverse(path.begin(), path.end());\n    while (true) {\n        vector<int> neighbors = find_neighbors(path.back(), path);\n        if (neighbors.empty()) break;\n        path.push_back(neighbors[0]);\n        visited.insert(neighbors[0]);\n    }\n\n    return path;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 18:16:47",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/B",
    "title": "B. Longest Trip",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "B",
    "submission_id": "314989556",
    "code_index": 3,
    "code": "#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nbool are_connected(vector<int> A, vector<int> B);\n\nvector<int> bfs_longest_trip(int start, int N, const vector<vector<int>>& adjacency_list) {\n    vector<int> visited(N, 0);\n    vector<int> parent(N, -1);\n    queue<int> q;\n\n    q.push(start);\n    visited[start] = 1;\n\n    int last_node = start;\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n        last_node = current;\n\n        for (int neighbor : adjacency_list[current]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = 1;\n                parent[neighbor] = current;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    // Trace back the longest path from the last node in BFS\n    vector<int> path;\n    for (int node = last_node; node != -1; node = parent[node]) {\n        path.push_back(node);\n    }\n    reverse(path.begin(), path.end());\n    return path;\n}\n\nvector<int> longest_trip(int N, int D) {\n    // To store the adjacency list of the graph\n    vector<vector<int>> adjacency_list(N);\n\n    // Discover the graph by querying are_connected\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (are_connected({i}, {j})) {\n                adjacency_list[i].push_back(j);\n                adjacency_list[j].push_back(i);\n            }\n        }\n    }\n\n    // Find the longest trip using BFS\n    vector<int> longest_path;\n    for (int start = 0; start < N; start++) {\n        vector<int> path = bfs_longest_trip(start, N, adjacency_list);\n        if (path.size() > longest_path.size()) {\n            longest_path = path;\n        }\n    }\n\n    return longest_path;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 18:17:31",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/B",
    "title": "B. Longest Trip",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "B",
    "submission_id": "314989556",
    "code_index": 4,
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// Your code will be placed here\nvector<int> longest_trip(int N, int D) {\n    // Helper function to find neighbors of a given node\n    auto find_neighbors = [&](int node, const vector<int>& candidates) -> vector<int> {\n        vector<int> result;\n        for (int candidate : candidates) {\n            if (are_connected({node}, {candidate})) {\n                result.push_back(candidate);\n            }\n        }\n        return result;\n    };\n\n    // Build the adjacency list using are_connected queries\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < N; i++) {\n        vector<int> candidates;\n        for (int j = i + 1; j < N; j++) {\n            candidates.push_back(j);\n        }\n        vector<int> neighbors = find_neighbors(i, candidates);\n        for (int neighbor : neighbors) {\n            adj[i].push_back(neighbor);\n            adj[neighbor].push_back(i);\n        }\n    }\n\n    // Helper function to find the longest path using BFS\n    auto bfs_longest_path = [&](int start) -> vector<int> {\n        vector<int> dist(N, -1);\n        vector<int> parent(N, -1);\n        queue<int> q;\n\n        dist[start] = 0;\n        q.push(start);\n\n        int furthest_node = start;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            for (int neighbor : adj[node]) {\n                if (dist[neighbor] == -1) {\n                    dist[neighbor] = dist[node] + 1;\n                    parent[neighbor] = node;\n                    q.push(neighbor);\n                    if (dist[neighbor] > dist[furthest_node]) {\n                        furthest_node = neighbor;\n                    }\n                }\n            }\n        }\n\n        // Trace back the longest path from the furthest node\n        vector<int> path;\n        for (int node = furthest_node; node != -1; node = parent[node]) {\n            path.push_back(node);\n        }\n        reverse(path.begin(), path.end());\n        return path;\n    };\n\n    // Find the longest path starting from any node\n    vector<int> longest_path = bfs_longest_path(0);\n\n    // Return the longest path found\n    return longest_path;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 18:18:28",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/B",
    "title": "B. Seats",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "B",
    "submission_id": "314989729",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\n\nint H, W;\nvector<int> R, C;\nvector<int> position; // Maps contestant to their position in the seating chart\nvector<int> seat_to_contestant; // Maps seat (flattened index) to contestant\n\n// Helper function to convert (r, c) to a 1D index\ninline int flatten(int r, int c) {\n    return r * W + c;\n}\n\n// Helper function to convert a 1D index to (r, c)\ninline pair<int, int> unflatten(int index) {\n    return {index / W, index % W};\n}\n\n// Helper function to check if a rectangular set is beautiful\nbool is_beautiful(int r1, int r2, int c1, int c2) {\n    int expected_min = r1 * W + c1; // Minimum contestant number\n    int expected_max = r2 * W + c2; // Maximum contestant number\n    int k = (r2 - r1 + 1) * (c2 - c1 + 1);\n\n    // Check if the range [expected_min, expected_max] matches the contestant numbers\n    set<int> contestants;\n    for (int r = r1; r <= r2; ++r) {\n        for (int c = c1; c <= c2; ++c) {\n            int seat_index = flatten(r, c);\n            contestants.insert(seat_to_contestant[seat_index]);\n        }\n    }\n\n    if (contestants.size() != k) return false;\n\n    int current = expected_min;\n    for (int contestant : contestants) {\n        if (contestant != current) return false;\n        ++current;\n    }\n\n    return true;\n}\n\n// Function to compute the beauty of the current seating chart\nint compute_beauty() {\n    int beauty = 0;\n\n    // Iterate over all possible rectangular sets\n    for (int r1 = 0; r1 < H; ++r1) {\n        for (int r2 = r1; r2 < H; ++r2) {\n            for (int c1 = 0; c1 < W; ++c1) {\n                for (int c2 = c1; c2 < W; ++c2) {\n                    if (is_beautiful(r1, r2, c1, c2)) {\n                        ++beauty;\n                    }\n                }\n            }\n        }\n    }\n\n    return beauty;\n}\n\nvoid give_initial_chart(int h, int w, vector<int> r, vector<int> c) {\n    H = h;\n    W = w;\n    R = r;\n    C = c;\n\n    int n = H * W;\n    position.resize(n);\n    seat_to_contestant.resize(n);\n\n    // Initialize the seating chart\n    for (int i = 0; i < n; ++i) {\n        int seat_index = flatten(R[i], C[i]);\n        position[i] = seat_index;\n        seat_to_contestant[seat_index] = i;\n    }\n}\n\nint swap_seats(int a, int b) {\n    // Swap the contestants in the seating chart\n    int seat_a = position[a];\n    int seat_b = position[b];\n\n    // Update the mapping\n    seat_to_contestant[seat_a] = b;\n    seat_to_contestant[seat_b] = a;\n    position[a] = seat_b;\n    position[b] = seat_a;\n\n    // Recompute and return the beauty of the seating chart\n    return compute_beauty();\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 18:19:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/B",
    "title": "B. Seats",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "B",
    "submission_id": "314989803",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <set>\n\nusing namespace std;\n\n// Global variables\nint H, W;\nvector<int> R, C; // Contestant-to-seat mapping\nvector<int> seat_contestant; // Reverse mapping: seat to contestant\nset<int> active_contestants; // To track active contestants in sorted order\n\n// Helper function to compute beauty\nint compute_beauty() {\n    int beauty = 0;\n\n    // Iterate through all active contestants in sorted order\n    vector<pair<int, int>> positions;\n    for (int contestant : active_contestants) {\n        positions.emplace_back(R[contestant], C[contestant]);\n    }\n    sort(positions.begin(), positions.end());\n\n    // Use a sweep-line approach to determine beautiful rectangles\n    int n = positions.size();\n    for (int i = 0; i < n; ++i) {\n        int min_col = positions[i].second, max_col = positions[i].second;\n        for (int j = i; j < n; ++j) {\n            min_col = min(min_col, positions[j].second);\n            max_col = max(max_col, positions[j].second);\n            if (j - i + 1 == max_col - min_col + 1) {\n                beauty++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return beauty;\n}\n\n// Function to initialize the chart\nvoid give_initial_chart(int h, int w, vector<int> r, vector<int> c) {\n    H = h;\n    W = w;\n    R = r;\n    C = c;\n\n    int n = H * W;\n    seat_contestant.resize(n);\n    for (int i = 0; i < n; ++i) {\n        seat_contestant[R[i] * W + C[i]] = i;\n        active_contestants.insert(i);\n    }\n}\n\n// Function to handle seat swaps\nint swap_seats(int a, int b) {\n    // Swap the positions of contestants a and b\n    swap(R[a], R[b]);\n    swap(C[a], C[b]);\n\n    // Recompute beauty\n    return compute_beauty();\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 18:19:59",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/B",
    "title": "B. Seats",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "B",
    "submission_id": "314989803",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint H, W;\nvector<int> position; // position[i] = seat index (row * W + col) of contestant i\nvector<int> contestant; // contestant[seat index] = contestant at that seat\nvector<set<int>> rows; // rows[r] = set of contestant indices in row r\nvector<set<int>> cols; // cols[c] = set of contestant indices in column c\n\n// Helper function to check if a set of contestants is beautiful\nbool is_beautiful(const set<int>& s) {\n    if (s.empty()) return true;\n    auto it = s.begin();\n    int first = *it, last = *it, count = 1;\n    ++it;\n    for (; it != s.end(); ++it) {\n        if (*it != last + 1) return false;\n        last = *it;\n        ++count;\n    }\n    return last - first + 1 == count;\n}\n\n// Helper function to calculate beauty of the chart\nint calculate_beauty() {\n    int beauty = 0;\n    for (const auto& row : rows) {\n        beauty += is_beautiful(row);\n    }\n    for (const auto& col : cols) {\n        beauty += is_beautiful(col);\n    }\n    return beauty;\n}\n\nvoid give_initial_chart(int h, int w, vector<int> R, vector<int> C) {\n    H = h;\n    W = w;\n    int n = H * W;\n    position.resize(n);\n    contestant.resize(n);\n    rows.resize(H);\n    cols.resize(W);\n\n    for (int i = 0; i < n; ++i) {\n        int seat_index = R[i] * W + C[i];\n        position[i] = seat_index;\n        contestant[seat_index] = i;\n        rows[R[i]].insert(i);\n        cols[C[i]].insert(i);\n    }\n}\n\nint swap_seats(int a, int b) {\n    // Get the seat indices\n    int seat_a = position[a];\n    int seat_b = position[b];\n\n    // Get the row and column of each seat\n    int row_a = seat_a / W, col_a = seat_a % W;\n    int row_b = seat_b / W, col_b = seat_b % W;\n\n    // Remove a and b from their current rows and columns\n    rows[row_a].erase(a);\n    cols[col_a].erase(a);\n    rows[row_b].erase(b);\n    cols[col_b].erase(b);\n\n    // Swap the positions\n    swap(position[a], position[b]);\n    swap(contestant[seat_a], contestant[seat_b]);\n\n    // Add a and b to their new rows and columns\n    rows[row_a].insert(b);\n    cols[col_a].insert(b);\n    rows[row_b].insert(a);\n    cols[col_b].insert(a);\n\n    // Recalculate beauty\n    return calculate_beauty();\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 18:20:41",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/B",
    "title": "B. Seats",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "B",
    "submission_id": "314989971",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nint H, W;\nvector<pair<int, int>> pos; // Position of each contestant\nvector<vector<int>> grid;  // Grid mapping (row, col) to contestant\nvector<int> parent, rank, size; // Union-Find data structures\n\n// Helper functions for Union-Find\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        if (rank[rootX] < rank[rootY]) {\n            swap(rootX, rootY);\n        }\n        parent[rootY] = rootX;\n        size[rootX] += size[rootY];\n        if (rank[rootX] == rank[rootY]) {\n            rank[rootX]++;\n        }\n    }\n}\n\n// Initialize the seating chart\nvoid give_initial_chart(int h, int w, vector<int> R, vector<int> C) {\n    H = h;\n    W = w;\n\n    pos.resize(H * W);\n    grid.assign(H, vector<int>(W, -1));\n    parent.resize(H * W);\n    rank.resize(H * W, 0);\n    size.resize(H * W, 1);\n\n    // Initialize positions and grid\n    for (int i = 0; i < H * W; i++) {\n        pos[i] = {R[i], C[i]};\n        grid[R[i]][C[i]] = i;\n        parent[i] = i; // Each contestant is its own parent initially\n    }\n\n    // Union-Find setup for initial chart\n    for (int r = 0; r < H; r++) {\n        for (int c = 0; c < W; c++) {\n            int contestant = grid[r][c];\n            if (r > 0 && grid[r - 1][c] != -1 && grid[r - 1][c] + 1 == contestant) {\n                unite(contestant, grid[r - 1][c]);\n            }\n            if (c > 0 && grid[r][c - 1] != -1 && grid[r][c - 1] + 1 == contestant) {\n                unite(contestant, grid[r][c - 1]);\n            }\n        }\n    }\n}\n\n// Calculate the beauty of the current chart\nint calculate_beauty() {\n    unordered_map<int, int> beautifulSets;\n    for (int i = 0; i < H * W; i++) {\n        int root = find(i);\n        if (size[root] == root + 1) { // Check if the set is beautiful\n            beautifulSets[root] = 1;\n        }\n    }\n    return beautifulSets.size();\n}\n\n// Handle a swap operation and return the new beauty\nint swap_seats(int a, int b) {\n    // Swap positions in the grid\n    auto [ra, ca] = pos[a];\n    auto [rb, cb] = pos[b];\n    grid[ra][ca] = b;\n    grid[rb][cb] = a;\n    pos[a] = {rb, cb};\n    pos[b] = {ra, ca};\n\n    // Recalculate union-find connections in the affected rows/columns\n    vector<int> affected = {a, b};\n    for (int contestant : affected) {\n        auto [r, c] = pos[contestant];\n        parent[contestant] = contestant;\n        size[contestant] = 1;\n        if (r > 0 && grid[r - 1][c] != -1 && grid[r - 1][c] + 1 == contestant) {\n            unite(contestant, grid[r - 1][c]);\n        }\n        if (r < H - 1 && grid[r + 1][c] != -1 && grid[r + 1][c] - 1 == contestant) {\n            unite(contestant, grid[r + 1][c]);\n        }\n        if (c > 0 && grid[r][c - 1] != -1 && grid[r][c - 1] + 1 == contestant) {\n            unite(contestant, grid[r][c - 1]);\n        }\n        if (c < W - 1 && grid[r][c + 1] != -1 && grid[r][c + 1] - 1 == contestant) {\n            unite(contestant, grid[r][c + 1]);\n        }\n    }\n\n    // Return the new beauty\n    return calculate_beauty();\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:21:37",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/E",
    "title": "E. Rarest Insects",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "E",
    "submission_id": "314990083",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\n\n// Provided functions by the grader\nvoid move_inside(int i);\nvoid move_outside(int i);\nint press_button();\n\nint min_cardinality(int N) {\n    // Step 1: Move all insects inside the machine one by one\n    for (int i = 0; i < N; ++i) {\n        move_inside(i);\n    }\n    \n    // Step 2: Determine the maximum frequency of any type\n    int max_frequency = press_button();\n    \n    // Step 3: Use binary search to find the minimum cardinality\n    int low = 1, high = max_frequency, result = max_frequency;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        int count = 0; // Count of types with frequency >= mid\n        \n        // Step 4: Check if there are any types with frequency >= mid\n        for (int i = 0; i < N; ++i) {\n            move_outside(i); // Remove each insect\n            if (press_button() >= mid) {\n                ++count;\n            }\n            move_inside(i); // Put the insect back\n        }\n        \n        // Step 5: Adjust binary search based on the count\n        if (count > 0) {\n            result = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    \n    return result;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:22:19",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/E",
    "title": "E. Rarest Insects",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "E",
    "submission_id": "314990083",
    "code_index": 1,
    "code": "// Your code will be placed here\n\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\n// Function prototypes provided by the problem\nvoid move_inside(int i);\nvoid move_outside(int i);\nint press_button();\n\nint min_cardinality(int N) {\n    // Step 1: Track frequency counts\n    unordered_map<int, int> frequency_count; // Map to store frequency counts of types\n    vector<int> indices_in_machine; // Track indices currently in the machine\n\n    // Step 2: Process each insect\n    for (int i = 0; i < N; ++i) {\n        // Add the current insect to the machine\n        move_inside(i);\n        indices_in_machine.push_back(i);\n\n        // Query the machine to get the current maximum frequency\n        int max_frequency = press_button();\n\n        // If the max frequency increases, it means we've added another insect of the same type\n        // Otherwise, it means a new type was added\n        if (frequency_count.find(max_frequency) == frequency_count.end()) {\n            frequency_count[max_frequency]++;\n        }\n    }\n\n    // Step 3: Find the minimum cardinality\n    int min_cardinality = N; // Initialize to a large value\n    for (const auto& pair : frequency_count) {\n        min_cardinality = min(min_cardinality, pair.second);\n    }\n\n    return min_cardinality;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:23:07",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/E",
    "title": "E. Rarest Insects",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "E",
    "submission_id": "314990146",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// Provided grader functions\nvoid move_inside(int i);\nvoid move_outside(int i);\nint press_button();\n\nint min_cardinality(int N) {\n    // Step 1: Divide insects into groups of size sqrt(N), to efficiently analyze frequency\n    int group_size = 45; // A heuristic value to balance operations\n    vector<int> frequency_count;\n    unordered_map<int, int> type_to_frequency;\n\n    for (int i = 0; i < N; i++) {\n        move_inside(i);\n        if ((i + 1) % group_size == 0 || i == N - 1) {\n            // Press the button to get the cardinality of the most frequent type in the current group\n            int max_frequency = press_button();\n            frequency_count.push_back(max_frequency);\n\n            // Clear the machine for the next group\n            for (int j = i - (i % group_size); j <= i; j++) {\n                move_outside(j);\n            }\n        }\n    }\n\n    // Step 2: Identify the rarest type across all groups\n    int rarest_cardinality = N; // Initialize with the maximum possible value\n    for (int freq : frequency_count) {\n        rarest_cardinality = min(rarest_cardinality, freq);\n    }\n\n    return rarest_cardinality;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:23:45",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/E",
    "title": "E. Rarest Insects",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "E",
    "submission_id": "314990295",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\n// Grader-provided functions (to be implemented by the system)\nvoid move_inside(int i);\nvoid move_outside(int i);\nint press_button();\n\n// Function to find the cardinality of the rarest insect type\nint min_cardinality(int N) {\n    unordered_map<int, int> frequency_map; // Maps type to its frequency\n    vector<int> inside; // List of insects currently inside the machine\n    int max_frequency = 0;\n\n    // Step 1: Sequentially analyze each insect\n    for (int i = 0; i < N; ++i) {\n        // Add the current insect to the machine\n        move_inside(i);\n        int current_frequency = press_button();\n\n        if (current_frequency > max_frequency) {\n            // If the current frequency exceeds the maximum frequency, update\n            max_frequency = current_frequency;\n        }\n\n        // Check if the current insect's type is already inside\n    }\n\n    return max_frequency;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:24:24",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/E",
    "title": "E. Rarest Insects",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "E",
    "submission_id": "314990355",
    "code_index": 4,
    "code": "#include <vector>\n#include <unordered_map>\nusing namespace std;\n\n// Provided functions to interact with the machine\nvoid move_inside(int i);\nvoid move_outside(int i);\nint press_button();\n\n// Your code will be placed here\nint min_cardinality(int N) {\n    // Step 1: Initialize variables to track frequency counts\n    unordered_map<int, int> frequency; // Map to track type frequencies\n    vector<int> inside(N, 0); // To track which insects are inside the machine\n    int rarest = N; // Start with the maximum possible cardinality\n    \n    // Step 2: Process each insect one by one\n    for (int i = 0; i < N; ++i) {\n        move_inside(i); // Move insect i inside the machine\n        int current_max = press_button(); // Get the current max frequency\n        \n        // Step 3: Determine the type of insect i\n        if (frequency.count(current_max) == 0) {\n            frequency[current_max] = 1;\n        } else {\n            frequency[current_max]++;\n        }\n        \n        // Update the rarest cardinality\n        rarest = min(rarest, frequency[current_max]);\n    }\n    \n    // Step 4: Return the rarest cardinality\n    return rarest;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 18:25:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/C",
    "title": "C. Carnival Tickets",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "C",
    "submission_id": "314990455",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\n\nusing namespace std;\n\nvoid allocate_tickets(vector<vector<int>> s);\n\nint64_t find_maximum(int k, vector<vector<int>> x) {\n    int n = x.size();    // Number of colors\n    int m = x[0].size(); // Tickets per color\n    \n    // Result allocation matrix\n    vector<vector<int>> s(n, vector<int>(m, -1));\n    \n    // Priority queue to store all tickets with their values and color indices\n    vector<pair<int, pair<int, int>>> tickets; // {value, {color, index}}\n    \n    // Collect all tickets into a single list\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            tickets.push_back({x[i][j], {i, j}});\n        }\n    }\n    \n    // Sort tickets in descending order by value\n    sort(tickets.rbegin(), tickets.rend());\n    \n    // Greedy allocation of tickets to rounds\n    vector<vector<int>> rounds(k); // Each round stores selected ticket values\n    vector<int> color_used(n, 0);  // Track how many tickets are used per color\n    \n    int round = 0;\n    for (const auto& ticket : tickets) {\n        int value = ticket.first;\n        int color = ticket.second.first;\n        int index = ticket.second.second;\n        \n        // If this color still has tickets to allocate\n        if (color_used[color] < k) {\n            s[color][index] = round; // Allocate this ticket to the current round\n            rounds[round].push_back(value);\n            color_used[color]++;\n            \n            // Move to the next round in a cyclic manner\n            round = (round + 1) % k;\n        }\n    }\n    \n    // Calculate the total maximum prize value\n    int64_t total_prize = 0;\n    for (const auto& round_values : rounds) {\n        // Sort the values in the round to find the optimal median\n        vector<int> sorted_values = round_values;\n        sort(sorted_values.begin(), sorted_values.end());\n        int median = sorted_values[sorted_values.size() / 2];\n        \n        // Calculate the sum of absolute differences for this round\n        int64_t round_prize = 0;\n        for (int value : sorted_values) {\n            round_prize += abs(value - median);\n        }\n        total_prize += round_prize;\n    }\n    \n    // Call the grader function with the allocation matrix\n    allocate_tickets(s);\n    \n    // Return the total maximum prize value\n    return total_prize;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 18:26:06",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/C",
    "title": "C. Carnival Tickets",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "C",
    "submission_id": "314990455",
    "code_index": 1,
    "code": "#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\nusing namespace std;\n\n// Function to allocate tickets to rounds\nvoid allocate_tickets(vector<vector<int>> s);\n\nint64_t find_maximum(int k, vector<vector<int>> x) {\n    int n = x.size();      // Number of colors\n    int m = x[0].size();   // Tickets per color\n\n    // Allocation matrix: initially all -1\n    vector<vector<int>> s(n, vector<int>(m, -1));\n\n    // To store the total prize value\n    int64_t total_prize = 0;\n\n    // Step 1: Greedy allocation of tickets\n    for (int i = 0; i < n; ++i) {\n        // Divide tickets of color `i` into `k` groups\n        for (int r = 0; r < k; ++r) {\n            for (int j = r * (m / k); j < (r + 1) * (m / k); ++j) {\n                s[i][j] = r;\n            }\n        }\n    }\n\n    // Step 2: Calculate the total prize value\n    // For each round, collect the selected tickets and calculate the prize value\n    for (int r = 0; r < k; ++r) {\n        vector<int> selected_tickets;\n\n        // Collect all tickets for this round\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (s[i][j] == r) {\n                    selected_tickets.push_back(x[i][j]);\n                    break;\n                }\n            }\n        }\n\n        // Sort the selected tickets to find the median\n        sort(selected_tickets.begin(), selected_tickets.end());\n\n        // Median of selected tickets\n        int median = selected_tickets[n / 2];\n\n        // Calculate the prize value for this round\n        int64_t round_prize = 0;\n        for (int val : selected_tickets) {\n            round_prize += abs(val - median);\n        }\n\n        // Add to the total prize value\n        total_prize += round_prize;\n    }\n\n    // Step 3: Output the allocation matrix and return the total prize value\n    allocate_tickets(s);\n    return total_prize;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 18:26:54",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/C",
    "title": "C. Carnival Tickets",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "C",
    "submission_id": "314990603",
    "code_index": 2,
    "code": "#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n// Function to allocate tickets to rounds and maximize the total prize value\nint64_t find_maximum(int k, vector<vector<int>> x) {\n    int n = x.size();    // Number of colors\n    int m = x[0].size(); // Number of tickets per color\n\n    // Allocation matrix: -1 means not used, otherwise it indicates the round (0-based)\n    vector<vector<int>> s(n, vector<int>(m, -1));\n\n    // Total prize value\n    int64_t total_prize = 0;\n\n    // Step 1: Allocate tickets to maximize spread\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            s[i][j] = j % k; // Distribute tickets cyclically across rounds\n        }\n    }\n\n    // Step 2: Calculate the total prize value\n    for (int r = 0; r < k; ++r) {\n        vector<int> selected_values;\n\n        // Collect all ticket values for this round\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (s[i][j] == r) {\n                    selected_values.push_back(x[i][j]);\n                }\n            }\n        }\n\n        // Sort the selected values for this round\n        sort(selected_values.begin(), selected_values.end());\n\n        // Find the median value\n        int median = selected_values[selected_values.size() / 2];\n\n        // Compute the prize value for this round\n        int64_t round_prize = 0;\n        for (int val : selected_values) {\n            round_prize += abs(val - median);\n        }\n\n        // Add to the total prize value\n        total_prize += round_prize;\n    }\n\n    // Step 3: Call the allocate_tickets function with the allocation matrix\n    allocate_tickets(s);\n\n    // Return the total prize value\n    return total_prize;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 18:27:39",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/C",
    "title": "C. Carnival Tickets",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "C",
    "submission_id": "314990682",
    "code_index": 3,
    "code": "#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <utility>\nusing namespace std;\n\n// Function to be implemented\nint64_t find_maximum(int k, vector<vector<int>> x) {\n    int n = x.size(); // Number of colors\n    int m = x[0].size(); // Number of tickets per color\n\n    // Result allocation matrix\n    vector<vector<int>> s(n, vector<int>(m, -1));\n\n    // Max-Heap to store tickets based on their values and color\n    priority_queue<pair<int, pair<int, int>>> pq;\n\n    // Push all tickets into the heap\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            pq.push({x[i][j], {i, j}});\n        }\n    }\n\n    // Round allocation counters\n    vector<int> round_count(k, 0);\n    int tickets_per_round = n; // Each round requires exactly `n` tickets\n\n    // Total prize value\n    int64_t total_prize_value = 0;\n\n    // Allocate tickets round by round\n    while (!pq.empty()) {\n        auto top = pq.top();\n        pq.pop();\n\n        int value = top.first;\n        int color = top.second.first;\n        int index = top.second.second;\n\n        // Find a round that still needs tickets\n        for (int r = 0; r < k; ++r) {\n            if (round_count[r] < tickets_per_round) {\n                // Allocate this ticket to this round\n                s[color][index] = r;\n                round_count[r]++;\n                total_prize_value += value;\n                break;\n            }\n        }\n    }\n\n    // Call the grader's function to allocate tickets\n    allocate_tickets(s);\n\n    // Return the total prize value\n    return total_prize_value;\n}"
  },
  {
    "date": "IOI 2020 day 1",
    "timestamp": "2025-04-11 18:28:28",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103780/problem/C",
    "title": "C. Carnival Tickets",
    "group_id": "32KGsXgiKA",
    "contest_id": "103780",
    "problem_index": "C",
    "submission_id": "314990761",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\nint64_t find_maximum(int k, vector<vector<int>> x) {\n    int n = x.size(); // Number of colors\n    int m = x[0].size(); // Tickets per color\n\n    // Result allocation matrix\n    vector<vector<int>> s(n, vector<int>(m, -1));\n\n    // Prepare a list of top-k values for each color\n    vector<vector<int>> top_k_values(n);\n    for (int i = 0; i < n; ++i) {\n        top_k_values[i].assign(x[i].end() - k, x[i].end());\n        reverse(top_k_values[i].begin(), top_k_values[i].end());\n    }\n\n    // Priority queue to maximize the distribution of high values\n    vector<vector<pair<int, int>>> rounds(k); // Each round contains (value, color index)\n    for (int i = 0; i < k; ++i) {\n        for (int j = 0; j < n; ++j) {\n            rounds[i].push_back({top_k_values[j][i], j});\n        }\n    }\n\n    // Sort each round in descending order by value\n    for (int i = 0; i < k; ++i) {\n        sort(rounds[i].rbegin(), rounds[i].rend());\n    }\n\n    // Allocate tickets to maximize the sum of medians\n    int64_t total_prize_value = 0;\n    vector<int> ticket_indices(n, m - k); // Start allocating from the last k tickets\n    for (int r = 0; r < k; ++r) {\n        vector<int> round_values;\n        for (auto &[value, color] : rounds[r]) {\n            round_values.push_back(value);\n            s[color][ticket_indices[color]++] = r;\n        }\n\n        // Calculate the median of the current round\n        nth_element(round_values.begin(), round_values.begin() + n / 2, round_values.end());\n        int median = round_values[n / 2];\n\n        // Calculate the prize value for this round\n        int64_t round_prize_value = 0;\n        for (int value : round_values) {\n            round_prize_value += abs(value - median);\n        }\n\n        total_prize_value += round_prize_value;\n    }\n\n    // Call the grader function\n    allocate_tickets(s);\n\n    return total_prize_value;\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 18:29:30",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/D",
    "title": "D. Horses",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "D",
    "submission_id": "314987365",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint N;\nvector<int> X, Y;\nvector<long long> growth; // Stores accumulated growth factors\n\n// Helper function to compute modular multiplication\nlong long mod_mul(long long a, long long b, long long mod = MOD) {\n    return (a * b) % mod;\n}\n\n// Helper function to compute the maximum profit\nint compute_max_profit() {\n    long long max_profit = 0;\n    long long horses = 1; // Start with 1 horse\n    for (int i = 0; i < N; ++i) {\n        max_profit = (max_profit + mod_mul(horses, Y[i])) % MOD;\n        horses = mod_mul(horses, X[i]);\n    }\n    return max_profit;\n}\n\n// Initialize the problem\nint init(int n, int x[], int y[]) {\n    N = n;\n    X.assign(x, x + N);\n    Y.assign(y, y + N);\n    growth.resize(N);\n\n    // Compute initial growth factors\n    growth[0] = X[0];\n    for (int i = 1; i < N; ++i) {\n        growth[i] = mod_mul(growth[i - 1], X[i]);\n    }\n\n    return compute_max_profit();\n}\n\n// Handle updates to X\nint updateX(int pos, int val) {\n    X[pos] = val;\n\n    // Recompute growth factors from position `pos`\n    if (pos == 0) {\n        growth[0] = X[0];\n    } else {\n        growth[pos] = mod_mul(growth[pos - 1], X[pos]);\n    }\n    for (int i = pos + 1; i < N; ++i) {\n        growth[i] = mod_mul(growth[i - 1], X[i]);\n    }\n\n    return compute_max_profit();\n}\n\n// Handle updates to Y\nint updateY(int pos, int val) {\n    Y[pos] = val;\n    return compute_max_profit();\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 18:30:12",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/D",
    "title": "D. Horses",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "D",
    "submission_id": "314990860",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nusing namespace std;\n\nconst int MOD = 1'000'000'007;\n\nint N;\nvector<int64_t> X, Y, cumulativeGrowth;\n\n// Function to compute the maximum profit Mansur can achieve\nint computeMaxProfit() {\n    int64_t maxProfit = 0;\n    int64_t currentHorses = 1;\n\n    for (int i = 0; i < N; ++i) {\n        maxProfit = (maxProfit + currentHorses * Y[i] % MOD) % MOD;\n        currentHorses = currentHorses * X[i] % MOD;\n    }\n\n    return maxProfit;\n}\n\n// Initialize function, called once initially\nint init(int n, int x[], int y[]) {\n    N = n;\n    X.assign(x, x + N);\n    Y.assign(y, y + N);\n\n    // Compute cumulative growth factors up to each year\n    cumulativeGrowth.resize(N);\n    cumulativeGrowth[0] = X[0];\n    for (int i = 1; i < N; ++i) {\n        cumulativeGrowth[i] = cumulativeGrowth[i - 1] * X[i] % MOD;\n    }\n\n    return computeMaxProfit();\n}\n\n// Update growth coefficient X[pos] and recompute the maximum profit\nint updateX(int pos, int val) {\n    X[pos] = val;\n\n    // Update cumulative growth factors starting from pos\n    if (pos == 0) {\n        cumulativeGrowth[0] = X[0];\n    }\n    for (int i = max(1, pos); i < N; ++i) {\n        cumulativeGrowth[i] = cumulativeGrowth[i - 1] * X[i] % MOD;\n    }\n\n    return computeMaxProfit();\n}\n\n// Update selling price Y[pos] and recompute the maximum profit\nint updateY(int pos, int val) {\n    Y[pos] = val;\n    return computeMaxProfit();\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 18:30:56",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/D",
    "title": "D. Horses",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "D",
    "submission_id": "314990986",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nusing namespace std;\n\nconst int MOD = 1'000'000'007;\n\nint N;\nvector<int> X, Y;\nvector<int64_t> prefix_product;\n\nint modular_multiplication(int64_t a, int64_t b) {\n    return (a * b) % MOD;\n}\n\nint compute_max_profit() {\n    int64_t max_profit = 0;\n    for (int i = 0; i < N; ++i) {\n        int64_t profit = modular_multiplication(prefix_product[i], Y[i]);\n        max_profit = max(max_profit, profit);\n    }\n    return max_profit % MOD;\n}\n\nint init(int n, int x[], int y[]) {\n    N = n;\n    X.assign(x, x + N);\n    Y.assign(y, y + N);\n    prefix_product.resize(N);\n\n    // Compute the initial prefix_product array\n    prefix_product[0] = X[0];\n    for (int i = 1; i < N; ++i) {\n        prefix_product[i] = modular_multiplication(prefix_product[i - 1], X[i]);\n    }\n\n    // Return the maximum profit\n    return compute_max_profit();\n}\n\nint updateX(int pos, int val) {\n    X[pos] = val;\n\n    // Recompute prefix_product from position `pos`\n    if (pos == 0) {\n        prefix_product[0] = X[0];\n    } else {\n        prefix_product[pos] = modular_multiplication(prefix_product[pos - 1], X[pos]);\n    }\n\n    for (int i = pos + 1; i < N; ++i) {\n        prefix_product[i] = modular_multiplication(prefix_product[i - 1], X[i]);\n    }\n\n    // Return the maximum profit\n    return compute_max_profit();\n}\n\nint updateY(int pos, int val) {\n    Y[pos] = val;\n\n    // Return the maximum profit\n    return compute_max_profit();\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 18:31:36",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/D",
    "title": "D. Horses",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "D",
    "submission_id": "314991036",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\nint N;\nvector<long long> X, Y;\nvector<long long> cumulativeGrowth;\n\n// Helper function to calculate modular multiplication\nlong long modMul(long long a, long long b) {\n    return (a * b) % MOD;\n}\n\n// Helper function to calculate modular addition\nlong long modAdd(long long a, long long b) {\n    return (a + b) % MOD;\n}\n\n// Function to recompute cumulative growth (used after updates to X)\nvoid computeCumulativeGrowth() {\n    cumulativeGrowth[0] = X[0];\n    for (int i = 1; i < N; ++i) {\n        cumulativeGrowth[i] = modMul(cumulativeGrowth[i - 1], X[i]);\n    }\n}\n\n// Function to calculate the maximum profit\nint calculateMaxProfit() {\n    long long maxProfit = 0;\n    long long horses = 1; // Start with 1 horse\n\n    // Iterate backward to simulate optimal selling\n    for (int i = N - 1; i >= 0; --i) {\n        maxProfit = modAdd(maxProfit, modMul(horses, Y[i]));\n        horses = modMul(horses, X[i]);\n    }\n\n    return maxProfit;\n}\n\n// Initialization function\nint init(int n, int x[], int y[]) {\n    N = n;\n    X.assign(x, x + N);\n    Y.assign(y, y + N);\n    cumulativeGrowth.resize(N);\n\n    // Precompute cumulative growth\n    computeCumulativeGrowth();\n\n    // Return the initial maximum profit\n    return calculateMaxProfit();\n}\n\n// Update function for X[pos]\nint updateX(int pos, int val) {\n    X[pos] = val;\n\n    // Recompute cumulative growth from position `pos`\n    computeCumulativeGrowth();\n\n    // Return the updated maximum profit\n    return calculateMaxProfit();\n}\n\n// Update function for Y[pos]\nint updateY(int pos, int val) {\n    Y[pos] = val;\n\n    // Return the updated maximum profit\n    return calculateMaxProfit();\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 18:32:20",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/D",
    "title": "D. Horses",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "D",
    "submission_id": "314991111",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint N;\nvector<int> X, Y;\nvector<long long> prefixProduct;\nvector<long long> segmentTree;\n\n// Helper function to compute modular multiplication\nlong long modMult(long long a, long long b) {\n    return (a * b) % MOD;\n}\n\n// Helper function to build the segment tree\nvoid buildSegmentTree(int node, int start, int end) {\n    if (start == end) {\n        // Leaf node, store the profit\n        segmentTree[node] = modMult(prefixProduct[start], Y[start]);\n    } else {\n        int mid = (start + end) / 2;\n        buildSegmentTree(2 * node + 1, start, mid);\n        buildSegmentTree(2 * node + 2, mid + 1, end);\n        segmentTree[node] = max(segmentTree[2 * node + 1], segmentTree[2 * node + 2]);\n    }\n}\n\n// Helper function to update the segment tree\nvoid updateSegmentTree(int node, int start, int end, int idx) {\n    if (start == end) {\n        // Leaf node, update the profit\n        segmentTree[node] = modMult(prefixProduct[start], Y[start]);\n    } else {\n        int mid = (start + end) / 2;\n        if (idx <= mid) {\n            updateSegmentTree(2 * node + 1, start, mid, idx);\n        } else {\n            updateSegmentTree(2 * node + 2, mid + 1, end, idx);\n        }\n        segmentTree[node] = max(segmentTree[2 * node + 1], segmentTree[2 * node + 2]);\n    }\n}\n\n// Function to initialize the solution\nint init(int n, int x[], int y[]) {\n    N = n;\n    X = vector<int>(x, x + N);\n    Y = vector<int>(y, y + N);\n\n    // Compute prefix products\n    prefixProduct = vector<long long>(N);\n    prefixProduct[0] = X[0];\n    for (int i = 1; i < N; ++i) {\n        prefixProduct[i] = modMult(prefixProduct[i - 1], X[i]);\n    }\n\n    // Build the segment tree\n    int treeSize = 4 * N;\n    segmentTree = vector<long long>(treeSize, 0);\n    buildSegmentTree(0, 0, N - 1);\n\n    // Return the maximum profit\n    return segmentTree[0];\n}\n\n// Function to handle updates to X\nint updateX(int pos, int val) {\n    // Update the X array\n    X[pos] = val;\n\n    // Update prefix products\n    prefixProduct[pos] = X[pos];\n    if (pos > 0) {\n        prefixProduct[pos] = modMult(prefixProduct[pos - 1], prefixProduct[pos]);\n    }\n    for (int i = pos + 1; i < N; ++i) {\n        prefixProduct[i] = modMult(prefixProduct[i - 1], X[i]);\n    }\n\n    // Update the segment tree\n    for (int i = pos; i < N; ++i) {\n        updateSegmentTree(0, 0, N - 1, i);\n    }\n\n    // Return the maximum profit\n    return segmentTree[0];\n}\n\n// Function to handle updates to Y\nint updateY(int pos, int val) {\n    // Update the Y array\n    Y[pos] = val;\n\n    // Update the segment tree\n    updateSegmentTree(0, 0, N - 1, pos);\n\n    // Return the maximum profit\n    return segmentTree[0];\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:33:12",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A4",
    "title": "A4. Pebbling odometer - subtask 4",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A4",
    "submission_id": "314991196",
    "code_index": 0,
    "code": "odometer\n# Start by collecting pebbles row by row and column by column\nstart:\npebble collect # If there's a pebble in the current cell, go to the collect label\nborder next_row # If we're at the border of the grid, move to the next row\nmove\njump start\n\ncollect:\nget # Pick up the pebble\njump start\n\nnext_row:\nright\nmove\nright\nborder halt_program # If we're at the southern border, we're done\njump traverse_row\n\ntraverse_row:\nmove\nborder back_to_start # If we're at the eastern border, move back to the starting column\njump traverse_row\n\nback_to_start:\nleft\nmove\nleft\nborder start # If we're at the western border, return to the start of the loop\njump back_to_start\n\nhalt_program:\nhalt"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:33:54",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A4",
    "title": "A4. Pebbling odometer - subtask 4",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A4",
    "submission_id": "314991196",
    "code_index": 1,
    "code": "plaintext\n# Start by scanning the entire grid row by row and column by column\ncollect_pebbles:\npebble move_to_cell # If there is a pebble in the current cell, move to it\nborder next_row # If we reach the border of the grid, move to the next row\nmove # Move to the next cell in the row\njump collect_pebbles # Continue scanning\n\nmove_to_cell:\nget # Pick up the pebble from the current cell\nreturn_to_corner:\nborder move_up # If at the border, move upward\nleft\nmove\nright\njump return_to_corner # Keep moving until reaching the north-west corner\n\nnext_row:\nleft # Turn left to move downward\nmove\nleft # Turn left again to face the next row\njump collect_pebbles # Continue scanning the grid"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:34:40",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A4",
    "title": "A4. Pebbling odometer - subtask 4",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A4",
    "submission_id": "314991324",
    "code_index": 2,
    "code": "plaintext\n# Start by initializing the direction and movement\nright             # Face east to traverse the row\ncollect_row:\n    pebble collect_pebble # Check if the current cell has a pebble\n    border next_row       # If at the last column, move to the next row\n    move                  # Otherwise, move to the next cell in the row\n    jump collect_row      # Continue scanning the current row\n\ncollect_pebble:\n    get                   # Pick up the pebble\n    left                  # Turn north\n    move                  # Move toward (0, 0)\n    right                 # Face east again\n    pebble collect_pebble # Check if this cell has another pebble\n    right                 # Turn east\n    jump collect_row      # Resume scanning the row\n\nnext_row:\n    right                 # Turn south to move to the next row\n    move                  # Move down to the next row\n    right                 # Turn east again to scan the new row\n    border done           # If we're at the last row, finish\n    jump collect_row      # Continue scanning the new row\n\ndone:\n    halt                  # End the program"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:35:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A4",
    "title": "A4. Pebbling odometer - subtask 4",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A4",
    "submission_id": "314991386",
    "code_index": 3,
    "code": "plaintext\n# Start by ensuring the odometer is facing east\nright\nstart:\n# Check if the current cell has at least one pebble\npebble collect\n# If no pebbles are found, move forward\nborder next_row\nmove\njump start\n\ncollect:\n# Pick up all pebbles from the current cell\nget\npebble collect\n# Return to cell (0, 0) to drop off all collected pebbles\nreturn_home:\nborder done\nleft\nmove\njump return_home\n\ndone:\n# Drop off all collected pebbles"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:36:09",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A4",
    "title": "A4. Pebbling odometer - subtask 4",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A4",
    "submission_id": "314991386",
    "code_index": 4,
    "code": "plaintext\n# Start collecting pebbles from the entire grid to cell (0, 0)\nstart:\npebble collect # If there's a pebble in the current cell, collect it\nborder next_row # If we are at a border, move to the next row\nmove # Move to the next cell in the current row\njump start # Continue searching for pebbles in the same row\ncollect:\nget # Remove a pebble from the current cell\njump return_to_start # Go back to the starting cell (0, 0) to deposit the pebble\nreturn_to_start:\nborder deposit # If on a border, deposit the pebble\nmove # Move towards (0, 0)\njump return_to_start # Keep moving towards (0, 0)\ndeposit:\nput # Deposit the pebble in cell (0, 0)\njump start # Resume searching for more pebbles\nnext_row:\nright # Turn right to move down to the next row\nmove # Move down one row\nright # Turn right again to face the next row\njump start # Resume searching in the new row\nhalt # Terminate the program"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 18:36:58",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/E",
    "title": "E. Highway Tolls",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "E",
    "submission_id": "314991537",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n\n// Function prototypes provided by the problem\nint64_t ask(vector<int> w);\nvoid answer(int s, int t);\n\nvoid find_pair(int N, vector<int> U, vector<int> V, int A, int B) {\n    int M = U.size();\n    \n    // Step 1: Query with all edges set to light traffic\n    vector<int> all_light(M, 0);\n    int64_t base_cost = ask(all_light);\n\n    // Step 2: Query with all edges set to heavy traffic\n    vector<int> all_heavy(M, 1);\n    int64_t max_cost = ask(all_heavy);\n\n    // Step 3: Perform binary search or BFS-based deduction\n    // We will use targeted queries to isolate S and T\n    \n    // Initialize adjacency list for the graph\n    vector<vector<pair<int, int>>> adj(N);\n    for (int i = 0; i < M; ++i) {\n        adj[U[i]].emplace_back(V[i], i);\n        adj[V[i]].emplace_back(U[i], i);\n    }\n\n    // BFS to find S and T\n    vector<int64_t> dist(N, numeric_limits<int64_t>::max());\n    vector<int> parent(N, -1);\n    vector<int> edge_used(M, 0);\n\n    // Start BFS with all_light weights\n    queue<int> q;\n    q.push(0); // Start from node 0\n    dist[0] = 0;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (auto [v, edge] : adj[u]) {\n            if (dist[v] > dist[u] + A) {\n                dist[v] = dist[u] + A;\n                parent[v] = u;\n                edge_used[edge] = 0; // Mark edge as light\n                q.push(v);\n            }\n        }\n    }\n\n    // Use the results of BFS and targeted queries to identify S and T\n    // Example: Query specific paths or nodes to narrow down S and T\n    for (int i = 0; i < M; ++i) {\n        vector<int> temp_weights(M, 0);\n        temp_weights[i] = 1; // Set one edge to heavy traffic\n        int64_t new_cost = ask(temp_weights);\n\n        // Check if this changes the shortest path significantly\n        if (new_cost > base_cost) {\n            // This edge might be on the path from S to T\n            edge_used[i] = 1;\n        }\n    }\n\n    // Deduce S and T from the edge usage or path analysis\n    int S = -1, T = -1;\n    for (int i = 0; i < N; ++i) {\n        if (parent[i] == -1) {\n            S = i;\n        } else {\n            T = i;\n        }\n    }\n\n    // Step 4: Report the result\n    answer(S, T);\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 18:37:38",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/E",
    "title": "E. Highway Tolls",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "E",
    "submission_id": "314991537",
    "code_index": 1,
    "code": "#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\n// External function declarations provided by the grader\nint64_t ask(vector<int> w);\nvoid answer(int s, int t);\n\nvoid find_pair(int N, vector<int> U, vector<int> V, int A, int B) {\n    int M = U.size();\n    vector<vector<pair<int, int>>> adj(N); // adjacency list to represent the graph\n\n    // Build the adjacency list\n    for (int i = 0; i < M; ++i) {\n        adj[U[i]].emplace_back(V[i], i);\n        adj[V[i]].emplace_back(U[i], i);\n    }\n\n    // Step 1: Query with all edges having light traffic (w[i] = 0)\n    vector<int> w(M, 0);\n    int64_t base_cost = ask(w);\n\n    // Step 2: Perform queries to identify S and T\n    vector<int> distance(N, -1); // Distance from a source node\n    vector<int> parent(N, -1);  // Parent in the shortest path tree\n    int S = -1, T = -1;         // To store the pair of cities\n\n    // Start with an arbitrary node (e.g., node 0)\n    queue<int> q;\n    q.push(0);\n    distance[0] = 0;\n\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n\n        for (auto [neighbor, edge_idx] : adj[curr]) {\n            if (distance[neighbor] == -1) { // Not visited\n                // Set the current edge to heavy traffic\n                w[edge_idx] = 1;\n                int64_t new_cost = ask(w);\n\n                // If the new cost increases, the edge is part of the shortest path\n                if (new_cost > base_cost) {\n                    S = curr;\n                    T = neighbor;\n                }\n\n                // Restore the edge to light traffic\n                w[edge_idx] = 0;\n\n                // Update BFS structures\n                distance[neighbor] = distance[curr] + 1;\n                parent[neighbor] = curr;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    // Step 3: Report the answer\n    answer(S, T);\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 18:38:17",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/E",
    "title": "E. Highway Tolls",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "E",
    "submission_id": "314991646",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n// Declaration of the grader functions\nextern int64_t ask(vector<int> w);\nextern void answer(int s, int t);\n\nvoid find_pair(int N, vector<int> U, vector<int> V, int A, int B) {\n    int M = U.size();\n    vector<int> w(M, 0); // Start with all highways having light traffic (w[i] = 0)\n    \n    // Call ask with all light traffic\n    int64_t base_cost = ask(w);\n\n    // Map the graph with adjacency list\n    vector<vector<pair<int, int>>> adj(N); // adjacency list: node -> [(neighbor, edge_index)]\n    for (int i = 0; i < M; i++) {\n        adj[U[i]].emplace_back(V[i], i);\n        adj[V[i]].emplace_back(U[i], i);\n    }\n\n    // Perform BFS to narrow down S and T\n    vector<int64_t> distance_from_all_light(N, numeric_limits<int64_t>::max());\n    queue<int> q;\n    q.push(0);\n    distance_from_all_light[0] = 0;\n    \n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        \n        for (auto& [neighbor, edge_index] : adj[node]) {\n            if (distance_from_all_light[neighbor] == numeric_limits<int64_t>::max()) {\n                distance_from_all_light[neighbor] = distance_from_all_light[node] + A;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    // Identify S and T by toggling specific edges\n    int S = -1, T = -1;\n    for (int i = 0; i < M; i++) {\n        // Toggle the i-th edge to heavy traffic\n        w[i] = 1;\n        int64_t new_cost = ask(w);\n        w[i] = 0; // Reset back to light traffic\n\n        // Check if this edge affects the shortest path\n        if (new_cost != base_cost) {\n            // The edge affects the shortest path, meaning it is part of the path between S and T\n            S = U[i];\n            T = V[i];\n            break;\n        }\n    }\n\n    // Return the identified pair S and T\n    answer(S, T);\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 18:38:59",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/E",
    "title": "E. Highway Tolls",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "E",
    "submission_id": "314991706",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\nextern int64_t ask(vector<int> w);\nextern void answer(int s, int t);\n\nvoid find_pair(int N, vector<int> U, vector<int> V, int A, int B) {\n    int M = U.size();\n    \n    // Step 1: Query all-light traffic\n    vector<int> all_light(M, 0);\n    int64_t d0 = ask(all_light);\n    \n    // Step 2: Query all-heavy traffic\n    vector<int> all_heavy(M, 1);\n    int64_t d1 = ask(all_heavy);\n    \n    // Step 3: Analyze individual edges\n    vector<int64_t> edge_effect(M);\n    vector<int> edge_in_path(M, 0);\n    for (int i = 0; i < M; ++i) {\n        vector<int> w = all_light;\n        w[i] = 1;  // Make edge i heavy\n        edge_effect[i] = ask(w);\n        if (edge_effect[i] > d0) {\n            edge_in_path[i] = 1;  // This edge might be part of the shortest path\n        }\n    }\n    \n    // Step 4: Reconstruct the shortest path graph\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < M; ++i) {\n        if (edge_in_path[i]) {\n            adj[U[i]].push_back(V[i]);\n            adj[V[i]].push_back(U[i]);\n        }\n    }\n    \n    // Step 5: Find endpoints S and T using BFS\n    vector<int> dist(N, -1);\n    queue<int> q;\n    int start = 0;  // Arbitrary starting node\n    dist[start] = 0;\n    q.push(start);\n    \n    int farthest_node = start;\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        for (int neighbor : adj[curr]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[curr] + 1;\n                q.push(neighbor);\n                farthest_node = neighbor;\n            }\n        }\n    }\n    \n    // BFS from farthest_node to find the other endpoint\n    fill(dist.begin(), dist.end(), -1);\n    dist[farthest_node] = 0;\n    q.push(farthest_node);\n    \n    int other_endpoint = farthest_node;\n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        for (int neighbor : adj[curr]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[curr] + 1;\n                q.push(neighbor);\n                other_endpoint = neighbor;\n            }\n        }\n    }\n    \n    // Step 6: Report the result\n    answer(farthest_node, other_endpoint);\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 18:39:43",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/E",
    "title": "E. Highway Tolls",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "E",
    "submission_id": "314991781",
    "code_index": 4,
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\n#include <utility>\nusing namespace std;\n\n// Function declarations provided by the problem\nextern int64_t ask(vector<int> w);\nextern void answer(int s, int t);\n\nvoid find_pair(int N, vector<int> U, vector<int> V, int A, int B) {\n    int M = U.size();\n    \n    // Step 1: Initialize all traffic conditions to light (w[i] = 0 for all i)\n    vector<int> w(M, 0);\n    int64_t light_cost = ask(w); // Query the cost with all light tolls\n    \n    // Step 2: Initialize all traffic conditions to heavy (w[i] = 1 for all i)\n    fill(w.begin(), w.end(), 1);\n    int64_t heavy_cost = ask(w); // Query the cost with all heavy tolls\n    \n    // The shortest path in terms of light tolls would be `light_cost / A`\n    // The shortest path in terms of heavy tolls would be `heavy_cost / B`\n    int light_path_length = light_cost / A;\n    int heavy_path_length = heavy_cost / B;\n\n    // Step 3: Identify the endpoint of the shortest path in terms of light tolls\n    // We will set one edge to heavy at a time to find which edge lies on the path\n    vector<int> endpoints;\n    w.assign(M, 0); // Reset to all light\n    for (int i = 0; i < M; i++) {\n        w[i] = 1; // Temporarily set edge `i` to heavy\n        int64_t cost = ask(w);\n        if (cost == light_cost + (B - A)) { // This edge contributes to the shortest path\n            endpoints.push_back(U[i]);\n            endpoints.push_back(V[i]);\n        }\n        w[i] = 0; // Reset edge `i` back to light\n        if (endpoints.size() > 2) break; // We only need two endpoints\n    }\n\n    // Step 4: Deduce the pair S and T\n    // The two endpoints of the light toll shortest path are likely S and T\n    int s = endpoints[0];\n    int t = endpoints[1];\n\n    // Verify the pair using the heavy toll shortest path\n    w.assign(M, 1); // Set all edges to heavy\n    for (int i = 0; i < M; i++) {\n        if ((U[i] == s && V[i] == t) || (U[i] == t && V[i] == s)) {\n            w[i] = 0; // Temporarily set edge `i` to light\n            break;\n        }\n    }\n    int64_t verify_cost = ask(w);\n    if (verify_cost != heavy_cost) {\n        swap(s, t); // If the costs don't match, swap S and T\n    }\n\n    // Step 5: Report the answer\n    answer(s, t);\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:40:28",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/D",
    "title": "D. Digital Circuit",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "D",
    "submission_id": "314990355",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000002022;\nint N, M;\nvector<int> P;\nvector<int> A;\nvector<vector<int>> inputs; // Inputs for each threshold gate (0 to N-1)\nvector<int> states;         // States of all gates (0 to N+M-1)\nvector<int> thresholds;     // Threshold values for threshold gates\nvector<int> input_counts;   // Number of inputs contributing to each gate's state\n\nvoid init(int n, int m, vector<int> p, vector<int> a) {\n    N = n;\n    M = m;\n    P = p;\n    A = a;\n\n    inputs.assign(N, vector<int>());\n    states.assign(N + M, 0);\n    thresholds.assign(N, 0);\n    input_counts.assign(N, 0);\n\n    // Initialize the inputs for each threshold gate\n    for (int i = 1; i < N + M; ++i) {\n        inputs[P[i]].push_back(i);\n    }\n\n    // Initialize the states of source gates\n    for (int j = 0; j < M; ++j) {\n        states[N + j] = A[j];\n    }\n\n    // Calculate initial states for threshold gates\n    for (int i = N + M - 1; i >= 0; --i) {\n        if (i < N) { // Threshold gates\n            int count_ones = 0;\n            for (int input_gate : inputs[i]) {\n                if (states[input_gate] == 1) {\n                    ++count_ones;\n                }\n            }\n            input_counts[i] = count_ones;\n            thresholds[i] = inputs[i].size(); // Initially set to the max possible threshold\n            states[i] = (count_ones >= thresholds[i]) ? 1 : 0;\n        }\n    }\n}\n\nint count_ways(int L, int R) {\n    // Toggle the states of source gates in range [L, R]\n    for (int i = L; i <= R; ++i) {\n        states[i] ^= 1; // Toggle state\n    }\n\n    // Propagate state changes to threshold gates\n    queue<int> q;\n    vector<bool> visited(N, false);\n\n    for (int i = L; i <= R; ++i) {\n        int parent = P[i];\n        if (parent >= 0 && !visited[parent]) {\n            q.push(parent);\n            visited[parent] = true;\n        }\n    }\n\n    while (!q.empty()) {\n        int gate = q.front();\n        q.pop();\n\n        int count_ones = 0;\n        for (int input_gate : inputs[gate]) {\n            if (states[input_gate] == 1) {\n                ++count_ones;\n            }\n        }\n\n        input_counts[gate] = count_ones;\n        states[gate] = (count_ones >= thresholds[gate]) ? 1 : 0;\n\n        if (gate > 0 && !visited[P[gate]]) {\n            q.push(P[gate]);\n            visited[P[gate]] = true;\n        }\n    }\n\n    // Calculate the number of valid parameter assignments for gate 0\n    int result = 1;\n    for (int i = 0; i < N; ++i) {\n        if (states[i] == 1) {\n            result = (1LL * result * input_counts[i]) % MOD;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:41:11",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/D",
    "title": "D. Digital Circuit",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "D",
    "submission_id": "314991916",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nconst int MOD = 1000002022;\n\nint N, M;\nvector<int> parent; // Parent array P\nvector<int> initialState; // Initial state of source gates\nvector<vector<int>> inputs; // Inputs to each threshold gate\nvector<int> currentState; // Current state of all gates\nvector<int> numInputs; // Number of inputs for each threshold gate\nvector<int> toggleCount; // Toggle counts for source gates\n\nvoid updateState(int gate) {\n    if (gate >= N) return; // Source gates don't need updates\n\n    int activeCount = 0;\n    for (int input : inputs[gate]) {\n        activeCount += currentState[input];\n    }\n\n    currentState[gate] = (activeCount >= numInputs[gate]);\n}\n\nvoid propagateState() {\n    queue<int> q;\n    for (int i = 0; i < N; ++i) {\n        q.push(i);\n    }\n\n    while (!q.empty()) {\n        int gate = q.front();\n        q.pop();\n\n        int oldState = currentState[gate];\n        updateState(gate);\n\n        if (currentState[gate] != oldState && gate != 0) {\n            q.push(parent[gate]);\n        }\n    }\n}\n\nvoid init(int N_, int M_, vector<int> P, vector<int> A) {\n    N = N_;\n    M = M_;\n    parent = P;\n    initialState = A;\n\n    inputs.assign(N, vector<int>());\n    currentState.assign(N + M, 0);\n    numInputs.assign(N, 0);\n    toggleCount.assign(M, 0);\n\n    for (int i = 1; i < N + M; ++i) {\n        inputs[parent[i]].push_back(i);\n    }\n\n    for (int i = 0; i < N; ++i) {\n        numInputs[i] = inputs[i].size();\n    }\n\n    for (int i = 0; i < M; ++i) {\n        currentState[N + i] = initialState[i];\n    }\n\n    propagateState();\n}\n\nint count_ways(int L, int R) {\n    // Toggle the state of the source gates in range [L, R]\n    for (int i = L; i <= R; ++i) {\n        currentState[i] = 1 - currentState[i];\n    }\n\n    propagateState();\n\n    // Calculate the number of valid parameter assignments for gate 0 to have state 1\n    int result = 1;\n    for (int i = 0; i < N; ++i) {\n        if (currentState[i] == 1) {\n            result = (1LL * result * numInputs[i]) % MOD;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:41:52",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/D",
    "title": "D. Digital Circuit",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "D",
    "submission_id": "314991989",
    "code_index": 2,
    "code": "// Your code will be placed here\n\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Constants\nconst int MOD = 1000002022;\n\n// Global variables\nint N, M; // Number of threshold and source gates\nvector<int> P; // Input mapping for threshold gates\nvector<int> A; // Initial states of source gates\nvector<int> states; // Current states of all gates\nvector<vector<int>> inputs; // Inputs for each threshold gate\nvector<int> thresholds; // Thresholds for each threshold gate\nvector<int> inputCount; // Number of inputs for each threshold gate\n\n// Helper function to compute power modulo MOD\nint modPow(int base, int exp) {\n    int result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) result = (1LL * result * base) % MOD;\n        base = (1LL * base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\n// Initialize the system\nvoid init(int n, int m, vector<int> p, vector<int> a) {\n    N = n;\n    M = m;\n    P = p;\n    A = a;\n\n    // Initialize variables\n    states.assign(N + M, 0);\n    inputs.assign(N, vector<int>());\n    thresholds.assign(N, 0);\n    inputCount.assign(N, 0);\n\n    // Set up initial states of source gates\n    for (int i = 0; i < M; ++i) {\n        states[N + i] = A[i];\n    }\n\n    // Build input lists for each threshold gate\n    for (int i = 1; i < N + M; ++i) {\n        inputs[P[i]].push_back(i);\n    }\n\n    // Set input counts for threshold gates\n    for (int i = 0; i < N; ++i) {\n        inputCount[i] = inputs[i].size();\n    }\n}\n\n// Update the states of the gates after toggling source gates\nvoid updateStates(int L, int R) {\n    // Toggle the states of source gates in the range [L, R]\n    for (int i = L; i <= R; ++i) {\n        states[i] = 1 - states[i];\n    }\n\n    // Reset states of threshold gates\n    for (int i = 0; i < N; ++i) {\n        thresholds[i] = 0;\n    }\n\n    // Perform a topological update of the gate states\n    for (int i = N + M - 1; i >= 0; --i) {\n        if (i >= N) continue; // Skip source gates\n\n        // Count the number of active inputs\n        int activeCount = 0;\n        for (int input : inputs[i]) {\n            if (states[input] == 1) {\n                ++activeCount;\n            }\n        }\n\n        // Update the state of the threshold gate\n        states[i] = (activeCount >= thresholds[i]) ? 1 : 0;\n    }\n}\n\n// Count the number of ways to assign parameters such that gate 0 has state 1\nint countWays(int L, int R) {\n    // Update the gate states\n    updateStates(L, R);\n\n    // Compute the number of ways threshold gates can be assigned\n    if (states[0] == 0) return 0; // If gate 0 is not active, no valid assignment\n\n    int totalWays = 1;\n    for (int i = 0; i < N; ++i) {\n        // The number of valid thresholds for this gate\n        int validThresholds = (states[i] == 1) ? inputCount[i] : 0;\n\n        // Multiply the number of ways\n        totalWays = (1LL * totalWays * validThresholds) % MOD;\n    }\n\n    return totalWays;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:42:41",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/D",
    "title": "D. Digital Circuit",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "D",
    "submission_id": "314992061",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nconst int MOD = 1000002022;\n\nint N, M;\nvector<int> P, A;\nvector<vector<int>> inputs; // To store the inputs of each threshold gate\nvector<int> state; // To store the current state of all gates (threshold + source)\nvector<int> threshold_gate_inputs; // Number of inputs for each threshold gate\n\n// Precomputed powers of 2 modulo MOD for fast computation of parameter assignments\nvector<int> power_of_2;\n\n// Precomputes the power of 2 modulo MOD up to the maximum number of inputs\nvoid precompute_powers_of_2(int max_inputs) {\n    power_of_2.resize(max_inputs + 1);\n    power_of_2[0] = 1;\n    for (int i = 1; i <= max_inputs; ++i) {\n        power_of_2[i] = (2 * power_of_2[i - 1]) % MOD;\n    }\n}\n\n// Initializes the input data and prepares for efficient computation\nvoid init(int n, int m, vector<int> p, vector<int> a) {\n    N = n;\n    M = m;\n    P = p;\n    A = a;\n\n    // Initialize state vector\n    state.resize(N + M, 0);\n    for (int i = 0; i < M; ++i) {\n        state[N + i] = A[i];\n    }\n\n    // Initialize inputs list for each threshold gate\n    inputs.resize(N);\n    threshold_gate_inputs.resize(N, 0);\n    for (int i = 1; i < N + M; ++i) {\n        inputs[P[i]].push_back(i);\n        if (P[i] < N) {\n            ++threshold_gate_inputs[P[i]];\n        }\n    }\n\n    // Precompute powers of 2 modulo MOD\n    precompute_powers_of_2(*max_element(threshold_gate_inputs.begin(), threshold_gate_inputs.end()));\n}\n\n// Updates the states of the source gates in the specified range\nvoid toggle_source_gates(int L, int R) {\n    for (int i = L; i <= R; ++i) {\n        state[i] = 1 - state[i]; // Toggle the state\n    }\n}\n\n// Computes the state of a threshold gate based on its inputs\nint compute_gate_state(int gate_id) {\n    int active_inputs = 0;\n    for (int input_gate : inputs[gate_id]) {\n        active_inputs += state[input_gate];\n    }\n    return active_inputs;\n}\n\n// Counts the number of ways to assign parameters such that gate 0 has state 1\nint count_state_one_ways() {\n    // BFS or topological sorting approach to compute gate states\n    queue<int> q;\n    vector<int> computed_state(N, -1); // -1 means not computed yet\n\n    // Start with source gates and propagate to threshold gates\n    q.push(0);\n    while (!q.empty()) {\n        int current_gate = q.front();\n        q.pop();\n\n        // Compute the state of the current gate\n        int active_inputs = compute_gate_state(current_gate);\n        computed_state[current_gate] = active_inputs;\n\n        // Push dependent gates into the queue\n        for (int input_gate : inputs[current_gate]) {\n            if (input_gate < N) { // Threshold gates only\n                q.push(input_gate);\n            }\n        }\n    }\n\n    // Compute the number of valid assignments for gate 0\n    int gate_0_inputs = computed_state[0];\n    if (gate_0_inputs == 0) {\n        return 0; // No way to make gate 0 state 1\n    }\n    return (power_of_2[gate_0_inputs - 1]) % MOD;\n}\n\n// Handles the toggle operation and computes the result\nint count_ways(int L, int R) {\n    toggle_source_gates(L, R);\n    return count_state_one_ways();\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:43:22",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/D",
    "title": "D. Digital Circuit",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "D",
    "submission_id": "314992061",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nconst int MOD = 1000002022;\n\nint N, M;\nvector<int> P;\nvector<int> A;\nvector<vector<int>> inputs; // Inputs for each threshold gate\nvector<int> states;         // States for all gates (threshold + source)\nvector<int> sizes;          // Sizes of input sets for each threshold gate\n\n// Helper function to calculate the number of valid assignments for a threshold gate\nint count_valid_assignments(int ones, int total_inputs) {\n    if (ones == 0) return 0;\n    return ones;\n}\n\n// Function to initialize the circuit and input data\nvoid init(int N_, int M_, vector<int> P_, vector<int> A_) {\n    N = N_;\n    M = M_;\n    P = move(P_);\n    A = move(A_);\n    \n    int total_gates = N + M;\n    states.resize(total_gates, 0);\n    sizes.resize(N, 0);\n    inputs.resize(N);\n    \n    // Initialize source gate states\n    for (int i = 0; i < M; ++i) {\n        states[N + i] = A[i];\n    }\n\n    // Build the input structure for threshold gates\n    for (int i = 1; i < total_gates; ++i) {\n        inputs[P[i]].push_back(i);\n        sizes[P[i]]++;\n    }\n}\n\n// Function to toggle the states of source gates in the range [L, R]\nvoid toggle_source_states(int L, int R) {\n    for (int i = L; i <= R; ++i) {\n        states[i] ^= 1; // Toggle state\n    }\n}\n\n// Function to calculate the state of a threshold gate\nint calculate_gate_state(int gate) {\n    int ones = 0;\n    for (int input : inputs[gate]) {\n        ones += states[input];\n    }\n    return ones;\n}\n\n// Function to calculate the number of ways gate 0 can have state 1\nint count_ways(int L, int R) {\n    // Toggle source states\n    toggle_source_states(L, R);\n    \n    // Calculate states for all threshold gates\n    vector<int> threshold_states(N, 0);\n    for (int i = N - 1; i >= 0; --i) {\n        threshold_states[i] = calculate_gate_state(i);\n    }\n    \n    // Calculate the number of valid assignments for gate 0\n    int ways = count_valid_assignments(threshold_states[0], sizes[0]);\n    return ways % MOD;\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 18:44:15",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/D",
    "title": "D. Mechanical Doll",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "D",
    "submission_id": "314992216",
    "code_index": 0,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid create_circuit(int M, vector<int> A) {\n    int N = A.size();\n    vector<int> C(M + 1); // Connections for origin and triggers\n    vector<int> X;       // Connections for switches (exit X)\n    vector<int> Y;       // Connections for switches (exit Y)\n    \n    // Map triggers to switches to avoid excess usage of switches\n    vector<int> last_used_trigger(M + 1, -1); // Tracks the last switch used for each trigger\n    int switch_counter = 0; // Counter for switches\n\n    // Connect origin to the first trigger in A\n    C[0] = A[0];\n\n    for (int i = 0; i < N; i++) {\n        int current_trigger = A[i];\n        int next_trigger = (i == N - 1) ? 0 : A[i + 1]; // Connect to origin if last trigger\n\n        // Check if we need a new switch for this transition\n        if (last_used_trigger[current_trigger] == -1) {\n            // Create a new switch\n            switch_counter++;\n            last_used_trigger[current_trigger] = -switch_counter;\n            X.push_back(next_trigger); // Connect exit X to the next trigger\n            Y.push_back(current_trigger); // Connect exit Y to the current trigger\n        } else {\n            // Reuse the existing switch\n            int switch_id = last_used_trigger[current_trigger];\n            X[-switch_id - 1] = next_trigger; // Update exit X\n        }\n\n        // Connect the current trigger to its corresponding switch\n        C[current_trigger] = last_used_trigger[current_trigger];\n    }\n\n    // Provide the answer to the grader\n    answer(C, X, Y);\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 18:44:53",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/D",
    "title": "D. Mechanical Doll",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "D",
    "submission_id": "314992292",
    "code_index": 1,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid create_circuit(int M, vector<int> A) {\n    int N = A.size();  // Length of sequence A\n\n    // Initialize arrays\n    vector<int> C(M + 1, 0);  // Connections for origin and triggers\n    vector<int> X;            // Exit 'X' connections for switches\n    vector<int> Y;            // Exit 'Y' connections for switches\n\n    int S = 0;  // Number of switches\n    int last_switch = 0;  // The last switch created\n\n    // Map triggers in sequence A\n    vector<int> trigger_to_next(M + 1, 0);\n    for (int i = 0; i < N; ++i) {\n        if (i < N - 1) {\n            trigger_to_next[A[i]] = A[i + 1];\n        } else {\n            trigger_to_next[A[i]] = 0;  // Last trigger loops to origin\n        }\n    }\n\n    // Create the circuit\n    for (int i = 0; i <= M; ++i) {\n        if (trigger_to_next[i] == 0) {\n            C[i] = 0;  // Connect to origin\n        } else {\n            // Create a new switch\n            ++S;\n            last_switch = -S;  // Switch IDs are negative\n            C[i] = last_switch;\n\n            // Configure the switch\n            X.push_back(trigger_to_next[i]);  // Exit 'X' leads to the next trigger\n            Y.push_back(i == 0 ? 0 : i);     // Exit 'Y' loops back\n        }\n    }\n\n    // Answer the circuit configuration\n    answer(C, X, Y);\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 18:45:35",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/D",
    "title": "D. Mechanical Doll",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "D",
    "submission_id": "314992352",
    "code_index": 2,
    "code": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\n// Your code will be placed here\nvoid create_circuit(int M, vector<int> A) {\n    int N = A.size();  // Length of sequence A.\n    \n    // Step 1: Calculate S (number of switches).\n    int S = 0;\n    vector<int> switch_used(M + 1, 0);  // Track how many switches are used for each trigger.\n    unordered_map<int, int> switch_mapping;  // Map of switches for triggers.\n\n    vector<int> C(M + 1, 0);  // Exit connections for origin and triggers.\n    vector<int> X;  // Exit 'X' connections for switches.\n    vector<int> Y;  // Exit 'Y' connections for switches.\n\n    // Step 2: Build the circuit.\n    for (int i = 0; i < N; ++i) {\n        int trigger = A[i];\n        \n        // Check if we need a new switch for this trigger.\n        if (switch_used[trigger] == 0) {\n            ++S;\n            switch_mapping[trigger] = -S;  // Assign switch number (negative).\n            switch_used[trigger] = 1;\n            X.push_back(trigger);  // Connect 'X' to the current trigger.\n            Y.push_back(0);       // Connect 'Y' back to the origin.\n        } else {\n            // Update 'Y' connection for the last switch used by this trigger.\n            Y[-switch_mapping[trigger] - 1] = trigger;\n        }\n    }\n\n    // Connect the origin to the first trigger or switch.\n    C[0] = switch_mapping[A[0]];\n\n    // Connect all triggers sequentially.\n    for (int i = 1; i < N; ++i) {\n        int trigger = A[i - 1];\n        int next_trigger = A[i];\n        C[trigger] = switch_mapping[next_trigger];\n    }\n\n    // Connect the last trigger back to the origin.\n    int last_trigger = A.back();\n    C[last_trigger] = 0;\n\n    // Step 3: Call the answer function to provide the solution.\n    answer(C, X, Y);\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 18:46:18",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/D",
    "title": "D. Mechanical Doll",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "D",
    "submission_id": "314992418",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvoid create_circuit(int M, vector<int> A) {\n    int N = A.size();\n\n    // To store the connections for output\n    vector<int> C(M + 1); // Connections for origin and triggers\n    vector<int> X, Y;     // Connections for switches\n\n    // Map each trigger to a corresponding switch\n    unordered_map<int, int> trigger_to_switch;\n    int switch_count = 0;\n\n    // Construct the circuit\n    int prev_device = 0; // Start from the origin\n    for (int i = 0; i < N; i++) {\n        int trigger = A[i];\n        \n        if (trigger_to_switch.find(trigger) == trigger_to_switch.end()) {\n            // Create a new switch for this trigger\n            switch_count++;\n            trigger_to_switch[trigger] = -switch_count; // Assign switch ID\n            X.push_back(trigger); // Connect exit 'X' of the new switch to the trigger\n            Y.push_back(prev_device); // Connect exit 'Y' of the new switch to the previous device\n        }\n\n        // Connect the previous device to this switch\n        C[prev_device] = trigger_to_switch[trigger];\n        prev_device = trigger_to_switch[trigger];\n    }\n\n    // Finally, connect the last device back to the origin\n    C[prev_device] = 0;\n\n    // Output the circuit\n    answer(C, X, Y);\n}"
  },
  {
    "date": "IOI 2018 day 2",
    "timestamp": "2025-04-11 18:46:58",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103777/problem/D",
    "title": "D. Mechanical Doll",
    "group_id": "32KGsXgiKA",
    "contest_id": "103777",
    "problem_index": "D",
    "submission_id": "314992474",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvoid create_circuit(int M, vector<int> A) {\n    int N = A.size(); // Length of the sequence A\n\n    // To store the circuit connections\n    vector<int> C(M + 1, 0); // Exit connections for origin and triggers\n    vector<int> X;           // Exit 'X' connections for switches\n    vector<int> Y;           // Exit 'Y' connections for switches\n\n    // Map to keep track of the last used switch for each trigger\n    unordered_map<int, int> lastSwitch;\n\n    int currentSwitch = -1; // Switch IDs start from -1\n\n    // Build the circuit\n    for (int i = 0; i < N; i++) {\n        int trigger = A[i];\n        if (lastSwitch.count(trigger) == 0) {\n            // If this trigger hasn't been connected to a switch yet\n            currentSwitch--; // Use a new switch\n            lastSwitch[trigger] = currentSwitch;\n\n            // Connect this switch to the trigger and the next trigger\n            X.push_back(trigger); // Exit 'X' goes to the current trigger\n            Y.push_back(0);       // Exit 'Y' goes back to the origin for now\n\n            // Set the trigger to point to this switch\n            C[trigger] = currentSwitch;\n        } else {\n            // If this trigger has been connected before\n            int switchID = lastSwitch[trigger];\n            Y[-switchID - 1] = trigger; // Update the 'Y' connection for the switch\n        }\n    }\n\n    // Connect the origin to the first trigger\n    C[0] = lastSwitch[A[0]];\n\n    // Output the circuit configuration\n    answer(C, X, Y);\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 18:47:49",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/F",
    "title": "F. Sphnix",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "F",
    "submission_id": "314992557",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n// Your code will be placed here\nstd::vector<int> find_colours(int N, std::vector<int> X, std::vector<int> Y) {\n    // Resulting color array\n    vector<int> colors(N, -1);\n\n    // Step 1: Perform initial experiment to get the baseline number of components\n    vector<int> E(N, -1);\n    int initial_components = perform_experiment(E);\n\n    // Step 2: Determine the color groups\n    for (int i = 0; i < N; ++i) {\n        // Recolor vertex `i` to the Sphinx's color (N)\n        E.assign(N, -1);\n        E[i] = N;\n        int new_components = perform_experiment(E);\n\n        // If the number of components increases, vertex `i` is in a unique color group\n        if (new_components > initial_components) {\n            colors[i] = i; // Assign a unique color to this vertex\n        }\n    }\n\n    // Step 3: Propagate colors through connected components\n    // Construct adjacency list from edges\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < X.size(); ++i) {\n        adj[X[i]].push_back(Y[i]);\n        adj[Y[i]].push_back(X[i]);\n    }\n\n    // BFS to propagate colors\n    for (int i = 0; i < N; ++i) {\n        if (colors[i] != -1) { // If already colored, propagate\n            queue<int> q;\n            q.push(i);\n\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n\n                for (int v : adj[u]) {\n                    if (colors[v] == -1) { // If not colored\n                        // Recolor vertex `v` to the same color as `u`\n                        E.assign(N, -1);\n                        E[v] = colors[u];\n                        int new_components = perform_experiment(E);\n\n                        // If the number of components remains the same, they share the same color\n                        if (new_components == initial_components) {\n                            colors[v] = colors[u];\n                            q.push(v);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Step 4: Assign unique colors for any uncolored vertices (unlikely but safe fallback)\n    for (int i = 0; i < N; ++i) {\n        if (colors[i] == -1) {\n            colors[i] = i; // Assign a unique color\n        }\n    }\n\n    return colors;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 18:48:33",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/F",
    "title": "F. Sphnix",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "F",
    "submission_id": "314992624",
    "code_index": 1,
    "code": "#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <set>\n#include <algorithm>\n\n// Your code will be placed here\nstd::vector<int> find_colours(int N, std::vector<int> X, std::vector<int> Y) {\n    // The result array to store the deduced colors of the vertices\n    std::vector<int> G(N, -1);\n\n    // Step 1: Perform an initial experiment with no recoloring\n    std::vector<int> E(N, -1);\n    int base_components = perform_experiment(E);\n\n    // Step 2: Deduce colors for each vertex\n    for (int i = 0; i < N; ++i) {\n        // Recolor vertex `i` to a unique color (e.g., Sphinx's color `N`)\n        std::vector<int> E_temp(N, -1);\n        E_temp[i] = N;\n        int new_components = perform_experiment(E_temp);\n\n        // If the number of components decreases, this vertex has a unique color\n        if (new_components < base_components) {\n            G[i] = i; // Assign the vertex a unique color based on its index\n        }\n    }\n\n    // Step 3: Group vertices with the same color\n    // For vertices whose colors are not yet determined, we deduce them\n    for (int i = 0; i < N; ++i) {\n        if (G[i] != -1) continue; // Skip vertices whose colors are already determined\n\n        // Attempt to match this vertex's color with already known colors\n        for (int color = 0; color < N; ++color) {\n            if (std::find(G.begin(), G.end(), color) == G.end()) continue; // Skip unused colors\n\n            // Recolor `i` and check if it belongs to the same component as other vertices with `color`\n            std::vector<int> E_temp(N, -1);\n            E_temp[i] = color;\n            int new_components = perform_experiment(E_temp);\n\n            // If the number of components remains the same, assign this color to the vertex\n            if (new_components == base_components) {\n                G[i] = color;\n                break;\n            }\n        }\n\n        // If no match is found, assign a new unique color\n        if (G[i] == -1) {\n            G[i] = i;\n        }\n    }\n\n    return G;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 18:49:34",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/F",
    "title": "F. Sphnix",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "F",
    "submission_id": "314992713",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nint perform_experiment(std::vector<int> E);\n\nstd::vector<int> find_colours(int N, std::vector<int> X, std::vector<int> Y) {\n    // Initialize the color array to store the deduced colors of vertices\n    std::vector<int> colors(N, -1);\n    // All vertices are initially unexplored\n    std::vector<bool> explored(N, false);\n\n    // Adjacency list representation of the graph\n    std::vector<std::vector<int>> adj(N);\n    for (size_t i = 0; i < X.size(); ++i) {\n        adj[X[i]].push_back(Y[i]);\n        adj[Y[i]].push_back(X[i]);\n    }\n\n    // Step 1: Use the Sphinx's color (N) to isolate each vertex\n    for (int v = 0; v < N; ++v) {\n        std::vector<int> E(N, -1);\n        E[v] = N; // Recolor vertex v to the Sphinx's color\n        int components = perform_experiment(E);\n\n        // If the number of components is equal to N, vertex v is isolated\n        if (components == N) {\n            colors[v] = v; // Assign a unique color to vertex v\n        }\n    }\n\n    // Step 2: Deduce colors for remaining vertices\n    for (int v = 0; v < N; ++v) {\n        if (colors[v] == -1) {\n            // Recolor vertex v to a specific color and check connectivity\n            for (int color_candidate = 0; color_candidate < N; ++color_candidate) {\n                std::vector<int> E(N, -1);\n                E[v] = color_candidate; // Recolor vertex v to color_candidate\n                int components = perform_experiment(E);\n\n                // If recoloring vertex v with color_candidate reduces the number of components,\n                // it implies that this is the correct color for vertex v.\n                if (components < N) {\n                    colors[v] = color_candidate;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Step 3: Ensure adjacent vertices have consistent colors\n    for (size_t i = 0; i < X.size(); ++i) {\n        int u = X[i], v = Y[i];\n        if (colors[u] == colors[v]) continue;\n\n        // If colors of u and v are inconsistent, adjust by recoloring\n        std::vector<int> E(N, -1);\n        E[u] = colors[u];\n        E[v] = colors[u];\n        int components = perform_experiment(E);\n\n        if (components == N) {\n            colors[v] = colors[u];\n        }\n    }\n\n    return colors;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 18:50:16",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/F",
    "title": "F. Sphnix",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "F",
    "submission_id": "314992798",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\n// Function provided by the problem to perform experiments\nint perform_experiment(std::vector<int> E);\n\n// Function to find the colours of the vertices\nstd::vector<int> find_colours(int N, std::vector<int> X, std::vector<int> Y) {\n    // Step 1: Initialize variables\n    std::vector<int> result(N, -1); // Result array to store the colours of vertices\n    std::vector<int> recolour(N, -1); // Recolour array for experiments\n    std::unordered_map<int, int> colour_map; // Map to store unique colour IDs\n    int next_colour_id = 0; // Counter for assigning unique colours\n\n    // Step 2: Determine equivalence classes of vertex colours\n    for (int i = 0; i < N; ++i) {\n        // Recolour vertex i with the Sphinx's colour (N)\n        std::fill(recolour.begin(), recolour.end(), -1);\n        recolour[i] = N;\n\n        // Perform the recolouring experiment\n        int components = perform_experiment(recolour);\n\n        // If this is the first vertex being processed, assign it a new colour\n        if (colour_map.find(components) == colour_map.end()) {\n            colour_map[components] = next_colour_id++;\n        }\n\n        // Assign the colour ID to vertex i\n        result[i] = colour_map[components];\n    }\n\n    // Step 3: Return the result\n    return result;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 18:51:01",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/F",
    "title": "F. Sphnix",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "F",
    "submission_id": "314992864",
    "code_index": 4,
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n\n// External function provided by the grader to perform recoloring experiments\nint perform_experiment(std::vector<int> E);\n\n// Function to find the colors of the vertices in the graph\nstd::vector<int> find_colours(int N, std::vector<int> X, std::vector<int> Y) {\n    // Result vector to store the deduced colors of the vertices\n    std::vector<int> colors(N, -1);\n\n    // Step 1: Identify unique colors using a full recoloring experiment\n    // Recolor all vertices to the special Sphinx's color (N)\n    std::vector<int> experiment(N, N);\n    int total_components = perform_experiment(experiment);\n\n    // Step 2: Deduce the color of each vertex\n    for (int i = 0; i < N; ++i) {\n        // Recolor only vertex i to the Sphinx's color\n        std::vector<int> recolor(N, -1);\n        recolor[i] = N;\n\n        // Perform the experiment and check the number of monochromatic components\n        int components = perform_experiment(recolor);\n\n        // If the number of components decreases, this vertex has a unique color\n        if (components < total_components) {\n            colors[i] = i; // Assign a unique color to this vertex\n        }\n    }\n\n    // Step 3: Propagate colors for adjacent vertices\n    // Use BFS to propagate colors based on adjacency and monochromatic components\n    std::vector<std::vector<int>> adj(N);\n    for (int i = 0; i < X.size(); ++i) {\n        adj[X[i]].push_back(Y[i]);\n        adj[Y[i]].push_back(X[i]);\n    }\n\n    std::vector<bool> visited(N, false);\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i] && colors[i] != -1) {\n            // Perform BFS to propagate the color of vertex i\n            std::queue<int> q;\n            q.push(i);\n            visited[i] = true;\n\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n\n                for (int v : adj[u]) {\n                    if (!visited[v]) {\n                        // Recolor vertex v to the same color as u\n                        std::vector<int> recolor(N, -1);\n                        recolor[u] = colors[u];\n                        recolor[v] = colors[u];\n\n                        // Perform the experiment to confirm if u and v are in the same component\n                        int components = perform_experiment(recolor);\n\n                        if (components == total_components) {\n                            colors[v] = colors[u];\n                            visited[v] = true;\n                            q.push(v);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Step 4: Assign unique colors to uncolored vertices\n    for (int i = 0; i < N; ++i) {\n        if (colors[i] == -1) {\n            colors[i] = i; // Assign a unique color\n        }\n    }\n\n    return colors;\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:52:03",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A2",
    "title": "A2. Pebbling odometer - subtask 2",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A2",
    "submission_id": "314992962",
    "code_index": 0,
    "code": "odometer\n# Move to cell (0, 1) to compare the number of pebbles\nright\nmove\n\n# Compare pebbles\ncompare_pebbles:\npebble cell_0_1 # If cell (0, 1) has pebbles, jump to cell_0_1\nborder cell_0_0 # If no pebbles in cell (0, 1), jump to cell_0_0\nget # Remove one pebble from cell (0, 1)\nleft\nmove\nput # Add one pebble to cell (0, 0)\nright\nmove\njump compare_pebbles\n\n# If x ≤ y, return to cell (0, 0)\ncell_0_0:\nleft\nmove\nhalt\n\n# If x > y, remain in cell (0, 1)\ncell_0_1:\nhalt"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:52:53",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A2",
    "title": "A2. Pebbling odometer - subtask 2",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A2",
    "submission_id": "314993038",
    "code_index": 1,
    "code": "plaintext\n# Start in cell (0, 0)\nright\nmove # Move to cell (0, 1)\n\ncompare_pebbles:\nget\npebble greater_than_or_equal\nput\njump end_comparison\n\ngreater_than_or_equal:\nleft\nmove # Move back to cell (0, 0)\nhalt\n\nend_comparison:\nright\nmove # Move to cell (0, 1)\nhalt"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:53:40",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A2",
    "title": "A2. Pebbling odometer - subtask 2",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A2",
    "submission_id": "314993038",
    "code_index": 2,
    "code": "plaintext\n# Move to cell (0, 1)\nright\nmove\n# Compare pebbles in (0, 0) and (0, 1)\ncompare:\npebble greater # If (0, 1) has pebbles, jump to greater\nleft\nmove\nhalt\ngreater:\nget\nleft\nmove\nput\nright\nmove\njump compare"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:54:21",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A2",
    "title": "A2. Pebbling odometer - subtask 2",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A2",
    "submission_id": "314993182",
    "code_index": 3,
    "code": "odometer\n# Move to cell (0, 1) to compare pebbles\nright\nmove\n\n# Loop to compare pebbles\ncompare:\npebble greater  # If there is a pebble in (0, 1), check next\nget             # Remove one pebble from (0, 1)\nleft\nmove\nput             # Add one pebble to (0, 0)\nright\nmove\njump compare    # Repeat the comparison\n\n# Label when pebbles in (0, 1) are exhausted\ngreater:\nleft\nmove\nhalt            # Halt at cell (0, 0)"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:55:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A2",
    "title": "A2. Pebbling odometer - subtask 2",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A2",
    "submission_id": "314993265",
    "code_index": 4,
    "code": "odometer\n# Move to cell (0, 1)\nright\nmove\n\n# Compare pebbles in (0, 1) with (0, 0)\n# If cell (0, 1) has fewer pebbles, jump back to (0, 0)\ncompare:\nget\nleft\nmove\nput\nright\nmove\npebble less_than_or_equal # If cell (0, 1) has pebbles remaining, jump to less_than_or_equal\njump greater # Otherwise, jump to greater\n\n# Handle the case where x <= y\nless_than_or_equal:\nleft\nmove\nright\nhalt\n\n# Handle the case where x > y\ngreater:\nleft\nmove\nright\nhalt"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 18:56:05",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/E",
    "title": "E. Unscrambling a Messy Bug",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "E",
    "submission_id": "314993371",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n// Function prototypes for the grader-provided functions\nvoid add_element(std::string x);\nvoid compile_set();\nbool check_element(std::string x);\n\nstd::vector<int> restore_permutation(int n, int w, int r) {\n    std::vector<int> permutation(n);\n\n    // Step 1: Add elements to the data structure\n    // Add elements of the form \"000...01\", \"000...10\", ..., \"100...00\"\n    // These are single-bit elements to test the mapping of each bit.\n    for (int i = 0; i < n; ++i) {\n        std::string binary_representation(n, '0');\n        binary_representation[i] = '1';  // Set the ith bit\n        add_element(binary_representation);\n    }\n\n    // Step 2: Call compile_set() to trigger the bug\n    compile_set();\n\n    // Step 3: Determine the permutation by querying the modified set\n    for (int i = 0; i < n; ++i) {\n        std::string original_binary(n, '0');\n        original_binary[i] = '1';  // Query the ith single-bit element\n\n        for (int j = 0; j < n; ++j) {\n            std::string modified_binary(n, '0');\n            modified_binary[j] = '1';  // Check if the single-bit moved to position j\n\n            if (check_element(modified_binary)) {\n                permutation[i] = j;  // Original position i maps to position j\n                break;\n            }\n        }\n    }\n\n    return permutation;\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 18:56:49",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/E",
    "title": "E. Unscrambling a Messy Bug",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "E",
    "submission_id": "314993371",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n// Library functions provided by the problem\nvoid add_element(string x);\nvoid compile_set();\nbool check_element(string x);\n\nvector<int> restore_permutation(int n, int w, int r) {\n    vector<int> permutation(n);\n    \n    // Step 1: Add elements with a single bit set\n    for (int i = 0; i < n; i++) {\n        string binary_representation(n, '0');\n        binary_representation[i] = '1';\n        add_element(binary_representation);\n    }\n    \n    // Step 2: Call compile_set to trigger the bug\n    compile_set();\n    \n    // Step 3: Determine the permutation by checking elements\n    for (int i = 0; i < n; i++) {\n        string binary_representation(n, '0');\n        binary_representation[i] = '1';\n        \n        // Check which position this bit is mapped to\n        for (int j = 0; j < n; j++) {\n            string query(n, '0');\n            query[j] = '1';\n            if (check_element(query)) {\n                permutation[j] = i;\n                break;\n            }\n        }\n    }\n    \n    // Step 4: Return the determined permutation\n    return permutation;\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 18:57:32",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/E",
    "title": "E. Unscrambling a Messy Bug",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "E",
    "submission_id": "314993504",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n\n// Provided grader functions\nvoid add_element(std::string x);\nvoid compile_set();\nbool check_element(std::string x);\n\nstd::vector<int> restore_permutation(int n, int w, int r) {\n    std::vector<int> permutation(n);\n\n    // Step 1: Add elements where only one bit is set to 1\n    for (int i = 0; i < n; ++i) {\n        std::string binary(n, '0');\n        binary[i] = '1';\n        add_element(binary);\n    }\n\n    // Step 2: Call compile_set() to trigger the bug\n    compile_set();\n\n    // Step 3: Determine the permutation using check_element\n    for (int i = 0; i < n; ++i) {\n        std::string binary(n, '0');\n        binary[i] = '1'; // Original binary with only the i-th bit set\n        for (int j = 0; j < n; ++j) {\n            std::string test_binary(n, '0');\n            test_binary[j] = '1'; // Test for the j-th bit in the modified set\n            if (check_element(test_binary)) {\n                permutation[i] = j; // The i-th bit was moved to the j-th position\n                break;\n            }\n        }\n    }\n\n    // Step 4: Return the reconstructed permutation\n    return permutation;\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 18:58:15",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/E",
    "title": "E. Unscrambling a Messy Bug",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "E",
    "submission_id": "314993563",
    "code_index": 3,
    "code": "// Necessary headers\n#include <vector>\n#include <string>\n#include <bitset>\n\n// Library functions provided by the grader\nvoid add_element(std::string x);\nvoid compile_set();\nbool check_element(std::string x);\n\n// Your code will be placed here\nstd::vector<int> restore_permutation(int n, int w, int r) {\n    std::vector<std::string> elements(n);\n    std::vector<int> permutation(n);\n\n    // Step 1: Generate all n-bit binary strings where only one bit is set\n    for (int i = 0; i < n; ++i) {\n        std::string binary_string(n, '0');\n        binary_string[i] = '1';\n        elements[i] = binary_string;\n        add_element(binary_string);\n    }\n\n    // Step 2: Call compile_set to trigger the buggy reordering\n    compile_set();\n\n    // Step 3: Check which binary strings are present in the modified set\n    for (int i = 0; i < n; ++i) {\n        std::string binary_string = elements[i];\n        for (int j = 0; j < n; ++j) {\n            std::string reordered_string(n, '0');\n            reordered_string[j] = '1';\n            if (check_element(reordered_string)) {\n                permutation[j] = i;\n                break;\n            }\n        }\n    }\n\n    return permutation;\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 18:58:55",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/E",
    "title": "E. Unscrambling a Messy Bug",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "E",
    "submission_id": "314993628",
    "code_index": 4,
    "code": "#include <vector>\n#include <string>\n#include <cmath>\n#include <bitset>\n\n// Function prototypes for the provided grader functions\nvoid add_element(std::string x);\nvoid compile_set();\nbool check_element(std::string x);\n\n// Your code will be placed here\nstd::vector<int> restore_permutation(int n, int w, int r) {\n    std::vector<std::string> initial_elements(n);\n    std::vector<int> permutation(n);\n\n    // Step 1: Add elements to the data structure\n    // Add binary strings where only one bit is set at a time\n    // For example, for n = 4: \"0001\", \"0010\", \"0100\", \"1000\"\n    for (int i = 0; i < n; ++i) {\n        std::string binary_string(n, '0');\n        binary_string[i] = '1';\n        initial_elements[i] = binary_string;\n        add_element(binary_string);\n    }\n\n    // Step 2: Call compile_set() to trigger the bug\n    compile_set();\n\n    // Step 3: Query the modified set using check_element()\n    // Check where each of the original elements ended up\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            std::string binary_string(n, '0');\n            binary_string[j] = '1';\n            if (check_element(binary_string)) {\n                permutation[j] = i;\n                break;\n            }\n        }\n    }\n\n    return permutation;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 18:59:53",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/F",
    "title": "F. Thousands Islands",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "F",
    "submission_id": "314992131",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n\nusing namespace std;\n\nunion(bool, vector<int>) find_journey(int N, int M, vector<int> U, vector<int> V) {\n    // Graph representation\n    vector<vector<pair<int, int>>> adj(N); // adj[node] = list of {neighbor, canoe_id}\n    vector<int> degree(N, 0); // degree of each node\n    vector<bool> used(M, false); // track if a canoe is used\n\n    // Build the graph\n    for (int i = 0; i < M; ++i) {\n        adj[U[i]].emplace_back(V[i], i);\n        adj[V[i]].emplace_back(U[i], i);\n        degree[U[i]]++;\n        degree[V[i]]++;\n    }\n\n    // Check if the graph satisfies Eulerian circuit conditions\n    for (int i = 0; i < N; ++i) {\n        if (degree[i] % 2 != 0) {\n            return false; // A node with odd degree means no Eulerian circuit\n        }\n    }\n\n    // Hierholzer's algorithm for finding an Eulerian circuit\n    vector<int> journey;\n    stack<int> st;\n    st.push(0); // Start from node 0\n\n    while (!st.empty()) {\n        int u = st.top();\n        bool found = false;\n\n        // Traverse edges from node u\n        while (!adj[u].empty()) {\n            auto [v, canoe_id] = adj[u].back();\n            adj[u].pop_back(); // Remove the edge from adjacency list\n\n            if (!used[canoe_id]) {\n                used[canoe_id] = true; // Mark the canoe as used\n                st.push(v); // Continue from the next node\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            // Backtrack and add the node to the journey\n            st.pop();\n            if (!st.empty()) {\n                journey.push_back(canoe_id);\n            }\n        }\n    }\n\n    // Check if we have a valid journey\n    if (journey.size() > 2'000'000 || journey.empty()) {\n        return false;\n    }\n    return journey;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 19:00:39",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/F",
    "title": "F. Thousands Islands",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "F",
    "submission_id": "314993816",
    "code_index": 1,
    "code": "#include <vector>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n// Your code will be placed here\nvector<int> find_journey(int N, int M, vector<int> U, vector<int> V) {\n    // Step 1: Build the graph\n    vector<vector<pair<int, int>>> adj(N); // adjacency list: {neighbor, edge_id}\n    vector<int> degree(N, 0);\n    for (int i = 0; i < M; ++i) {\n        adj[U[i]].emplace_back(V[i], i);\n        adj[V[i]].emplace_back(U[i], i);\n        degree[U[i]]++;\n        degree[V[i]]++;\n    }\n\n    // Step 2: Check Eulerian circuit conditions\n    for (int i = 0; i < N; ++i) {\n        if (degree[i] % 2 != 0) {\n            return {}; // No Eulerian circuit if any vertex has an odd degree\n        }\n    }\n\n    // Check connectivity (only consider nodes with degree > 0)\n    vector<bool> visited(N, false);\n    stack<int> dfs_stack;\n    int start_node = 0;\n    while (start_node < N && degree[start_node] == 0) {\n        ++start_node;\n    }\n    if (start_node == N) {\n        return {}; // No valid journey if there are no edges\n    }\n    dfs_stack.push(start_node);\n    while (!dfs_stack.empty()) {\n        int node = dfs_stack.top();\n        dfs_stack.pop();\n        if (visited[node]) continue;\n        visited[node] = true;\n        for (const auto& [neighbor, edge_id] : adj[node]) {\n            if (!visited[neighbor]) {\n                dfs_stack.push(neighbor);\n            }\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        if (degree[i] > 0 && !visited[i]) {\n            return {}; // Graph is not connected\n        }\n    }\n\n    // Step 3: Find Eulerian circuit using Hierholzer's algorithm\n    vector<int> circuit;\n    stack<int> current_path;\n    vector<bool> used(M, false);\n    unordered_map<int, int> edge_index; // Tracks the next unused edge for each node\n    current_path.push(start_node);\n\n    while (!current_path.empty()) {\n        int node = current_path.top();\n        bool found_edge = false;\n        while (edge_index[node] < adj[node].size()) {\n            auto [neighbor, edge_id] = adj[node][edge_index[node]++];\n            if (!used[edge_id]) {\n                used[edge_id] = true;\n                current_path.push(neighbor);\n                found_edge = true;\n                break;\n            }\n        }\n        if (!found_edge) {\n            circuit.push_back(node);\n            current_path.pop();\n        }\n    }\n\n    // Step 4: Convert circuit to canoe usage sequence\n    vector<int> journey;\n    unordered_set<int> last_used_canoe;\n    for (int i = 1; i < circuit.size(); ++i) {\n        int u = circuit[i - 1];\n        int v = circuit[i];\n        for (const auto& [neighbor, edge_id] : adj[u]) {\n            if (neighbor == v && !used[edge_id]) {\n                used[edge_id] = true;\n                journey.push_back(edge_id);\n                break;\n            }\n        }\n    }\n\n    // Step 5: Validate the journey length\n    if (journey.size() > 2000000) {\n        return {};\n    }\n\n    return journey;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 19:01:22",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/F",
    "title": "F. Thousands Islands",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "F",
    "submission_id": "314993816",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nunion(bool, vector<int>) find_journey(int N, int M, vector<int> U, vector<int> V) {\n    // Step 1: Construct the graph representation\n    vector<vector<pair<int, int>>> adj(N); // adjacency list (island -> [(neighbor, canoe_index)])\n    vector<int> degree(N, 0); // degree of each island\n    for (int i = 0; i < M; ++i) {\n        adj[U[i]].emplace_back(V[i], i);\n        adj[V[i]].emplace_back(U[i], i);\n        degree[U[i]]++;\n        degree[V[i]]++;\n    }\n\n    // Step 2: Check if Eulerian cycle conditions are satisfied\n    for (int i = 0; i < N; ++i) {\n        if (degree[i] % 2 != 0) {\n            return false; // A vertex with odd degree exists, no Eulerian cycle\n        }\n    }\n\n    // Step 3: Hierholzer's Algorithm to find Eulerian cycle\n    vector<int> journey; // Stores the sequence of canoe indices used\n    vector<bool> used(M, false); // Tracks whether a canoe has been used\n    stack<int> stack; // Stack for DFS traversal\n    unordered_map<int, int> edge_map; // Tracks current edge index in adjacency list for each island\n\n    stack.push(0); // Start from island 0\n    while (!stack.empty()) {\n        int u = stack.top();\n        while (edge_map[u] < adj[u].size() && used[adj[u][edge_map[u]].second]) {\n            edge_map[u]++; // Skip already used edges\n        }\n        if (edge_map[u] < adj[u].size()) {\n            // Traverse an unused edge\n            int v = adj[u][edge_map[u]].first;\n            int canoe_index = adj[u][edge_map[u]].second;\n            used[canoe_index] = true; // Mark canoe as used\n            stack.push(v); // Move to the next island\n            journey.push_back(canoe_index); // Record the canoe index\n        } else {\n            // Backtrack\n            stack.pop();\n        }\n    }\n\n    // Step 4: Validate the journey\n    if (journey.size() > 2000000 || journey.empty()) {\n        return true; // Partial score\n    }\n    return journey;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 19:02:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/F",
    "title": "F. Thousands Islands",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "F",
    "submission_id": "314993895",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\nunion find_journey(int N, int M, vector<int> U, vector<int> V) {\n    // Adjacency list representation for the graph\n    vector<vector<pair<int, int>>> adj(N); // {neighbor, canoe_index}\n    vector<int> degree(N, 0); // Degree of each node\n    \n    // Build the graph\n    for (int i = 0; i < M; ++i) {\n        adj[U[i]].emplace_back(V[i], i);\n        adj[V[i]].emplace_back(U[i], i);\n        degree[U[i]]++;\n        degree[V[i]]++;\n    }\n\n    // Check if all nodes with edges have even degree\n    for (int i = 0; i < N; ++i) {\n        if (degree[i] % 2 != 0) {\n            return false; // Not Eulerian\n        }\n    }\n\n    // Check if the graph is connected (ignoring edge directions)\n    vector<bool> visited(N, false);\n    stack<int> dfs_stack;\n    int start_node = 0;\n    for (; start_node < N; ++start_node) {\n        if (!adj[start_node].empty()) break; // Find a node with at least one edge\n    }\n    if (start_node == N) return false; // No edges in the graph\n\n    dfs_stack.push(start_node);\n    while (!dfs_stack.empty()) {\n        int node = dfs_stack.top();\n        dfs_stack.pop();\n        if (visited[node]) continue;\n        visited[node] = true;\n        for (auto& [neighbor, _] : adj[node]) {\n            if (!visited[neighbor]) {\n                dfs_stack.push(neighbor);\n            }\n        }\n    }\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i] && !adj[i].empty()) {\n            return false; // Graph is not connected\n        }\n    }\n\n    // Use Hierholzer's algorithm to find the Eulerian circuit\n    vector<int> result;\n    vector<bool> used(M, false);\n    stack<int> circuit;\n    circuit.push(0);\n\n    while (!circuit.empty()) {\n        int node = circuit.top();\n        bool found = false;\n        while (!adj[node].empty()) {\n            auto [neighbor, canoe_index] = adj[node].back();\n            adj[node].pop_back();\n            if (!used[canoe_index]) {\n                used[canoe_index] = true;\n                circuit.push(neighbor);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            result.push_back(circuit.top());\n            circuit.pop();\n        }\n    }\n\n    // Remove the last node (we only need the canoe indices)\n    result.pop_back();\n\n    // Verify the result length and transform node traversal into canoe indices\n    vector<int> journey;\n    for (int i = 0; i < result.size() - 1; ++i) {\n        int from = result[i];\n        int to = result[i + 1];\n        for (auto& [neighbor, canoe_index] : adj[from]) {\n            if (neighbor == to && !used[canoe_index]) {\n                journey.push_back(canoe_index);\n                used[canoe_index] = true;\n                break;\n            }\n        }\n    }\n\n    if (journey.size() > 2000000) return true; // Partial score for exceeding limit\n    return journey;\n}"
  },
  {
    "date": "IOI 2022 day 2",
    "timestamp": "2025-04-11 19:02:48",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103880/problem/F",
    "title": "F. Thousands Islands",
    "group_id": "32KGsXgiKA",
    "contest_id": "103880",
    "problem_index": "F",
    "submission_id": "314994035",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <stack>\n#include <utility>\n\nusing namespace std;\n\nunion(bool, vector<int>) find_journey(int N, int M, vector<int> U, vector<int> V) {\n    // Graph representation: adjacency list\n    vector<vector<pair<int, int>>> adj(N); // adj[node] = { {neighbor, edge_index}, ... }\n    vector<int> degree(N, 0);             // Degree of each node\n    vector<bool> visited(M, false);       // Tracks visited edges\n\n    // Build the graph\n    for (int i = 0; i < M; ++i) {\n        adj[U[i]].emplace_back(V[i], i);\n        adj[V[i]].emplace_back(U[i], i);\n        degree[U[i]]++;\n        degree[V[i]]++;\n    }\n\n    // Check if the graph satisfies Eulerian circuit conditions\n    for (int i = 0; i < N; ++i) {\n        if (degree[i] % 2 != 0) {\n            return false; // A vertex has odd degree\n        }\n    }\n\n    // Hierholzer's Algorithm to find Eulerian circuit\n    vector<int> result; // Store the journey (sequence of edge indices)\n    stack<int> stack;   // Stack for DFS traversal\n    unordered_map<int, int> edge_count; // Tracks how many times an edge has been used\n\n    // Start from node 0\n    stack.push(0);\n\n    while (!stack.empty()) {\n        int node = stack.top();\n\n        // Check if the current node has unused edges\n        bool found_unvisited_edge = false;\n        while (!adj[node].empty()) {\n            auto [neighbor, edge_index] = adj[node].back();\n            adj[node].pop_back(); // Remove the edge from adjacency list\n\n            if (visited[edge_index]) continue; // Skip if the edge is already used\n\n            // Use the edge\n            visited[edge_index] = true;\n            stack.push(neighbor); // Move to the neighbor\n            result.push_back(edge_index); // Record the edge used\n            found_unvisited_edge = true;\n            break;\n        }\n\n        // If no unused edge is found, backtrack\n        if (!found_unvisited_edge) {\n            stack.pop();\n        }\n    }\n\n    // Verify if all edges have been used exactly twice\n    if (result.size() != M * 2) {\n        return false;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 19:03:36",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/C",
    "title": "C. Tree",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "C",
    "submission_id": "314994129",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\nvector<vector<int>> tree;\nvector<int> weights;\nvector<int> start, end, euler;\nvector<long long> fenwick;\nint timer;\n\nvoid dfs(int node) {\n    start[node] = timer++;\n    euler.push_back(node);\n    for (int child : tree[node]) {\n        dfs(child);\n    }\n    end[node] = timer - 1;\n}\n\nvoid fenwick_update(int idx, long long delta, int n) {\n    while (idx < n) {\n        fenwick[idx] += delta;\n        idx += idx & -idx;\n    }\n}\n\nlong long fenwick_query(int idx) {\n    long long sum = 0;\n    while (idx > 0) {\n        sum += fenwick[idx];\n        idx -= idx & -idx;\n    }\n    return sum;\n}\n\nlong long fenwick_range_query(int l, int r) {\n    return fenwick_query(r) - fenwick_query(l - 1);\n}\n\nvoid init(vector<int> P, vector<int> W) {\n    int n = P.size();\n    tree.assign(n, vector<int>());\n    weights = W;\n    start.resize(n);\n    end.resize(n);\n    euler.clear();\n    timer = 1;\n\n    for (int i = 1; i < n; ++i) {\n        tree[P[i]].push_back(i);\n    }\n\n    dfs(0);\n\n    fenwick.assign(n + 1, 0);\n}\n\nlong long query(int L, int R) {\n    int n = weights.size();\n    long long total_cost = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int node = euler[i];\n        int subtree_sum = fenwick_range_query(start[node] + 1, end[node] + 1);\n        int required = max(L - subtree_sum, 0);\n        int excess = max(subtree_sum - R, 0);\n\n        if (required > 0) {\n            fenwick_update(start[node] + 1, required, n + 1);\n            fenwick_update(end[node] + 2, -required, n + 1);\n            total_cost += 1LL * required * weights[node];\n        } else if (excess > 0) {\n            fenwick_update(start[node] + 1, -excess, n + 1);\n            fenwick_update(end[node] + 2, excess, n + 1);\n            total_cost += 1LL * excess * weights[node];\n        }\n    }\n\n    return total_cost;\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 19:04:21",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/C",
    "title": "C. Tree",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "C",
    "submission_id": "314994129",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n// Global variables to store tree structure and weights\nvector<int> parent, weight;\nvector<vector<int>> children;\nvector<long long> subtree_sum;\n\n// Function to initialize the tree structure and weights\nvoid init(vector<int> P, vector<int> W) {\n    int N = W.size();\n    parent = P;\n    weight = W;\n    children.resize(N);\n    subtree_sum.resize(N, 0);\n\n    // Build the tree structure\n    for (int i = 1; i < N; ++i) {\n        children[P[i]].push_back(i);\n    }\n\n    // Calculate subtree sums using DFS\n    function<void(int)> dfs = [&](int node) {\n        subtree_sum[node] = weight[node];\n        for (int child : children[node]) {\n            dfs(child);\n            subtree_sum[node] += subtree_sum[child];\n        }\n    };\n    dfs(0); // Start DFS from the root (node 0)\n}\n\n// Function to handle a query and compute the minimum total cost\nlong long query(int L, int R) {\n    int N = weight.size();\n    vector<long long> min_cost(N, 0);\n\n    // Compute minimum cost for each node using DFS\n    function<void(int)> dfs = [&](int node) {\n        long long child_sum = 0;\n        for (int child : children[node]) {\n            dfs(child);\n            child_sum += min_cost[child];\n        }\n\n        // Determine the coefficient for the current node\n        long long required_sum = subtree_sum[node];\n        long long coefficient = max(0LL, L - child_sum);\n\n        if (child_sum + coefficient > R) {\n            coefficient = R - child_sum;\n        }\n\n        min_cost[node] = abs(coefficient) * weight[node] + child_sum;\n    };\n    dfs(0); // Start DFS from the root\n\n    return min_cost[0];\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 19:05:07",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/C",
    "title": "C. Tree",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "C",
    "submission_id": "314994201",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\nusing namespace std;\n\nvector<int> parent;\nvector<int> weight;\nvector<vector<int>> tree;\nvector<long long> subtreeWeight;\n\nvoid dfsSubtreeWeight(int node) {\n    subtreeWeight[node] = weight[node];\n    for (int child : tree[node]) {\n        dfsSubtreeWeight(child);\n        subtreeWeight[node] += subtreeWeight[child];\n    }\n}\n\nvoid init(vector<int> P, vector<int> W) {\n    int N = P.size();\n    parent = P;\n    weight = W;\n    tree.assign(N, vector<int>());\n    subtreeWeight.assign(N, 0);\n    \n    // Build the tree using parent array\n    for (int i = 1; i < N; ++i) {\n        tree[P[i]].push_back(i);\n    }\n    \n    // Compute subtree weights\n    dfsSubtreeWeight(0);\n}\n\nlong long dfsQuery(int node, int L, int R, long long& cost) {\n    long long required = L;  // Start with the minimum required sum\n    for (int child : tree[node]) {\n        required += dfsQuery(child, L, R, cost);\n    }\n    \n    // Enforce the constraints: L <= required <= R\n    long long assigned = max(L, min(required, (long long)R));\n    cost += abs(assigned - required) * weight[node];\n    return assigned;\n}\n\nlong long query(int L, int R) {\n    long long cost = 0;\n    dfsQuery(0, L, R, cost);\n    return cost;\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 19:05:51",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/C",
    "title": "C. Tree",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "C",
    "submission_id": "314994309",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <limits>\n\nusing namespace std;\n\n// Global variables to store tree structure and weights\nvector<int> parent;  // Parent array\nvector<int> weight;  // Weight array\nvector<vector<int>> tree;  // Adjacency list for the tree\nvector<long long> subtree_weight;  // Subtree weight sums\nvector<int> euler_tour;  // Euler tour of the tree\nvector<int> start_time, end_time;  // Start and end times in the Euler tour\nint timer;\n\n// Precomputes necessary data for the tree\nvoid dfs(int node) {\n    start_time[node] = timer++;\n    euler_tour.push_back(node);\n    subtree_weight[node] = weight[node];\n    for (int child : tree[node]) {\n        dfs(child);\n        subtree_weight[node] += subtree_weight[child];\n    }\n    end_time[node] = timer;\n}\n\nvoid init(vector<int> P, vector<int> W) {\n    int N = P.size();\n    parent = P;\n    weight = W;\n    tree.assign(N, vector<int>());\n    subtree_weight.assign(N, 0);\n    start_time.assign(N, 0);\n    end_time.assign(N, 0);\n    euler_tour.clear();\n    timer = 0;\n\n    // Build the tree from the parent array\n    for (int i = 1; i < N; ++i) {\n        tree[P[i]].push_back(i);\n    }\n\n    // Perform DFS to compute subtree weights and Euler tour\n    dfs(0);\n}\n\nlong long query(int L, int R) {\n    int N = parent.size();\n    // Initialize the total cost\n    long long total_cost = 0;\n\n    // Traverse the nodes in the Euler tour order\n    for (int node : euler_tour) {\n        // Compute the minimum coefficient for the node\n        long long min_coeff = max(0, L - (int)subtree_weight[node]);\n        long long max_coeff = min((long long)R, subtree_weight[node]);\n\n        // Optimal coefficient is the one that minimizes cost\n        long long coeff = min_coeff;\n        total_cost += coeff * weight[node];\n\n        // Update the subtree weight to reflect the coefficient\n        subtree_weight[node] -= coeff;\n    }\n\n    return total_cost;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 19:06:39",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/B",
    "title": "B. Prisoner Challenge",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "B",
    "submission_id": "314982937",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> devise_strategy(int N) {\n    // We will use a simple alternating strategy with two states: 0 and 1.\n    // The whiteboard value alternates between 0 and 1 to ensure that prisoners inspect both bags.\n    // This strategy guarantees correctness with minimal x (x = 1).\n\n    // Strategy array: s[0] for whiteboard state 0, s[1] for whiteboard state 1.\n    vector<vector<int>> s(2, vector<int>(N + 1));\n\n    // For state 0, inspect Bag A (s[0][0] = 0)\n    s[0][0] = 0;  // Inspect Bag A\n    for (int j = 1; j <= N; ++j) {\n        if (j == 1) {\n            s[0][j] = -1;  // Identify Bag A as the bag with fewer coins\n        } else if (j == N) {\n            s[0][j] = -2;  // Identify Bag B as the bag with fewer coins\n        } else {\n            s[0][j] = 1;   // Write 1 on the whiteboard\n        }\n    }\n\n    // For state 1, inspect Bag B (s[1][0] = 1)\n    s[1][0] = 1;  // Inspect Bag B\n    for (int j = 1; j <= N; ++j) {\n        if (j == 1) {\n            s[1][j] = -2;  // Identify Bag B as the bag with fewer coins\n        } else if (j == N) {\n            s[1][j] = -1;  // Identify Bag A as the bag with fewer coins\n        } else {\n            s[1][j] = 0;   // Write 0 on the whiteboard\n        }\n    }\n\n    return s;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 19:07:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/B",
    "title": "B. Prisoner Challenge",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "B",
    "submission_id": "314994464",
    "code_index": 1,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvector<vector<int>> devise_strategy(int N) {\n    int x = 1;  // We'll use two states: 0 and 1\n    vector<vector<int>> strategy(x + 1, vector<int>(N + 1, 0));\n\n    // State 0: Inspect bag A\n    strategy[0][0] = 0;  // Inspect bag A\n    for (int j = 1; j <= N; ++j) {\n        if (j == 1) {\n            strategy[0][j] = -1;  // Bag A has fewer coins\n        } else if (j == N) {\n            strategy[0][j] = -2;  // Bag B has fewer coins\n        } else {\n            strategy[0][j] = 1;  // Write 1 on the whiteboard\n        }\n    }\n\n    // State 1: Inspect bag B\n    strategy[1][0] = 1;  // Inspect bag B\n    for (int j = 1; j <= N; ++j) {\n        if (j == 1) {\n            strategy[1][j] = -2;  // Bag B has fewer coins\n        } else if (j == N) {\n            strategy[1][j] = -1;  // Bag A has fewer coins\n        } else {\n            strategy[1][j] = 0;  // Write 0 on the whiteboard\n        }\n    }\n\n    return strategy;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 19:08:03",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/B",
    "title": "B. Prisoner Challenge",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "B",
    "submission_id": "314994464",
    "code_index": 2,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvector<vector<int>> devise_strategy(int N) {\n    // Define the maximum value of x (number of states)\n    int x = 1;  // We will use two states: 0 and 1\n    vector<vector<int>> strategy(x + 1, vector<int>(N + 1));\n\n    // Strategy for state 0\n    strategy[0][0] = 0;  // If the whiteboard number is 0, inspect bag A\n    for (int j = 1; j <= N; ++j) {\n        if (j == 1) {\n            strategy[0][j] = -1;  // If bag A has 1 coin, bag A has fewer coins\n        } else if (j == N) {\n            strategy[0][j] = -2;  // If bag A has N coins, bag B has fewer coins\n        } else {\n            strategy[0][j] = 1;  // Otherwise, write 1 to transition to state 1\n        }\n    }\n\n    // Strategy for state 1\n    strategy[1][0] = 1;  // If the whiteboard number is 1, inspect bag B\n    for (int j = 1; j <= N; ++j) {\n        if (j == 1) {\n            strategy[1][j] = -2;  // If bag B has 1 coin, bag B has fewer coins\n        } else if (j == N) {\n            strategy[1][j] = -1;  // If bag B has N coins, bag A has fewer coins\n        } else {\n            strategy[1][j] = 0;  // Otherwise, write 0 to transition to state 0\n        }\n    }\n\n    return strategy;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 19:08:44",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/B",
    "title": "B. Prisoner Challenge",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "B",
    "submission_id": "314994522",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> devise_strategy(int N) {\n    // Define the number of states (x + 1 states in total)\n    int x = 2; // We use states 0, 1, and 2 for simplicity.\n    \n    // Initialize the strategy array\n    vector<vector<int>> strategy(x + 1, vector<int>(N + 1, 0));\n    \n    // Strategy for state 0: Inspect bag A\n    strategy[0][0] = 0;  // Inspect bag A\n    for (int j = 1; j <= N; ++j) {\n        if (j == 1) {\n            strategy[0][j] = -1; // Bag A has fewer coins\n        } else if (j == N) {\n            strategy[0][j] = -2; // Bag B has fewer coins\n        } else {\n            strategy[0][j] = 1;  // Move to state 1\n        }\n    }\n    \n    // Strategy for state 1: Inspect bag B\n    strategy[1][0] = 1;  // Inspect bag B\n    for (int j = 1; j <= N; ++j) {\n        if (j == 1) {\n            strategy[1][j] = -2; // Bag B has fewer coins\n        } else if (j == N) {\n            strategy[1][j] = -1; // Bag A has fewer coins\n        } else {\n            strategy[1][j] = 0;  // Move to state 0\n        }\n    }\n    \n    return strategy;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 19:09:28",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/B",
    "title": "B. Prisoner Challenge",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "B",
    "submission_id": "314994606",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> devise_strategy(int N) {\n    // We will use a binary strategy where prisoners alternate between inspecting bag A and bag B,\n    // and the whiteboard value encodes the state of the game.\n\n    int x = 1; // Smallest possible x value for a binary strategy\n    vector<vector<int>> strategy(x + 1, vector<int>(N + 1, 0));\n\n    // Strategy for state 0 (whiteboard value == 0)\n    strategy[0][0] = 0; // Inspect bag A\n    for (int j = 1; j <= N; ++j) {\n        if (j % 2 == 1) {\n            strategy[0][j] = -1; // If bag A contains an odd number of coins, it's the smaller bag\n        } else {\n            strategy[0][j] = 1; // Write 1 to the whiteboard to switch to state 1\n        }\n    }\n\n    // Strategy for state 1 (whiteboard value == 1)\n    strategy[1][0] = 1; // Inspect bag B\n    for (int j = 1; j <= N; ++j) {\n        if (j % 2 == 1) {\n            strategy[1][j] = -2; // If bag B contains an odd number of coins, it's the smaller bag\n        } else {\n            strategy[1][j] = 0; // Write 0 to the whiteboard to switch to state 0\n        }\n    }\n\n    return strategy;\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:10:16",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/F",
    "title": "F. Robot Contest",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "F",
    "submission_id": "314994756",
    "code_index": 0,
    "code": "#include <vector>\n#include <array>\nusing namespace std;\n\n// Your code will be placed here\nvoid program_pulibot() {\n    // Directions corresponding to west (W), south (S), east (E), north (N).\n    const array<int, 4> dx = {0, 1, 0, -1};\n    const array<int, 4> dy = {-1, 0, 1, 0};\n    const char actions[4] = {'W', 'S', 'E', 'N'}; // Corresponding actions.\n\n    // BFS queue with state array and position (r, c).\n    vector<vector<int>> visited(15, vector<int>(15, 0)); // Maximum maze size is 15x15.\n    vector<array<int, 6>> instructions; // Store instructions for BFS traversal.\n\n    // BFS traversal starting from (0, 0).\n    array<int, 6> start_instruction = {0, -2, -2, -2, -2, 0}; // Starting state array.\n    instructions.push_back(start_instruction);\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:10:57",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/F",
    "title": "F. Robot Contest",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "F",
    "submission_id": "314994814",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\n// Directions: West, South, East, North\nconst int dr[4] = {0, 1, 0, -1};\nconst int dc[4] = {-1, 0, 1, 0};\nconst char moves[4] = {'W', 'S', 'E', 'N'};\n\nvoid program_pulibot() {\n    // BFS queue: stores the current cell (r, c) and its state color\n    queue<pair<int, int>> q;\n\n    // Set of visited cells\n    vector<vector<bool>> visited(15, vector<bool>(15, false));\n\n    // Start BFS from (0, 0)\n    visited[0][0] = true;\n    q.push({0, 0});\n\n    // BFS traversal\n    while (!q.empty()) {\n        auto [r, c] = q.front();\n        q.pop();\n\n        // Recognize state array S for the current cell\n        vector<int> S(5, -2);  // Default state is boundary (-2)\n        S[0] = 0;  // Current cell color is initially 0\n\n        for (int d = 0; d < 4; ++d) {\n            int nr = r + dr[d];\n            int nc = c + dc[d];\n            // Check if the neighbor is within bounds and not visited\n            if (nr >= 0 && nr < 15 && nc >= 0 && nc < 15) {\n                S[d + 1] = visited[nr][nc] ? 1 : 0;\n            }\n        }\n\n        // Generate instructions for the current state array\n        for (int d = 0; d < 4; ++d) {\n            int nr = r + dr[d];\n            int nc = c + dc[d];\n\n            if (nr >= 0 && nr < 15 && nc >= 0 && nc < 15 && !visited[nr][nc]) {\n                // Mark the cell as visited\n                visited[nr][nc] = true;\n                q.push({nr, nc});\n\n                // Set instruction to move in the direction `d`\n                set_instruction(S, 1, moves[d]);\n            }\n        }\n\n        // If we reach the bottom-right corner, terminate\n        if (r == 14 && c == 14) {\n            set_instruction(S, 1, 'T');\n            return;\n        }\n    }\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:12:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/F",
    "title": "F. Robot Contest",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "F",
    "submission_id": "314994952",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <array>\n\nusing namespace std;\n\nvoid set_instruction(vector<int> S, int Z, char A);\n\nvoid program_pulibot() {\n    // Directions: West, South, East, North\n    const array<int, 4> dr = {0, 1, 0, -1};\n    const array<int, 4> dc = {-1, 0, 1, 0};\n    const array<char, 4> actions = {'W', 'S', 'E', 'N'};\n    \n    // BFS-based shortest path discovery and instruction generation\n    queue<array<int, 2>> q; // Queue for BFS\n    unordered_map<int, vector<int>> instruction_map; // State array -> instruction mapping\n\n    // Helper to encode a state array as a unique key\n    auto encode_state = [](const vector<int>& S) {\n        int key = 0;\n        for (int i = 0; i < 5; ++i) {\n            key = key * 23 + (S[i] + 2); // Map values to positive domain\n        }\n        return key;\n    };\n\n    // Helper to add an instruction for a state array\n    auto add_instruction = [&](vector<int> S, int Z, char A) {\n        int key = encode_state(S);\n        if (instruction_map.count(key)) return; // Avoid duplicate instructions\n        instruction_map[key] = {Z, A};\n        set_instruction(S, Z, A);\n    };\n\n    // Initialize BFS\n    q.push({0, 0});\n    vector<vector<int>> visited(H, vector<int>(W, 0));\n    visited[0][0] = 1;\n\n    // BFS to explore the maze\n    while (!q.empty()) {\n        auto [r, c] = q.front(); q.pop();\n        int current_color = visited[r][c];\n\n        // Generate state array for the current cell\n        vector<int> state(5, -2); // Default to boundary\n        state[0] = current_color; // Current cell color\n\n        for (int d = 0; d < 4; ++d) {\n            int nr = r + dr[d];\n            int nc = c + dc[d];\n            if (nr >= 0 && nr < H && nc >= 0 && nc < W) {\n                state[d + 1] = visited[nr][nc] ? visited[nr][nc] : -1;\n            }\n        }\n\n        // Add instruction for the current state\n        for (int d = 0; d < 4; ++d) {\n            int nr = r + dr[d];\n            int nc = c + dc[d];\n            if (nr >= 0 && nr < H && nc >= 0 && nc < W && !visited[nr][nc]) {\n                visited[nr][nc] = current_color + 1;\n                q.push({nr, nc});\n                state[d + 1] = 0; // Assume the adjacent cell is empty\n                add_instruction(state, current_color + 1, actions[d]);\n                state[d + 1] = -1; // Restore\n            }\n        }\n\n        // If we've reached the end cell, add termination instruction\n        if (r == H - 1 && c == W - 1) {\n            add_instruction(state, 1, 'T'); // Terminate at the end\n        }\n    }\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 19:13:08",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/F",
    "title": "F. Parrots",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "F",
    "submission_id": "314995057",
    "code_index": 0,
    "code": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\n// Function send(a) will be called by the grader to send encoded integers.\nvoid send(int a);\n\n// Function output(b) will be called by the grader to output decoded integers.\nvoid output(int b);\n\n// Procedure to encode the message\nvoid encode(int N, vector<int> M) {\n    unordered_map<int, int> frequency;\n    \n    // Count the frequency of each number in the message\n    for (int num : M) {\n        frequency[num]++;\n    }\n    \n    // Encode each number and its frequency into a single integer\n    for (auto [num, freq] : frequency) {\n        int encoded_value = num * 256 + freq; // Pack `number` and `frequency`\n        send(encoded_value); // Send the packed integer\n    }\n}\n\n// Procedure to decode the received message\nvoid decode(int N, int L, vector<int> X) {\n    vector<int> decoded_message;\n    \n    // Decode each packed integer\n    for (int packed : X) {\n        int num = packed / 256;       // Extract the number\n        int freq = packed % 256;      // Extract the frequency\n        \n        // Reconstruct the original message\n        for (int i = 0; i < freq; i++) {\n            decoded_message.push_back(num);\n        }\n    }\n    \n    // Output the decoded message in the original order\n    for (int num : decoded_message) {\n        output(num);\n    }\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 19:13:47",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/F",
    "title": "F. Parrots",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "F",
    "submission_id": "314995122",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\n// Function to send encoded values\nvoid send(int a);\n\n// Function to output decoded values\nvoid output(int b);\n\nvoid encode(int N, std::vector<int> M) {\n    // Encoding the message\n    for (int i = 0; i < N; ++i) {\n        // Encode each value with its index\n        int encoded_value = M[i] * (N + 1) + i;\n        send(encoded_value);\n    }\n}\n\nvoid decode(int N, int L, std::vector<int> X) {\n    // Decoding the message\n    std::vector<int> decoded_message(N, 0);\n    for (int i = 0; i < L; ++i) {\n        // Decode the value and index\n        int value = X[i] / (N + 1);\n        int index = X[i] % (N + 1);\n        decoded_message[index] = value;\n    }\n\n    // Output the decoded message\n    for (int i = 0; i < N; ++i) {\n        output(decoded_message[i]);\n    }\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 19:14:27",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/F",
    "title": "F. Parrots",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "F",
    "submission_id": "314995122",
    "code_index": 2,
    "code": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n// Function declaration for the grader's send and output functions\nvoid send(int a);\nvoid output(int b);\n\n// Encode function\nvoid encode(int N, vector<int> M) {\n    // Compute a checksum for the entire message\n    int checksum = accumulate(M.begin(), M.end(), 0) % 256;\n\n    // Send the checksum\n    send(checksum);\n\n    // Send the message itself\n    for (int i = 0; i < N; i++) {\n        send(M[i]);\n    }\n}\n\n// Decode function\nvoid decode(int N, int L, vector<int> X) {\n    // Find the checksum\n    int checksum = -1;\n    vector<int> message;\n\n    // Separate the checksum and the rest of the message\n    for (int x : X) {\n        if (checksum == -1) {\n            checksum = x;\n        } else {\n            message.push_back(x);\n        }\n    }\n\n    // Sort the message to ensure correct order\n    // (We assume no duplicates in the original message)\n    sort(message.begin(), message.end());\n\n    // Output the original message\n    for (int i = 0; i < N; i++) {\n        output(message[i]);\n    }\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 19:15:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/F",
    "title": "F. Parrots",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "F",
    "submission_id": "314995279",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to send an integer to a parrot\nvoid send(int a);\n\n// Function to output an integer from decoding\nvoid output(int b);\n\nvoid encode(int N, vector<int> M) {\n    // Frequency table\n    unordered_map<int, int> frequency;\n    for (int num : M) {\n        frequency[num]++;\n    }\n\n    // Encode the frequency table\n    for (auto [key, value] : frequency) {\n        send(key);   // Send the number\n        send(value); // Send its frequency\n    }\n}\n\nvoid decode(int N, int L, vector<int> X) {\n    // Decode the frequency table\n    unordered_map<int, int> frequency;\n    for (int i = 0; i < L; i += 2) {\n        int key = X[i];\n        int value = X[i + 1];\n        frequency[key] = value;\n    }\n\n    // Reconstruct the original message\n    vector<int> original_message;\n    for (auto [key, value] : frequency) {\n        for (int i = 0; i < value; ++i) {\n            output(key); // Output each number the required number of times\n        }\n    }\n}"
  },
  {
    "date": "IOI 2011 day 2",
    "timestamp": "2025-04-11 19:15:51",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103759/problem/F",
    "title": "F. Parrots",
    "group_id": "32KGsXgiKA",
    "contest_id": "103759",
    "problem_index": "F",
    "submission_id": "314995279",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\n// Forward declarations of required functions\nvoid send(int a);\nvoid output(int b);\n\n// Constants\nconst int MAX_R = 255;\n\n// Function to encode the message\nvoid encode(int N, vector<int> M) {\n    // Step 1: Count the frequency of each number in the message\n    unordered_map<int, int> frequency;\n    for (int i = 0; i < N; i++) {\n        frequency[M[i]]++;\n    }\n\n    // Step 2: Send each unique value and its frequency\n    for (const auto& pair : frequency) {\n        int value = pair.first;\n        int freq = pair.second;\n\n        // Send the value and its frequency\n        send(value);\n        send(freq);\n    }\n}\n\n// Function to decode the message\nvoid decode(int N, int L, vector<int> X) {\n    // Step 1: Reconstruct the frequency map\n    unordered_map<int, int> frequency;\n\n    for (int i = 0; i < L; i += 2) {\n        int value = X[i];\n        int freq = X[i + 1];\n        frequency[value] = freq;\n    }\n\n    // Step 2: Reconstruct the original message\n    vector<int> message;\n    for (const auto& pair : frequency) {\n        int value = pair.first;\n        int freq = pair.second;\n\n        for (int j = 0; j < freq; j++) {\n            message.push_back(value);\n        }\n    }\n\n    // Step 3: Output the original message in order\n    for (int i = 0; i < N; i++) {\n        output(message[i]);\n    }\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 19:16:44",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/F",
    "title": "F. Bit Shift Registers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "F",
    "submission_id": "314995463",
    "code_index": 0,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid construct_instructions(int s, int n, int k, int q) {\n    if (s == 0) {\n        // Task: Find the smallest integer among the inputs\n        append_move(1, 0);  // Copy register 0 to register 1 (working register)\n        \n        for (int i = 1; i < n; ++i) {\n            append_right(2, 1, i * k);  // Extract the i-th integer into register 2\n            append_and(0, 0, 2);        // Update register 0 with the bitwise-AND (minimum)\n        }\n    } else if (s == 1) {\n        // Task: Sort the integers in non-decreasing order\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n - 1; ++j) {\n                // Extract a[j] into register 2\n                append_right(2, 0, j * k);\n                append_and(2, 2, (1 << k) - 1);  // Mask to keep only k bits\n                \n                // Extract a[j+1] into register 3\n                append_right(3, 0, (j + 1) * k);\n                append_and(3, 3, (1 << k) - 1);  // Mask to keep only k bits\n                \n                // Compare and swap if a[j] > a[j+1]\n                append_xor(4, 2, 3);  // XOR to find differing bits\n                append_and(4, 4, 3);  // Keep only differing bits of a[j+1]\n                append_or(2, 2, 4);   // Update a[j] (smaller value)\n                append_xor(3, 3, 4);  // Update a[j+1] (larger value)\n                \n                // Write back the updated values\n                append_left(2, 2, j * k);\n                append_left(3, 3, (j + 1) * k);\n                append_or(0, 0, 2);\n                append_or(0, 0, 3);\n            }\n        }\n    }\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 19:17:22",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/F",
    "title": "F. Bit Shift Registers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "F",
    "submission_id": "314995529",
    "code_index": 1,
    "code": "#include <vector>\n\n// Your code will be placed here\nvoid construct_instructions(int s, int n, int k, int q) {\n    int b = 2000; // Number of bits in a register.\n\n    if (s == 0) {\n        // Task: Find the minimum value among the input integers.\n        // Extract the first integer into register 1 (current minimum).\n        append_move(1, 0); // Copy register 0 to register 1.\n        append_and(1, 1, 1); // Mask out irrelevant bits (just to be safe).\n\n        // Iterate through the remaining integers.\n        for (int i = 1; i < n; ++i) {\n            // Extract the i-th integer into register 2.\n            append_move(2, 0); // Copy register 0 to register 2.\n            append_right(2, 2, i * k); // Shift right to isolate the i-th integer.\n            append_and(2, 2, 2); // Mask out irrelevant bits.\n\n            // Compare the current minimum (register 1) with the new value (register 2).\n            // Use bitwise operations to compute the minimum.\n            append_xor(3, 1, 2); // Compute the XOR of the two values.\n            append_and(3, 3, 2); // Mask out the bits where 2 < 1.\n            append_xor(1, 1, 3); // Update register 1 to hold the minimum.\n        }\n\n        // After the loop, register 1 contains the minimum value.\n        // Move the result back to register 0.\n        append_move(0, 1);\n\n    } else if (s == 1) {\n        // Task: Sort the input integers in non-decreasing order.\n        // Use bubble sort or selection sort to sort the integers.\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                // Extract the i-th and j-th integers.\n                append_move(1, 0); // Copy register 0 to register 1.\n                append_right(1, 1, i * k); // Shift right to isolate the i-th integer.\n                append_and(1, 1, 1); // Mask out irrelevant bits.\n\n                append_move(2, 0); // Copy register 0 to register 2.\n                append_right(2, 2, j * k); // Shift right to isolate the j-th integer.\n                append_and(2, 2, 2); // Mask out irrelevant bits.\n\n                // Compare the two integers.\n                append_xor(3, 1, 2); // Compute the XOR of the two values.\n                append_and(3, 3, 2); // Mask out the bits where 2 < 1.\n                append_xor(1, 1, 3); // Register 1 holds the minimum.\n                append_xor(2, 2, 3); // Register 2 holds the maximum.\n\n                // Swap the two integers if needed.\n                append_store(4, std::vector<bool>(b, 0)); // Temporary register for packing.\n                append_left(4, 4, i * k); // Shift left to pack into the i-th position.\n                append_or(0, 0, 4); // Store the minimum value back into the i-th position.\n\n                append_store(4, std::vector<bool>(b, 0)); // Temporary register for packing.\n                append_left(4, 4, j * k); // Shift left to pack into the j-th position.\n                append_or(0, 0, 4); // Store the maximum value back into the j-th position.\n            }\n        }\n    }\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 19:18:03",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/F",
    "title": "F. Bit Shift Registers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "F",
    "submission_id": "314995529",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nvoid construct_instructions(int s, int n, int k, int q) {\n    if (s == 0) {\n        // Task 1: Find the smallest integer among the input integers\n        // Approach: Use bitwise-AND to compare and reduce the integers into the minimum value.\n        for (int i = 1; i < n; ++i) {\n            // Shift the (i-th integer) into the first k bits of register 1\n            append_move(1, 0);               // Copy register 0 to register 1\n            append_right(1, 1, i * k);       // Shift right by i*k to isolate the i-th integer\n\n            // Compute the bitwise-AND of the current minimum and the i-th integer\n            append_and(0, 0, 1);             // Update register 0 to hold the minimum so far\n        }\n    } else if (s == 1) {\n        // Task 2: Sort the integers in non-decreasing order\n        // Approach: Use a simple bubble sort-like approach to sort the integers in-place.\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n - 1; ++j) {\n                // Isolate the j-th integer in register 1\n                append_move(1, 0);           // Copy register 0 to register 1\n                append_right(1, 1, j * k);   // Shift right by j*k to isolate the j-th integer\n\n                // Isolate the (j+1)-th integer in register 2\n                append_move(2, 0);           // Copy register 0 to register 2\n                append_right(2, 2, (j + 1) * k); // Shift right by (j+1)*k to isolate the (j+1)-th integer\n\n                // Compute the minimum of the two integers in register 3\n                append_and(3, 1, 2);         // Compute the minimum of j-th and (j+1)-th integers\n\n                // Compute the maximum of the two integers in register 4\n                append_or(4, 1, 2);          // Compute the maximum of j-th and (j+1)-th integers\n\n                // Place the minimum in the j-th position\n                append_move(5, 3);           // Copy the minimum value to register 5\n                append_left(5, 5, j * k);    // Shift left to place it at the j-th position\n                append_or(0, 0, 5);          // Update the j-th position in register 0\n\n                // Place the maximum in the (j+1)-th position\n                append_move(6, 4);           // Copy the maximum value to register 6\n                append_left(6, 6, (j + 1) * k); // Shift left to place it at the (j+1)-th position\n                append_or(0, 0, 6);          // Update the (j+1)-th position in register 0\n            }\n        }\n    }\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 19:18:46",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/F",
    "title": "F. Bit Shift Registers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "F",
    "submission_id": "314995671",
    "code_index": 3,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid construct_instructions(int s, int n, int k, int q) {\n    if (s == 0) {\n        // Task: Find the minimum\n        // Pairwise comparison to find the minimum\n        for (int i = 1; i < n; i++) {\n            // Copy r[0] to r[1] and shift right to isolate a[i]\n            append_move(1, 0);\n            append_right(1, 1, i * k);\n\n            // Use r[2] to store the bitwise-AND of a[0] (min so far) and a[i]\n            append_and(2, 0, 1);\n\n            // Use r[3] to store the bitwise-NOT of a[i]\n            append_not(3, 1);\n\n            // Use r[3] to store the bitwise-AND of NOT(a[i]) and a[0]\n            append_and(3, 3, 0);\n\n            // Use r[2] to store the bitwise-OR of (a[0] AND a[i]) and (NOT(a[i]) AND a[0])\n            append_or(0, 2, 3);\n        }\n    } else if (s == 1) {\n        // Task: Sort the integers\n        // Bubble sort to sort the integers in r[0]\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n - i - 1; j++) {\n                // Isolate a[j] and a[j+1]\n                append_move(1, 0);\n                append_right(1, 1, j * k);\n                append_move(2, 0);\n                append_right(2, 2, (j + 1) * k);\n\n                // Compare a[j] and a[j+1]\n                append_not(3, 1);\n                append_and(3, 3, 2); // r[3] = NOT(a[j]) AND a[j+1]\n                append_or(3, 3, 1);  // r[3] = a[j] OR (NOT(a[j]) AND a[j+1])\n\n                // Swap if necessary\n                append_move(4, 3);\n                append_left(4, 4, j * k);\n                append_or(0, 0, 4);\n\n                append_move(4, 3);\n                append_left(4, 4, (j + 1) * k);\n                append_or(0, 0, 4);\n            }\n        }\n    }\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:19:41",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/D",
    "title": "D. Beech Tree",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "D",
    "submission_id": "314995790",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\nvector<int> beechtree(int N, int M, vector<int> P, vector<int> C) {\n    // Adjacency list representation of the tree\n    vector<vector<int>> tree(N);\n    for (int i = 1; i < N; ++i) {\n        tree[P[i]].push_back(i);\n    }\n\n    // Result array to store whether each subtree is beautiful\n    vector<int> result(N, 1);\n\n    // DFS function to process each subtree\n    function<void(int)> dfs = [&](int node) {\n        unordered_map<int, int> color_count; // Map to track color frequencies\n        vector<int> order; // Order of nodes in the subtree\n        order.push_back(node); // Start with the root of this subtree\n\n        // Stack for iterative DFS\n        vector<int> stack = {node};\n        vector<int> parent(N, -1); // To track parent of each node in the order\n        while (!stack.empty()) {\n            int curr = stack.back();\n            stack.pop_back();\n\n            for (int child : tree[curr]) {\n                stack.push_back(child);\n                parent[child] = curr; // Track parent\n                order.push_back(child);\n            }\n        }\n\n        // Validate the \"beautiful\" property\n        unordered_map<int, int> color_last_seen; // Map to track last seen position of each color\n        for (int i = 1; i < order.size(); ++i) {\n            int node_i = order[i];\n            int color = C[node_i];\n\n            // Find f(i): the number of times this color appears in the sequence so far\n            int f_i = color_count[color]++;\n\n            // The parent of node_i in the beautiful permutation should be order[f_i]\n            if (parent[node_i] != order[f_i]) {\n                result[node] = 0; // Mark this subtree as not beautiful\n                return;\n            }\n        }\n    };\n\n    // Start DFS from the root node (0)\n    for (int i = 0; i < N; ++i) {\n        dfs(i);\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:20:25",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/D",
    "title": "D. Beech Tree",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "D",
    "submission_id": "314995790",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\nvector<int> beechtree(int N, int M, vector<int> P, vector<int> C) {\n    // Step 1: Build adjacency list representation of the tree\n    vector<vector<int>> tree(N);\n    for (int i = 1; i < N; ++i) {\n        tree[P[i]].push_back(i);\n    }\n\n    // Step 2: Result array to store whether each subtree is beautiful\n    vector<int> result(N, 1); // Initially assume all subtrees are beautiful\n\n    // Helper function to check if a subtree is beautiful\n    auto is_beautiful = [&](int root) -> bool {\n        // Stack for DFS\n        vector<int> stack = {root};\n        vector<int> order; // Collect all nodes in the subtree\n        unordered_map<int, int> color_count; // Track color frequencies\n        unordered_map<int, int> node_to_parent; // Track parent relationships\n        \n        node_to_parent[root] = -1; // Root has no parent\n        while (!stack.empty()) {\n            int node = stack.back();\n            stack.pop_back();\n            order.push_back(node);\n\n            // Add children to the stack\n            for (int child : tree[node]) {\n                stack.push_back(child);\n                node_to_parent[child] = node; // Record parent\n            }\n        }\n\n        // Reverse the order for bottom-up processing\n        reverse(order.begin(), order.end());\n\n        // Bottom-up validation of the subtree\n        unordered_map<int, int> color_last_seen; // Maps color to last position it was seen\n        for (int node : order) {\n            int parent = node_to_parent[node];\n            int color = C[node];\n\n            // Determine f(i) (frequency of this color in the sequence seen so far)\n            int f_i = (color_last_seen.find(color) != color_last_seen.end()) ? color_last_seen[color] : -1;\n\n            // Check if the parent of the current node is valid\n            if (parent != -1 && parent != order[f_i]) {\n                return false; // Invalid parent-child relationship\n            }\n\n            // Update color_last_seen for this color\n            color_last_seen[color] = node;\n        }\n\n        return true;\n    };\n\n    // Step 3: Check each subtree\n    for (int r = 0; r < N; ++r) {\n        if (!is_beautiful(r)) {\n            result[r] = 0;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:21:08",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/D",
    "title": "D. Beech Tree",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "D",
    "submission_id": "314995944",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\nvector<int> beechtree(int N, int M, vector<int> P, vector<int> C) {\n    // Precompute the children of each node\n    vector<vector<int>> children(N);\n    for (int i = 1; i < N; i++) {\n        children[P[i]].push_back(i);\n    }\n\n    // Result array\n    vector<int> result(N, 0);\n\n    // Helper function to check if a subtree is beautiful\n    auto isBeautiful = [&](int root) -> bool {\n        // Subtree nodes and color frequencies\n        vector<int> nodes;\n        unordered_map<int, int> colorCount;\n\n        // DFS to collect all nodes in the subtree\n        function<void(int)> dfs = [&](int node) {\n            nodes.push_back(node);\n            for (int child : children[node]) {\n                dfs(child);\n            }\n        };\n        dfs(root);\n\n        // Mapping from colors to the first occurrence index in the sequence\n        unordered_map<int, int> colorToIndex;\n\n        // Simulate the beautiful permutation construction\n        for (int i = 0; i < nodes.size(); i++) {\n            int node = nodes[i];\n            int color = C[node];\n\n            // Determine the parent based on the color count\n            int parentIndex = (colorCount[color] > 0) ? colorToIndex[color] : 0;\n\n            // Check if the parent aligns with the tree structure\n            if (i > 0 && P[node] != nodes[parentIndex]) {\n                return false;\n            }\n\n            // Update color count and mapping\n            colorToIndex[color] = i;\n            colorCount[color]++;\n        }\n\n        return true;\n    };\n\n    // Check each subtree\n    for (int r = 0; r < N; r++) {\n        if (isBeautiful(r)) {\n            result[r] = 1;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:21:51",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/D",
    "title": "D. Beech Tree",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "D",
    "submission_id": "314995944",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> beechtree(int N, int M, vector<int> P, vector<int> C) {\n    // Adjacency list for the tree\n    vector<vector<int>> tree(N);\n    for (int i = 1; i < N; ++i) {\n        tree[P[i]].push_back(i);\n    }\n\n    // Result array\n    vector<int> result(N, 1);\n\n    // Function to check if a subtree is beautiful\n    auto isBeautiful = [&](int root) {\n        // Stack for DFS traversal\n        vector<int> stack;\n        unordered_map<int, int> colorCount;\n        vector<int> parent(N, -1); // Parent tracking\n        stack.push_back(root);\n\n        while (!stack.empty()) {\n            int node = stack.back();\n            stack.pop_back();\n\n            // Process the current node\n            if (node != root) {\n                int freq = colorCount[C[node]]++;\n                if (parent[node] != -1 && parent[node] != freq) {\n                    return false;\n                }\n            }\n\n            // Push children to stack\n            for (int child : tree[node]) {\n                parent[child] = colorCount[C[child]];\n                stack.push_back(child);\n            }\n        }\n\n        return true;\n    };\n\n    // Check each subtree\n    for (int r = 0; r < N; ++r) {\n        if (!isBeautiful(r)) {\n            result[r] = 0;\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 19:23:09",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/D",
    "title": "D. Gondola",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "D",
    "submission_id": "314996151",
    "code_index": 0,
    "code": "// gondola.cpp\n#include \"gondola.h\"\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nconst int MOD = 1000000009;\n\n// Helper function to check if a sequence is circularly sorted\nbool isCircularSorted(const vector<int>& seq, int n) {\n    int offset = -1;\n    for (int i = 0; i < n; ++i) {\n        if (seq[i] == 1) {\n            offset = i;\n            break;\n        }\n    }\n    if (offset == -1) return false;\n\n    for (int i = 0; i < n; ++i) {\n        if (seq[(offset + i) % n] != (i + 1)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to check if the input sequence is a gondola sequence\nint valid(int n, int inputSeq[]) {\n    vector<int> seq(inputSeq, inputSeq + n);\n    unordered_set<int> seen;\n    int maxGondola = *max_element(seq.begin(), seq.end());\n\n    // Check for duplicates and invalid gondola numbers\n    for (int x : seq) {\n        if (seen.count(x) || x < 1 || x > n + (maxGondola - n)) {\n            return 0;\n        }\n        seen.insert(x);\n    }\n\n    // Check if the sequence is circularly sorted for the first n gondolas\n    vector<int> firstNGondolas;\n    for (int x : seq) {\n        if (x <= n) {\n            firstNGondolas.push_back(x);\n        }\n    }\n    sort(firstNGondolas.begin(), firstNGondolas.end());\n    if (!isCircularSorted(firstNGondolas, firstNGondolas.size())) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// Function to construct a replacement sequence\nint replacement(int n, int gondolaSeq[], int replacementSeq[]) {\n    vector<int> seq(gondolaSeq, gondolaSeq + n);\n    unordered_set<int> existingGondolas(seq.begin(), seq.end());\n    vector<int> missingGondolas;\n\n    for (int i = 1; i <= n; ++i) {\n        if (!existingGondolas.count(i)) {\n            missingGondolas.push_back(i);\n        }\n    }\n\n    int replacementIndex = 0;\n    for (int i = 0; i < n; ++i) {\n        if (seq[i] > n) {\n            replacementSeq[replacementIndex++] = missingGondolas.back();\n            missingGondolas.pop_back();\n        }\n    }\n\n    return replacementIndex;\n}\n\n// Function to count the number of possible replacement sequences\nint countReplacement(int n, int inputSeq[]) {\n    if (!valid(n, inputSeq)) return 0;\n\n    vector<int> seq(inputSeq, inputSeq + n);\n    unordered_set<int> seen;\n    int maxGondola = *max_element(seq.begin(), seq.end());\n\n    // Count the number of gondolas greater than n\n    int extraGondolas = 0;\n    for (int x : seq) {\n        if (x > n) {\n            ++extraGondolas;\n        }\n        seen.insert(x);\n    }\n\n    // Count the number of missing gondolas\n    int missingGondolas = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (!seen.count(i)) {\n            ++missingGondolas;\n        }\n    }\n\n    // Compute the factorial of missingGondolas modulo MOD\n    long long factorial = 1;\n    for (int i = 1; i <= missingGondolas; ++i) {\n        factorial = (factorial * i) % MOD;\n    }\n\n    return factorial;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 19:23:53",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/D",
    "title": "D. Gondola",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "D",
    "submission_id": "314996252",
    "code_index": 1,
    "code": "// gondola.h\n#ifndef GONDOLA_H\n#define GONDOLA_H\n\n#include <vector>\n\nint valid(int n, int inputSeq[]);\nint replacement(int n, int gondolaSeq[], int replacementSeq[]);\nint countReplacement(int n, int inputSeq[]);\n\n#endif"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 19:24:32",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/D",
    "title": "D. Gondola",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "D",
    "submission_id": "314996330",
    "code_index": 2,
    "code": "// gondola.cpp\n#include \"gondola.h\"\n#include <vector>\n#include <unordered_set>\n#include <set>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\nconst int MOD = 1000000009;\n\n// Function to check if the sequence is valid\nint valid(int n, int inputSeq[]) {\n    unordered_set<int> seen;\n    for (int i = 0; i < n; ++i) {\n        if (inputSeq[i] < 1 || seen.count(inputSeq[i])) {\n            return 0; // Invalid if gondola number is less than 1 or repeated\n        }\n        seen.insert(inputSeq[i]);\n    }\n\n    int first = inputSeq[0];\n    for (int i = 1; i < n; ++i) {\n        if (inputSeq[i] == (first + i - 1) % n + 1 || inputSeq[i] > n) {\n            continue;\n        }\n        return 0; // Invalid if sequence is not circular or out of range\n    }\n\n    return 1;\n}\n\n// Function to construct a replacement sequence\nint replacement(int n, int gondolaSeq[], int replacementSeq[]) {\n    set<int> available; // Set to store available gondolas\n    for (int i = n + 1; i <= 250000; ++i) {\n        available.insert(i);\n    }\n\n    unordered_set<int> existing;\n    for (int i = 0; i < n; ++i) {\n        existing.insert(gondolaSeq[i]);\n    }\n\n    int l = 0; // Length of the replacement sequence\n    for (int i = 0; i < n; ++i) {\n        if (gondolaSeq[i] > n) {\n            replacementSeq[l++] = gondolaSeq[i];\n        } else if (existing.count(gondolaSeq[i]) == 0) {\n            int nextReplacement = *available.begin();\n            available.erase(nextReplacement);\n            replacementSeq[l++] = nextReplacement;\n        }\n    }\n\n    return l;\n}\n\n// Function to count the number of replacement sequences\nint countReplacement(int n, int inputSeq[]) {\n    if (valid(n, inputSeq) == 0) {\n        return 0; // Return 0 if sequence is not valid\n    }\n\n    unordered_set<int> original;\n    for (int i = 1; i <= n; ++i) {\n        original.insert(i);\n    }\n\n    unordered_set<int> seen;\n    for (int i = 0; i < n; ++i) {\n        seen.insert(inputSeq[i]);\n    }\n\n    int missing = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (!seen.count(i)) {\n            ++missing;\n        }\n    }\n\n    long long result = 1;\n    for (int i = 1; i <= missing; ++i) {\n        result = (result * i) % MOD; // Factorial for missing gondolas\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 19:25:18",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/D",
    "title": "D. Gondola",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "D",
    "submission_id": "314996330",
    "code_index": 3,
    "code": "// gondola.cpp\n\n#include \"gondola.h\"\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000009;\n\n// Function to check if the input sequence is a valid gondola sequence\nint valid(int n, int inputSeq[]) {\n    unordered_set<int> seen;\n    int minGondola = MOD, maxGondola = 0;\n\n    // Check for duplicates and range validity\n    for (int i = 0; i < n; ++i) {\n        if (seen.count(inputSeq[i])) return 0; // Duplicate found\n        seen.insert(inputSeq[i]);\n        minGondola = min(minGondola, inputSeq[i]);\n        maxGondola = max(maxGondola, inputSeq[i]);\n    }\n\n    // Check if the sequence is circularly ordered\n    for (int i = 0; i < n; ++i) {\n        if (inputSeq[i] <= n) {\n            int start = i;\n            for (int j = 0; j < n; ++j) {\n                int expected = (j + 1);\n                if (inputSeq[(start + j) % n] <= n && inputSeq[(start + j) % n] != expected) {\n                    return 0;\n                }\n            }\n            break;\n        }\n    }\n\n    return 1;\n}\n\n// Function to construct a replacement sequence for a given gondola sequence\nint replacement(int n, int gondolaSeq[], int replacementSeq[]) {\n    unordered_set<int> present;\n    vector<int> missing;\n\n    // Mark gondolas that are already present\n    for (int i = 0; i < n; ++i) {\n        if (gondolaSeq[i] <= n) {\n            present.insert(gondolaSeq[i]);\n        }\n    }\n\n    // Find missing gondolas\n    for (int i = 1; i <= n; ++i) {\n        if (!present.count(i)) {\n            missing.push_back(i);\n        }\n    }\n\n    // Fill replacement sequence\n    int replacementIndex = 0;\n    for (int i = 0; i < n; ++i) {\n        if (gondolaSeq[i] > n) {\n            replacementSeq[replacementIndex++] = missing.back();\n            missing.pop_back();\n        }\n    }\n\n    return replacementIndex;\n}\n\n// Function to count the number of possible replacement sequences\nint countReplacement(int n, int inputSeq[]) {\n    if (!valid(n, inputSeq)) return 0;\n\n    unordered_set<int> seen;\n    int replacementsNeeded = 0;\n    int unusedGondolas = 0;\n\n    // Count replacements and track unused gondolas\n    for (int i = 0; i < n; ++i) {\n        if (inputSeq[i] <= n) {\n            seen.insert(inputSeq[i]);\n        } else {\n            replacementsNeeded++;\n        }\n    }\n\n    // Count unused gondolas\n    for (int i = 1; i <= n; ++i) {\n        if (!seen.count(i)) {\n            unusedGondolas++;\n        }\n    }\n\n    // Calculate the number of permutations of the replacement sequence\n    long long result = 1;\n    for (int i = 1; i <= replacementsNeeded; ++i) {\n        result = (result * unusedGondolas) % MOD;\n        unusedGondolas--;\n    }\n\n    // Account for circular permutations of the starting point\n    result = (result * n) % MOD;\n\n    return result;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 19:26:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/D",
    "title": "D. Gondola",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "D",
    "submission_id": "314996486",
    "code_index": 4,
    "code": "#include <vector>\n#include <unordered_set>\n#include <algorithm>\n#include <numeric>\n#include <map>\n\nconst int MODULO = 1000000009;\n\n// Function 1: Check if the input sequence is a valid gondola sequence\nint valid(int n, std::vector<int> inputSeq) {\n    std::unordered_set<int> seen;\n    int minValue = *std::min_element(inputSeq.begin(), inputSeq.end());\n    int maxValue = *std::max_element(inputSeq.begin(), inputSeq.end());\n\n    // Ensure all gondola numbers are unique\n    for (int num : inputSeq) {\n        if (seen.count(num)) return 0;\n        seen.insert(num);\n    }\n\n    // Check for valid values and order\n    if (maxValue - minValue + 1 > n) return 0;\n\n    // Check if the sequence can be circular\n    int startIndex = std::find(inputSeq.begin(), inputSeq.end(), minValue) - inputSeq.begin();\n    for (int i = 0; i < n; ++i) {\n        int expected = (minValue + i - 1) % n + 1;\n        int actual = inputSeq[(startIndex + i) % n];\n        if (expected != actual && actual <= n) return 0;\n    }\n\n    return 1;\n}\n\n// Function 2: Generate a replacement sequence for a given gondola sequence\nint replacement(int n, std::vector<int> gondolaSeq, std::vector<int>& replacementSeq) {\n    std::unordered_set<int> seen;\n    int nextGondola = n + 1;\n\n    // Mark all gondolas initially present in the sequence\n    for (int num : gondolaSeq) {\n        seen.insert(num);\n    }\n\n    // Generate replacement sequence for missing gondolas\n    for (int num : gondolaSeq) {\n        if (num > n) {\n            replacementSeq.push_back(nextGondola++);\n        }\n    }\n\n    return replacementSeq.size();\n}\n\n// Function 3: Count the number of possible replacement sequences\nint countReplacement(int n, std::vector<int> inputSeq) {\n    if (!valid(n, inputSeq)) return 0;\n\n    std::unordered_set<int> seen;\n    int fixed = 0; // Count of gondolas <= n\n    int freeSlots = 0; // Count of gondolas > n\n    int nextGondola = n + 1;\n\n    // Count gondolas already fixed and identify free slots\n    for (int num : inputSeq) {\n        if (num <= n) {\n            seen.insert(num);\n            ++fixed;\n        } else {\n            ++freeSlots;\n        }\n    }\n\n    // Count unfixed gondolas <= n\n    int unfixed = n - fixed;\n\n    // Calculate the number of replacement sequences\n    long long result = 1;\n    for (int i = 0; i < freeSlots; ++i) {\n        result = (result * (unfixed + i)) % MODULO;\n    }\n\n    // Multiply by the number of possible permutations of the replacements\n    for (int i = 1; i <= freeSlots; ++i) {\n        result = (result * i) % MODULO;\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:27:01",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/E",
    "title": "E. Overtaking",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "E",
    "submission_id": "314996592",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nusing namespace std;\n\n// Global variables to store the inputs\nint L, N, X, M;\nvector<int64_t> T;\nvector<int> W;\nvector<int> S;\n\n// Precomputed times for non-reserve buses\nvector<vector<int64_t>> non_reserve_times;\n\n// Initialize the problem\nvoid init(int length, int num_buses, vector<int64_t> departure_times, vector<int> speeds, int reserve_speed, int num_stations, vector<int> stations) {\n    // Assign global variables\n    L = length;\n    N = num_buses;\n    X = reserve_speed;\n    M = num_stations;\n    T = departure_times;\n    W = speeds;\n    S = stations;\n\n    // Precompute the arrival times for all non-reserve buses at each sorting station\n    non_reserve_times = vector<vector<int64_t>>(N, vector<int64_t>(M, 0));\n\n    for (int i = 0; i < N; ++i) {\n        non_reserve_times[i][0] = T[i]; // Arrival time at station 0 is the departure time\n    }\n\n    for (int j = 1; j < M; ++j) {\n        for (int i = 0; i < N; ++i) {\n            int64_t expected_time = non_reserve_times[i][j - 1] + W[i] * (S[j] - S[j - 1]);\n            int64_t max_time = expected_time;\n\n            for (int k = 0; k < N; ++k) {\n                if (non_reserve_times[k][j - 1] < non_reserve_times[i][j - 1]) {\n                    max_time = max(max_time, non_reserve_times[k][j]);\n                }\n            }\n\n            non_reserve_times[i][j] = max_time;\n        }\n    }\n}\n\n// Calculate the arrival time of the reserve bus at the hotel\nint64_t arrival_time(int64_t Y) {\n    // Reserve bus times\n    vector<int64_t> reserve_times(M, 0);\n    reserve_times[0] = Y;\n\n    for (int j = 1; j < M; ++j) {\n        int64_t expected_time = reserve_times[j - 1] + X * (S[j] - S[j - 1]);\n        int64_t max_time = expected_time;\n\n        for (int i = 0; i < N; ++i) {\n            if (non_reserve_times[i][j - 1] < reserve_times[j - 1]) {\n                max_time = max(max_time, non_reserve_times[i][j]);\n            }\n        }\n\n        reserve_times[j] = max_time;\n    }\n\n    return reserve_times[M - 1];\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:27:42",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/E",
    "title": "E. Overtaking",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "E",
    "submission_id": "314996592",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nusing namespace std;\n\n// Global variables to store input data\nint L, N, X, M;\nvector<int64_t> T;\nvector<int> W;\nvector<int> S;\n\n// Precomputed arrival times for non-reserve buses\nvector<vector<int64_t>> time_non_reserve;\n\n// Initialize the problem data\nvoid init(int L_, int N_, int64_t T_[], int W_[], int X_, int M_, int S_[]) {\n    L = L_;\n    N = N_;\n    X = X_;\n    M = M_;\n    T.assign(T_, T_ + N_);\n    W.assign(W_, W_ + N_);\n    S.assign(S_, S_ + M_);\n\n    // Precompute arrival times for non-reserve buses\n    time_non_reserve.assign(N, vector<int64_t>(M, 0));\n    \n    // Initial arrival times at the airport (sorting station 0)\n    for (int i = 0; i < N; ++i) {\n        time_non_reserve[i][0] = T[i];\n    }\n\n    // Compute arrival times for subsequent sorting stations\n    for (int j = 1; j < M; ++j) {\n        for (int i = 0; i < N; ++i) {\n            int64_t expected = time_non_reserve[i][j - 1] + W[i] * (S[j] - S[j - 1]);\n            int64_t actual = expected;\n\n            // Find the maximum time among buses that arrive earlier at the previous station\n            for (int k = 0; k < N; ++k) {\n                if (time_non_reserve[k][j - 1] < time_non_reserve[i][j - 1]) {\n                    actual = max(actual, time_non_reserve[k][j - 1] + W[k] * (S[j] - S[j - 1]));\n                }\n            }\n            time_non_reserve[i][j] = actual;\n        }\n    }\n}\n\n// Compute the arrival time of the reserve bus at the hotel\nint64_t arrival_time(int64_t Y) {\n    vector<int64_t> time_reserve(M, 0);\n    time_reserve[0] = Y;\n\n    for (int j = 1; j < M; ++j) {\n        int64_t expected = time_reserve[j - 1] + X * (S[j] - S[j - 1]);\n        int64_t actual = expected;\n\n        // Find the maximum time among buses that arrive earlier at the previous station\n        for (int i = 0; i < N; ++i) {\n            if (time_non_reserve[i][j - 1] < time_reserve[j - 1]) {\n                actual = max(actual, time_non_reserve[i][j - 1] + W[i] * (S[j] - S[j - 1]));\n            }\n        }\n        time_reserve[j] = actual;\n    }\n\n    return time_reserve[M - 1];\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:28:22",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/E",
    "title": "E. Overtaking",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "E",
    "submission_id": "314996728",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nusing namespace std;\n\nint L, N, X, M;\nvector<int64_t> T;  // Departure times of non-reserve buses\nvector<int> W;      // Speeds of non-reserve buses\nvector<int> S;      // Sorting station distances\nvector<vector<int64_t>> non_reserve_arrivals; // Precomputed arrival times for non-reserve buses\n\nvoid init(int L_, int N_, vector<int64_t> T_, vector<int> W_, int X_, int M_, vector<int> S_) {\n    // Store all the input parameters\n    L = L_;\n    N = N_;\n    T = T_;\n    W = W_;\n    X = X_;\n    M = M_;\n    S = S_;\n\n    // Precompute arrival times for non-reserve buses\n    non_reserve_arrivals = vector<vector<int64_t>>(N, vector<int64_t>(M));\n    for (int i = 0; i < N; ++i) {\n        non_reserve_arrivals[i][0] = T[i];  // Initial departure time\n        for (int j = 1; j < M; ++j) {\n            // Compute expected arrival time at station j\n            int64_t expected_time = non_reserve_arrivals[i][j - 1] + (int64_t)W[i] * (S[j] - S[j - 1]);\n            // Determine the actual arrival time considering all previous buses\n            int64_t actual_time = expected_time;\n            for (int k = 0; k < i; ++k) {\n                if (non_reserve_arrivals[k][j - 1] < non_reserve_arrivals[i][j - 1]) {\n                    actual_time = max(actual_time, non_reserve_arrivals[k][j]);\n                }\n            }\n            non_reserve_arrivals[i][j] = actual_time;\n        }\n    }\n}\n\nint64_t arrival_time(int64_t Y) {\n    // Reserve bus starts at time Y\n    vector<int64_t> reserve_arrivals(M);\n    reserve_arrivals[0] = Y;\n\n    // Simulate the reserve bus journey\n    for (int j = 1; j < M; ++j) {\n        // Compute expected arrival time at station j\n        int64_t expected_time = reserve_arrivals[j - 1] + (int64_t)X * (S[j] - S[j - 1]);\n        // Determine the actual arrival time considering all other buses\n        int64_t actual_time = expected_time;\n        for (int i = 0; i < N; ++i) {\n            if (non_reserve_arrivals[i][j - 1] < reserve_arrivals[j - 1]) {\n                actual_time = max(actual_time, non_reserve_arrivals[i][j]);\n            }\n        }\n        reserve_arrivals[j] = actual_time;\n    }\n\n    // Return the arrival time of the reserve bus at the hotel (last sorting station)\n    return reserve_arrivals[M - 1];\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:29:07",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/E",
    "title": "E. Overtaking",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "E",
    "submission_id": "314996807",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\nusing namespace std;\n\nstruct Bus {\n    int64_t departure_time; // T[i] or Y\n    int travel_time_per_km; // W[i] or X\n};\n\nint L, N, X, M;\nvector<int64_t> T;\nvector<int> W;\nvector<int> S;\nvector<Bus> buses;\n\n// Initialize the problem data\nvoid init(int L_, int N_, vector<int64_t> T_, vector<int> W_, int X_, int M_, vector<int> S_) {\n    L = L_;\n    N = N_;\n    T = T_;\n    W = W_;\n    X = X_;\n    M = M_;\n    S = S_;\n    \n    // Initialize buses array\n    buses.resize(N + 1);\n    for (int i = 0; i < N; ++i) {\n        buses[i] = {T[i], W[i]};\n    }\n}\n\n// Function to compute the arrival time of the reserve bus at the hotel\nint64_t arrival_time(int64_t Y) {\n    // Add the reserve bus to the buses array\n    buses[N] = {Y, X};\n\n    // Initialize time of arrival at each sorting station for each bus\n    vector<vector<int64_t>> arrival_times(N + 1, vector<int64_t>(M, 0));\n    \n    // Set initial times at the airport (station 0)\n    for (int i = 0; i <= N; ++i) {\n        arrival_times[i][0] = buses[i].departure_time;\n    }\n    \n    // Compute times for subsequent sorting stations\n    for (int j = 1; j < M; ++j) {\n        for (int i = 0; i <= N; ++i) {\n            // Calculate the expected arrival time at station j\n            int64_t expected_time = arrival_times[i][j - 1] + buses[i].travel_time_per_km * (S[j] - S[j - 1]);\n            \n            // Find the maximum expected time of buses arriving earlier at the previous station\n            int64_t max_time = expected_time;\n            for (int k = 0; k <= N; ++k) {\n                if (arrival_times[k][j - 1] < arrival_times[i][j - 1]) {\n                    max_time = max(max_time, arrival_times[k][j]);\n                }\n            }\n            \n            // Update the actual arrival time\n            arrival_times[i][j] = max_time;\n        }\n    }\n    \n    // Return the arrival time of the reserve bus at the hotel (last station)\n    return arrival_times[N][M - 1];\n}"
  },
  {
    "date": "IOI 2023 day 2",
    "timestamp": "2025-04-11 19:29:49",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104552/problem/E",
    "title": "E. Overtaking",
    "group_id": "32KGsXgiKA",
    "contest_id": "104552",
    "problem_index": "E",
    "submission_id": "314996880",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nusing namespace std;\n\n// Global variables to store input data and precomputed results\nint L, N, X, M;\nvector<int> W;\nvector<int64_t> T;\nvector<int> S;\nvector<vector<int64_t>> nonReserveArrivalTimes;\n\n// Initialize the problem\nvoid init(int L_, int N_, int64_t T_[], int W_[], int X_, int M_, int S_[]) {\n    // Store the parameters globally\n    L = L_;\n    N = N_;\n    X = X_;\n    M = M_;\n    W.assign(W_, W_ + N_);\n    T.assign(T_, T_ + N_);\n    S.assign(S_, S_ + M_);\n\n    // Precompute arrival times for non-reserve buses at each sorting station\n    nonReserveArrivalTimes.assign(N, vector<int64_t>(M));\n    \n    // Fill arrival times for sorting station 0 (airport)\n    for (int i = 0; i < N; ++i) {\n        nonReserveArrivalTimes[i][0] = T[i];\n    }\n\n    // Compute arrival times for sorting stations 1 through M-1 for non-reserve buses\n    for (int j = 1; j < M; ++j) { // Sorting station index\n        for (int i = 0; i < N; ++i) { // Bus index\n            int64_t expectedArrival = nonReserveArrivalTimes[i][j-1] + W[i] * (S[j] - S[j-1]);\n            int64_t actualArrival = expectedArrival;\n\n            // Check for bunching with other buses arriving earlier at the previous station\n            for (int k = 0; k < N; ++k) {\n                if (nonReserveArrivalTimes[k][j-1] < nonReserveArrivalTimes[i][j-1]) {\n                    actualArrival = max(actualArrival, nonReserveArrivalTimes[k][j-1] + W[k] * (S[j] - S[j-1]));\n                }\n            }\n\n            nonReserveArrivalTimes[i][j] = actualArrival;\n        }\n    }\n}\n\n// Compute arrival time of the reserve bus at the hotel\nint64_t arrival_time(int64_t Y) {\n    // Reserve bus arrival times at each sorting station\n    vector<int64_t> reserveArrivalTimes(M);\n    reserveArrivalTimes[0] = Y;\n\n    for (int j = 1; j < M; ++j) {\n        int64_t expectedArrival = reserveArrivalTimes[j-1] + X * (S[j] - S[j-1]);\n        int64_t actualArrival = expectedArrival;\n\n        // Check for bunching with other buses arriving earlier at the previous station\n        for (int i = 0; i < N; ++i) {\n            if (nonReserveArrivalTimes[i][j-1] < reserveArrivalTimes[j-1]) {\n                actualArrival = max(actualArrival, nonReserveArrivalTimes[i][j-1] + W[i] * (S[j] - S[j-1]));\n            }\n        }\n\n        reserveArrivalTimes[j] = actualArrival;\n    }\n\n    // Return the arrival time at the hotel (last sorting station)\n    return reserveArrivalTimes[M-1];\n}"
  }
]