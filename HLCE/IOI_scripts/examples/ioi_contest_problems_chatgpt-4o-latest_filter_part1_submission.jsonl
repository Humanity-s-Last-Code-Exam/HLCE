[
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 16:14:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A5",
    "title": "A5. Pebbling odometer - subtask 5",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A5",
    "submission_id": "314975527",
    "code_index": 0,
    "code": "odometer\n# Initialize variables\nmin_pebbles:\nhalt # Placeholder; replace with actual implementation"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 16:15:00",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A5",
    "title": "A5. Pebbling odometer - subtask 5",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A5",
    "submission_id": "314975527",
    "code_index": 1,
    "code": "odometer\n# Initialize variables and start traversal\nmin_pebble_count:\nright\nstart_row:\npebble check_minimum\nborder next_row\nmove\njump start_row\n\nnext_row:\nright\nmove\nright\njump start_row\n\ncheck_minimum:\n# Compare the current cell's pebbles with stored minimum\n..."
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 16:15:38",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A5",
    "title": "A5. Pebbling odometer - subtask 5",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A5",
    "submission_id": "314975651",
    "code_index": 2,
    "code": "odometer\n# Initialize the direction to move through the grid\nright\n\n# Labels for looping through the grid\nrow_start:\n# Check if the current cell has fewer pebbles than the current minimum\npebble update_min\nmove\njump row_start\nupdate_min:\n# Update logic for new minimum\nhalt"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 16:16:18",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A5",
    "title": "A5. Pebbling odometer - subtask 5",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A5",
    "submission_id": "314975718",
    "code_index": 3,
    "code": "odometer\n# Initialize and face east to traverse the grid row by row\nright\n\n# Starting point for grid traversal\nstart:\n\n# Store the current cell's pebble count as the potential minimum\nput # Temporarily add a pebble to mark this cell\nleft\nmove\npebble skip_compare\nright\nput # Restore original pebble count\nmove"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 16:17:21",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A3",
    "title": "A3. Pebbling odometer - subtask 3",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A3",
    "submission_id": "314975814",
    "code_index": 0,
    "code": "odometer\n# Move to the first pebble in row 0\nright\nfind_first:\npebble first_found\nmove\njump find_first\n\nfirst_found:\nput # Mark the first pebble's position\nmove\n\n# Move to find the second pebble in row 0\nfind_second:\npebble second_found\nmove\njump find_second\n\nsecond_found:\n# Calculate the midpoint\nright\nright\nmove_to_first:\npebble back_to_midpoint\nmove\njump move_to_first\n\nback_to_midpoint:\nright\nright\nmove\nmove_to_midpoint:\npebble midpoint_reached\nmove\nmove\njump move_to_midpoint\n\nmidpoint_reached:\nhalt"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 16:18:00",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A3",
    "title": "A3. Pebbling odometer - subtask 3",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A3",
    "submission_id": "314975875",
    "code_index": 1,
    "code": "plaintext\n# Move right to start traversing row 0\nright\n\n# Loop to find the first pebble\nfind_first_pebble:\npebble first_found\nmove\njump find_first_pebble\n\n# Save the position of the first pebble\nfirst_found:\nput\nright\nright\n\n# Loop to find the second pebble\nfind_second_pebble:\npebble second_found\nmove\njump find_second_pebble\n\n# Save the position of the second pebble\nsecond_found:\nput\nright\nright\n\n# Start moving back to compute the midpoint\ncompute_midpoint:\nget\nmove\npebble midpoint_found\njump compute_midpoint\n\n# Stop at the midpoint\nmidpoint_found:\nhalt"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 16:18:37",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A3",
    "title": "A3. Pebbling odometer - subtask 3",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A3",
    "submission_id": "314975929",
    "code_index": 2,
    "code": "plaintext\n# Start by facing east to traverse row 0\nright\n\n# Loop to find the first pebble\nfind_first_pebble:\npebble first_pebble_found\nmove\njump find_first_pebble\n\n# First pebble found; mark its position\nfirst_pebble_found:\nput\nleft # Turn around to traverse back\nreturn_to_start:\nborder start_traversal\nmove\njump return_to_start\n\nstart_traversal:\nright # Face east again\n\n# Loop to find the second pebble\nfind_second_pebble:\npebble second_pebble_found\nmove\njump find_second_pebble\n\n# Second pebble found; mark its position\nsecond_pebble_found:\nput\n\n# Calculate midpoint by moving back and forth\ncalculate_midpoint:\nleft # Turn around to traverse back\nreturn_to_start_again:\nborder midpoint_calculation\nget\nmove\njump return_to_start_again\n\nmidpoint_calculation:\nright # Face east again\nmove # Move to midpoint\nget # Remove pebble at midpoint\nhalt"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 16:19:19",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A3",
    "title": "A3. Pebbling odometer - subtask 3",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A3",
    "submission_id": "314975999",
    "code_index": 3,
    "code": "odometer\n# Move to the first pebble in row 0\nright\nfind_first_pebble:\npebble found_first # pebble found\nborder found_first # end of the row\nmove\njump find_first_pebble\n\nfound_first:\n# Store the position of the first pebble\nleft\nput\nright\n\n# Move to the second pebble\nfind_second_pebble:\nmove\npebble found_second # pebble found\nborder found_second # end of the row\njump find_second_pebble\n\nfound_second:\n# Store the position of the second pebble\nleft\nput\nput\nright\n\n# Return to the beginning of the row\nreset_position:\nborder start_midpoint\nleft\nleft\nmove\nright\nright\njump reset_position\n\nstart_midpoint:\n# Compute the midpoint\nmidpoint_loop:\nget\nborder midpoint_found\nmove\njump midpoint_loop\n\nmidpoint_found:\n# Odometer is now at the midpoint, terminate\nhalt"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 16:20:05",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/A",
    "title": "A. Cluedo",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "A",
    "submission_id": "314976102",
    "code_index": 0,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid Solve() {\n    int murderer = 1, location = 1, weapon = 1;\n\n    while (true) {\n        int result = Theory(murderer, location, weapon);\n        \n        if (result == 0) {\n            // All three are correct, exit the function\n            return;\n        } else if (result == 1) {\n            // Murderer is wrong, increment murderer\n            murderer++;\n        } else if (result == 2) {\n            // Location is wrong, increment location\n            location++;\n        } else if (result == 3) {\n            // Weapon is wrong, increment weapon\n            weapon++;\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 16:20:42",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/A",
    "title": "A. Cluedo",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "A",
    "submission_id": "314977138",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n\nvoid Solve() {\n    // Initialize possible values for murderer, location, and weapon\n    std::vector<int> murderers = {1, 2, 3, 4, 5, 6};\n    std::vector<int> locations = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::vector<int> weapons = {1, 2, 3, 4, 5, 6};\n\n    // Variables to hold the correct values\n    int correct_murderer = -1;\n    int correct_location = -1;\n    int correct_weapon = -1;\n\n    // Narrow down the murderer\n    for (int m : murderers) {\n        int result = Theory(m, locations[0], weapons[0]);\n        if (result == 0) {\n            correct_murderer = m;\n            correct_location = locations[0];\n            correct_weapon = weapons[0];\n            return;\n        } else if (result == 1) {\n            correct_murderer = m;\n            break;\n        }\n    }\n\n    // Narrow down the location\n    for (int l : locations) {\n        int result = Theory(correct_murderer, l, weapons[0]);\n        if (result == 0) {\n            correct_location = l;\n            correct_weapon = weapons[0];\n            return;\n        } else if (result == 2) {\n            correct_location = l;\n            break;\n        }\n    }\n\n    // Narrow down the weapon\n    for (int w : weapons) {\n        int result = Theory(correct_murderer, correct_location, w);\n        if (result == 0) {\n            correct_weapon = w;\n            return;\n        } else if (result == 3) {\n            correct_weapon = w;\n            break;\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 16:21:26",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/A",
    "title": "A. Cluedo",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "A",
    "submission_id": "314977205",
    "code_index": 2,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid Solve() {\n    // Initialize ranges for murderer, location, and weapon\n    int murderer = 1, location = 1, weapon = 1;\n\n    while (true) {\n        // Test the current theory\n        int result = Theory(murderer, location, weapon);\n\n        // Check result and adjust accordingly\n        if (result == 0) {\n            // The theory is correct\n            return;\n        } else if (result == 1) {\n            // Murderer is wrong, increment murderer\n            murderer++;\n        } else if (result == 2) {\n            // Location is wrong, increment location\n            location++;\n        } else if (result == 3) {\n            // Weapon is wrong, increment weapon\n            weapon++;\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 16:22:06",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/A",
    "title": "A. Cluedo",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "A",
    "submission_id": "314977274",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function declaration for Theory provided by the grader\nint Theory(int M, int L, int W);\n\nvoid Solve() {\n    // Initialize the possible ranges for murderer, location, and weapon\n    int murderer = 1, location = 1, weapon = 1;\n\n    // Loop until the correct theory is found\n    while (true) {\n        // Call the Theory function with the current guess\n        int result = Theory(murderer, location, weapon);\n\n        // If the theory is correct, exit\n        if (result == 0) {\n            return;\n        }\n\n        // Update the guess based on the result\n        if (result == 1) {\n            murderer++;\n        } else if (result == 2) {\n            location++;\n        } else if (result == 3) {\n            weapon++;\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 16:22:49",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/A",
    "title": "A. Cluedo",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "A",
    "submission_id": "314977352",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function prototype for the grader's Theory function\nint Theory(int M, int L, int W);\n\nvoid Solve() {\n    // Initialize the search space for murderer, location, and weapon\n    int murderer = 1, location = 1, weapon = 1;\n\n    while (true) {\n        // Call the Theory function with the current guess\n        int result = Theory(murderer, location, weapon);\n\n        if (result == 0) {\n            // The theory is correct, exit the function\n            return;\n        } else if (result == 1) {\n            // The murderer is wrong, try the next murderer\n            murderer++;\n        } else if (result == 2) {\n            // The location is wrong, try the next location\n            location++;\n        } else if (result == 3) {\n            // The weapon is wrong, try the next weapon\n            weapon++;\n        }\n    }\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 16:23:36",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/E",
    "title": "E. Friend",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "E",
    "submission_id": "314977429",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint findSample(int n, int confidence[], int host[], int protocol[]) {\n    // Adjacency list to represent the friendship relations\n    vector<set<int>> friends(n);\n\n    // Build the network based on the protocols\n    for (int i = 1; i < n; ++i) {\n        if (protocol[i] == 0) { // IAmYourFriend\n            friends[i].insert(host[i]);\n            friends[host[i]].insert(i);\n        } else if (protocol[i] == 1) { // MyFriendsAreYourFriends\n            for (int friend_of_host : friends[host[i]]) {\n                friends[i].insert(friend_of_host);\n                friends[friend_of_host].insert(i);\n            }\n        } else if (protocol[i] == 2) { // WeAreYourFriends\n            for (int friend_of_host : friends[host[i]]) {\n                friends[i].insert(friend_of_host);\n                friends[friend_of_host].insert(i);\n            }\n            friends[i].insert(host[i]);\n            friends[host[i]].insert(i);\n        }\n    }\n\n    // Maximum independent set using a greedy approach\n    vector<bool> visited(n, false);\n    vector<pair<int, int>> nodes; // Pair of (confidence, person)\n\n    for (int i = 0; i < n; ++i) {\n        nodes.emplace_back(confidence[i], i);\n    }\n\n    // Sort in descending order of confidence\n    sort(nodes.rbegin(), nodes.rend());\n\n    int totalConfidence = 0;\n\n    for (auto& [conf, person] : nodes) {\n        if (!visited[person]) {\n            totalConfidence += conf;\n            visited[person] = true;\n            for (int friend_of_person : friends[person]) {\n                visited[friend_of_person] = true;\n            }\n        }\n    }\n\n    return totalConfidence;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 16:24:18",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/E",
    "title": "E. Friend",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "E",
    "submission_id": "314977494",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <unordered_set>\nusing namespace std;\n\nint findSample(int n, int confidence[], int host[], int protocol[]) {\n    // Step 1: Build the graph using adjacency lists\n    vector<vector<int>> graph(n);  // graph[i] contains the list of friends of person i\n\n    for (int i = 1; i < n; ++i) {\n        int h = host[i];\n        if (protocol[i] == 0) {  // IAmYourFriend\n            graph[i].push_back(h);\n            graph[h].push_back(i);\n        } else if (protocol[i] == 1) {  // MyFriendsAreYourFriends\n            for (int friend_of_h : graph[h]) {\n                graph[i].push_back(friend_of_h);\n                graph[friend_of_h].push_back(i);\n            }\n        } else if (protocol[i] == 2) {  // WeAreYourFriends\n            graph[i].push_back(h);\n            graph[h].push_back(i);\n            for (int friend_of_h : graph[h]) {\n                graph[i].push_back(friend_of_h);\n                graph[friend_of_h].push_back(i);\n            }\n        }\n    }\n\n    // Step 2: Find the maximum independent set\n    // Use a greedy approach based on node confidence values.\n    vector<pair<int, int>> nodes;  // Pair of (confidence, node index)\n    for (int i = 0; i < n; ++i) {\n        nodes.emplace_back(confidence[i], i);\n    }\n    // Sort nodes by confidence in descending order\n    sort(nodes.rbegin(), nodes.rend());\n\n    vector<bool> in_set(n, false);  // Whether a node is included in the independent set\n    vector<bool> visited(n, false);  // Whether a node is already processed\n    int max_confidence_sum = 0;\n\n    for (const auto& [conf, node] : nodes) {\n        if (!visited[node]) {\n            // Add this node to the independent set\n            in_set[node] = true;\n            max_confidence_sum += conf;\n\n            // Mark all neighbors as visited\n            visited[node] = true;\n            for (int neighbor : graph[node]) {\n                visited[neighbor] = true;\n            }\n        }\n    }\n\n    return max_confidence_sum;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 16:24:59",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/E",
    "title": "E. Friend",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "E",
    "submission_id": "314977581",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nint findSample(int n, int confidence[], int host[], int protocol[]) {\n    // Adjacency list to represent the friendship graph\n    vector<unordered_set<int>> friends(n);\n\n    // Build the friendship graph based on the protocol\n    for (int i = 1; i < n; ++i) {\n        int h = host[i];\n        if (protocol[i] == 0) { // IAmYourFriend\n            friends[h].insert(i);\n            friends[i].insert(h);\n        } else if (protocol[i] == 1) { // MyFriendsAreYourFriends\n            for (int friendOfHost : friends[h]) {\n                friends[i].insert(friendOfHost);\n                friends[friendOfHost].insert(i);\n            }\n        } else if (protocol[i] == 2) { // WeAreYourFriends\n            friends[h].insert(i);\n            friends[i].insert(h);\n            for (int friendOfHost : friends[h]) {\n                friends[i].insert(friendOfHost);\n                friends[friendOfHost].insert(i);\n            }\n        }\n    }\n\n    // Use a greedy algorithm to find the maximum independent set\n    // This is a heuristic approach for the problem\n    vector<bool> visited(n, false);\n    vector<pair<int, int>> nodesWithConfidence; // Pair of (confidence, node)\n\n    for (int i = 0; i < n; ++i) {\n        nodesWithConfidence.emplace_back(confidence[i], i);\n    }\n\n    // Sort nodes by confidence in descending order\n    sort(nodesWithConfidence.rbegin(), nodesWithConfidence.rend());\n\n    int maxConfidenceSum = 0;\n\n    for (const auto& [conf, node] : nodesWithConfidence) {\n        if (!visited[node]) {\n            maxConfidenceSum += conf;\n            visited[node] = true;\n            // Mark all friends of this node as visited\n            for (int friendNode : friends[node]) {\n                visited[friendNode] = true;\n            }\n        }\n    }\n\n    return maxConfidenceSum;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 16:25:43",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/E",
    "title": "E. Friend",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "E",
    "submission_id": "314977640",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint findSample(int n, int confidence[], int host[], int protocol[]) {\n    // Step 1: Build the friendship graph\n    vector<vector<int>> graph(n);\n    \n    for (int i = 1; i < n; ++i) {\n        int h = host[i];\n        if (protocol[i] == 0) { // IAmYourFriend\n            graph[h].push_back(i);\n            graph[i].push_back(h);\n        } else if (protocol[i] == 1) { // MyFriendsAreYourFriends\n            for (int f : graph[h]) {\n                graph[i].push_back(f);\n                graph[f].push_back(i);\n            }\n        } else if (protocol[i] == 2) { // WeAreYourFriends\n            graph[h].push_back(i);\n            graph[i].push_back(h);\n            for (int f : graph[h]) {\n                graph[i].push_back(f);\n                graph[f].push_back(i);\n            }\n        }\n    }\n\n    // Step 2: Use a greedy graph coloring approach for maximum independent set\n    vector<bool> visited(n, false);\n    vector<int> maxConfidence(n, 0);\n    vector<int> sortedNodes(n);\n    for (int i = 0; i < n; ++i) sortedNodes[i] = i;\n\n    // Sort nodes by confidence in descending order\n    sort(sortedNodes.begin(), sortedNodes.end(), [&](int a, int b) {\n        return confidence[a] > confidence[b];\n    });\n\n    int maxSum = 0;\n\n    for (int node : sortedNodes) {\n        if (!visited[node]) {\n            maxSum += confidence[node];\n            visited[node] = true;\n            for (int neighbor : graph[node]) {\n                visited[neighbor] = true;\n            }\n        }\n    }\n\n    return maxSum;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 16:26:24",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/E",
    "title": "E. Friend",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "E",
    "submission_id": "314977712",
    "code_index": 4,
    "code": "#include <vector>\n#include <unordered_set>\n#include <algorithm>\n\n// Your code will be placed here\nint findSample(int n, int confidence[], int host[], int protocol[]) {\n    // Adjacency list to represent the friendship graph\n    std::vector<std::unordered_set<int>> friends(n);\n\n    // Build the network\n    for (int i = 1; i < n; ++i) {\n        int h = host[i];\n        int p = protocol[i];\n\n        if (p == 0) {\n            // IAmYourFriend: Add friendship between i and host[h]\n            friends[i].insert(h);\n            friends[h].insert(i);\n        } else if (p == 1) {\n            // MyFriendsAreYourFriends: Add friendship between i and each friend of host[h]\n            for (int friend_of_host : friends[h]) {\n                friends[i].insert(friend_of_host);\n                friends[friend_of_host].insert(i);\n            }\n        } else if (p == 2) {\n            // WeAreYourFriends: Add friendship between i and host[h], and also between i and each friend of host[h]\n            friends[i].insert(h);\n            friends[h].insert(i);\n            for (int friend_of_host : friends[h]) {\n                friends[i].insert(friend_of_host);\n                friends[friend_of_host].insert(i);\n            }\n        }\n    }\n\n    // Maximum independent set calculation using a greedy approach\n    std::vector<std::pair<int, int>> people; // {confidence, person_id}\n    for (int i = 0; i < n; ++i) {\n        people.emplace_back(confidence[i], i);\n    }\n\n    // Sort people by decreasing confidence\n    std::sort(people.rbegin(), people.rend());\n\n    std::unordered_set<int> selected; // Selected people for the sample\n    std::unordered_set<int> forbidden; // Forbidden people (friends of selected)\n\n    for (const auto& [conf, person_id] : people) {\n        if (forbidden.count(person_id) == 0) {\n            // If person is not forbidden, add to the sample\n            selected.insert(person_id);\n\n            // Mark all friends of this person as forbidden\n            for (int friend_id : friends[person_id]) {\n                forbidden.insert(friend_id);\n            }\n        }\n    }\n\n    // Calculate total confidence of the selected sample\n    int total_confidence = 0;\n    for (int person_id : selected) {\n        total_confidence += confidence[person_id];\n    }\n\n    return total_confidence;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 16:27:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/D",
    "title": "D. The Big Prize",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "D",
    "submission_id": "314977797",
    "code_index": 0,
    "code": "#include <vector>\nusing namespace std;\n\n// Function to find the box containing the diamond\nint find_best(int n) {\n    int left = 0, right = n - 1;\n\n    // Binary search to narrow down the box containing the diamond\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        vector<int> response = ask(mid);\n\n        // If the diamond is in the current box\n        if (response[0] == 0 && response[1] == 0) {\n            return mid;\n        }\n\n        // If there are more expensive prizes to the left of the current box\n        if (response[0] > 0) {\n            right = mid - 1;\n        } else { // If there are more expensive prizes to the right of the current box\n            left = mid + 1;\n        }\n    }\n\n    // This point should never be reached if the input guarantees one diamond\n    return -1; \n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 16:28:02",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/D",
    "title": "D. The Big Prize",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "D",
    "submission_id": "314977857",
    "code_index": 1,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nint find_best(int n) {\n    int left = 0, right = n - 1;\n\n    while (left < right) {\n        // Midpoint of the current range\n        int mid = (left + right) / 2;\n\n        // Ask about the midpoint box\n        vector<int> a = ask(mid);\n\n        // If both a[0] and a[1] are zero, this is the diamond\n        if (a[0] == 0 && a[1] == 0) {\n            return mid;\n        }\n\n        // If there are more expensive prizes to the left, narrow the search to the left half\n        if (a[0] > 0) {\n            right = mid - 1;\n        } \n        // Otherwise, narrow the search to the right half\n        else {\n            left = mid + 1;\n        }\n    }\n\n    // At this point, left == right, so this must be the diamond\n    return left;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 16:28:44",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/D",
    "title": "D. The Big Prize",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "D",
    "submission_id": "314977937",
    "code_index": 2,
    "code": "// Your code will be placed here\n\n#include <vector>\nusing namespace std;\n\n// Declaration of the ask function as specified in the problem.\nvector<int> ask(int i);\n\nint find_best(int n) {\n    int left = 0, right = n - 1;\n\n    while (left < right) {\n        int mid = (left + right) / 2;\n        vector<int> response = ask(mid);\n        \n        int left_more_expensive = response[0];\n        int right_more_expensive = response[1];\n\n        // If the diamond is at mid, both left and right counts of more expensive prizes will be 0.\n        if (left_more_expensive == 0 && right_more_expensive == 0) {\n            return mid;\n        }\n\n        // If there are more expensive prizes to the left, the diamond must be in the left half.\n        if (left_more_expensive > 0) {\n            right = mid - 1;\n        }\n        // Otherwise, the diamond must be in the right half.\n        else {\n            left = mid + 1;\n        }\n    }\n\n    // When left == right, we have found the diamond's position.\n    return left;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 16:29:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/D",
    "title": "D. The Big Prize",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "D",
    "submission_id": "314977937",
    "code_index": 3,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nint find_best(int n) {\n    // Binary search to find the diamond\n    int left = 0, right = n - 1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        vector<int> result = ask(mid); // Query the mid box\n        \n        // If the current box is the diamond, return its index\n        if (result[0] == 0 && result[1] == 0) {\n            return mid;\n        }\n        \n        // Use the response to narrow down the search\n        if (result[0] > 0) {\n            // There are more expensive prizes to the left\n            right = mid - 1;\n        } else {\n            // There are more expensive prizes to the right\n            left = mid + 1;\n        }\n    }\n    return -1; // This should never happen if the input guarantees a diamond\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 16:29:59",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/D",
    "title": "D. The Big Prize",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "D",
    "submission_id": "314978070",
    "code_index": 4,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nint find_best(int n) {\n    // A helper function to determine if a box contains the diamond.\n    auto is_diamond = [&](int i, const vector<int>& response) -> bool {\n        // If the response is [0, 0], it means there are no more expensive prizes\n        // to the left or right, so this box must contain the diamond.\n        return response[0] == 0 && response[1] == 0;\n    };\n    \n    // Binary search approach to minimize the number of queries\n    int left = 0, right = n - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        vector<int> response = ask(mid); // Query the box at position 'mid'\n\n        if (is_diamond(mid, response)) {\n            // If the current box contains the diamond, return its index\n            return mid;\n        }\n\n        // Use the response to decide which half to search next\n        // If there are more expensive prizes to the left of mid, search the left half\n        if (response[0] > 0) {\n            right = mid - 1;\n        } else {\n            // Otherwise, search the right half\n            left = mid + 1;\n        }\n    }\n    \n    // This point should never be reached as there is guaranteed to be exactly one diamond\n    return -1;\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 16:30:56",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/E",
    "title": "E. Robots",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "E",
    "submission_id": "314978150",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include \"robots.h\"\n\n// Helper function to check if all toys can be put away in `minutes` time\nbool canPutAway(int minutes, const std::vector<int>& weakLimits, const std::vector<int>& smallLimits, const std::vector<int>& weights, const std::vector<int>& sizes) {\n    std::multiset<int> weakRobots(weakLimits.begin(), weakLimits.end());\n    std::multiset<int> smallRobots(smallLimits.begin(), smallLimits.end());\n\n    // Handle toys that require both weak and small robots\n    std::vector<std::pair<int, int>> bothRequired;\n    for (size_t i = 0; i < weights.size(); ++i) {\n        bothRequired.emplace_back(weights[i], sizes[i]);\n    }\n    std::sort(bothRequired.begin(), bothRequired.end());\n\n    for (int i = 0; i < minutes; ++i) {\n        std::multiset<int> availableWeak = weakRobots;\n        std::multiset<int> availableSmall = smallRobots;\n        \n        // Try to match toy"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 16:31:36",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/E",
    "title": "E. Robots",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "E",
    "submission_id": "314978201",
    "code_index": 1,
    "code": "#include \"robots.h\"\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <climits>\n\nusing namespace std;\n\n// Helper function to check if all toys can be put away in `time` minutes\nbool canPutAway(int time, int A, int B, int T, vector<int>& X, vector<int>& Y, vector<int>& W, vector<int>& S) {\n    // Multisets to store the limits of robots\n    multiset<int> weakRobots(X.begin(), X.end());\n    multiset<int> smallRobots(Y.begin(), Y.end());\n\n    // List of toys that need to be handled\n    vector<pair<int, int>> toys; // {weight, size}\n    for (int i = 0; i < T; ++i) {\n        toys.emplace_back(W[i], S[i]);\n    }\n\n    // Sort toys so that we handle the hardest-to-place toys first\n    sort(toys.begin(), toys.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return max(a.first, a.second) > max(b.first, b.second);\n    });\n\n    for (int i = 0; i < T;) {\n        int handled = 0; // Number of toys handled in this iteration\n\n        // Temporary copies of robot limits for this iteration\n        multiset<int> tempWeakRobots = weakRobots;\n        multiset<int> tempSmallRobots = smallRobots;\n\n        for (int j = 0; j < time && i < T; ++j) {\n            auto& [weight, size] = toys[i];\n\n            // Try to use a weak robot\n            auto itWeak = tempWeakRobots.lower_bound(weight + 1);\n            bool usedWeak = false;\n            if (itWeak != tempWeakRobots.end()) {\n                tempWeakRobots.erase(itWeak);\n                usedWeak = true;\n            }\n\n            // Try to use a small robot if a weak robot wasn't used\n            if (!usedWeak) {\n                auto itSmall = tempSmallRobots.lower_bound(size + 1);\n                if (itSmall != tempSmallRobots.end()) {\n                    tempSmallRobots.erase(itSmall);\n                } else {\n                    // If neither a weak nor a small robot can handle this toy, return false\n                    return false;\n                }\n            }\n\n            // If a robot was successfully used, mark the toy as handled\n            ++handled;\n            ++i;\n        }\n\n        // If no toys were handled in this iteration, it's impossible to proceed\n        if (handled == 0) return false;\n    }\n\n    // If all toys have been handled, return true\n    return true;\n}\n\nint putaway(int A, int B, int T, int X[], int Y[], int W[], int S[]) {\n    // Convert input arrays to vectors for easier manipulation\n    vector<int> weakRobots(X, X + A);\n    vector<int> smallRobots(Y, Y + B);\n    vector<int> toyWeights(W, W + T);\n    vector<int> toySizes(S, S + T);\n\n    // Check if any toy cannot be handled by any robot\n    for (int i = 0; i < T; ++i) {\n        bool canBeHandled = false;\n\n        // Check if any weak robot can handle the toy\n        for (int x : weakRobots) {\n            if (toyWeights[i] < x) {\n                canBeHandled = true;\n                break;\n            }\n        }\n\n        // Check if any small robot can handle the toy\n        for (int y : smallRobots) {\n            if (toySizes[i] < y) {\n                canBeHandled = true;\n                break;\n            }\n        }\n\n        // If no robot can handle this toy, return -1\n        if (!canBeHandled) return -1;\n    }\n\n    // Binary search for the minimum time\n    int left = 1, right = T, result = T;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (canPutAway(mid, A, B, T, weakRobots, smallRobots, toyWeights, toySizes)) {\n            result = mid; // Update result and try for a smaller time\n            right = mid - 1;\n        } else {\n            left = mid + 1; // Try for a larger time\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 16:32:14",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/E",
    "title": "E. Robots",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "E",
    "submission_id": "314978254",
    "code_index": 2,
    "code": "#include \"robots.h\"\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n// Helper function to check if all toys can be put away in 'minutes' time\nbool canPutAwayInTime(int minutes, const vector<int>& weak_limits, const vector<int>& small_limits, const vector<pair<int, int>>& toys) {\n    // Separate toys into weak and small categories\n    vector<int> weak_toys, small_toys;\n    for (const auto& toy : toys) {\n        if (toy.first < weak_limits.front()) weak_toys.push_back(toy.second); // Toys valid for weak robots\n        if (toy.second < small_limits.front()) small_toys.push_back(toy.first); // Toys valid for small robots\n    }\n    \n    // Sort the toys in descending order for efficient allocation\n    sort(weak_toys.begin(), weak_toys.end(), greater<int>());\n    sort(small_toys.begin(), small_toys.end(), greater<int>());\n\n    // Simulate toy allocation to robots\n    auto allocateToys = [&](const vector<int>& robots, vector<int>& toys) -> bool {\n        int robot_count = robots.size();\n        for (int i = 0; i < minutes; ++i) {\n            for (int j = 0; j < robot_count; ++j) {\n                if (!toys.empty() && toys.back() < robots[j]) {\n                    toys.pop_back(); // Assign toy to robot\n                }\n            }\n        }\n        return toys.empty(); // All toys successfully assigned\n    };\n\n    // Check if weak robots can handle weak toys\n    if (!allocateToys(weak_limits, weak_toys)) return false;\n\n    // Check if small robots can handle small toys\n    if (!allocateToys(small_limits, small_toys)) return false;\n\n    return true;\n}\n\nint putaway(int A, int B, int T, int X[], int Y[], int W[], int S[]) {\n    // Convert input arrays to vectors for easier manipulation\n    vector<int> weak_limits(X, X + A);\n    vector<int> small_limits(Y, Y + B);\n    vector<pair<int, int>> toys(T);\n    for (int i = 0; i < T; ++i) {\n        toys[i] = {W[i], S[i]};\n    }\n\n    // Sort robot limits and toys\n    sort(weak_limits.begin(), weak_limits.end());\n    sort(small_limits.begin(), small_limits.end());\n    sort(toys.begin(), toys.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.first < b.first || (a.first == b.first && a.second < b.second);\n    });\n\n    // Check if there's any toy that cannot be handled by any robot\n    for (const auto& toy : toys) {\n        if (toy.first >= weak_limits.back() && toy.second >= small_limits.back()) {\n            return -1; // Impossible to put away this toy\n        }\n    }\n\n    // Perform binary search to find the minimum time\n    int low = 1, high = T, result = -1;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        if (canPutAwayInTime(mid, weak_limits, small_limits, toys)) {\n            result = mid; // Update result\n            high = mid - 1; // Try for a smaller time\n        } else {\n            low = mid + 1; // Try for a larger time\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2017 day 1",
    "timestamp": "2025-04-11 16:33:14",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103774/problem/B",
    "title": "B. Wiring",
    "group_id": "32KGsXgiKA",
    "contest_id": "103774",
    "problem_index": "B",
    "submission_id": "314978348",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cstdint>\n#include <algorithm>\n#include <cmath>\n\nint64_t min_total_length(std::vector<int> r, std::vector<int> b) {\n    int n = r.size();\n    int m = b.size();\n\n    int i = 0, j = 0; // Pointers for red and blue arrays\n    int64_t total_length = 0;\n\n    // Two-pointer approach\n    while (i < n && j < m) {\n        // Connect the closest red and blue points\n        total_length += std::abs(r[i] - b[j]);\n        \n        // Move the pointer of the smaller value forward\n        if (r[i] < b[j]) {\n            ++i;\n        } else {\n            ++j;\n        }\n    }\n\n    // If there are remaining red points, connect them\n    while (i < n) {\n        total_length += std::abs(r[i] - b[m - 1]); // Connect to the last blue point\n        ++i;\n    }\n\n    // If there are remaining blue points, connect them\n    while (j < m) {\n        total_length += std::abs(b[j] - r[n - 1]); // Connect to the last red point\n        ++j;\n    }\n\n    return total_length;\n}"
  },
  {
    "date": "IOI 2017 day 1",
    "timestamp": "2025-04-11 16:34:00",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103774/problem/B",
    "title": "B. Wiring",
    "group_id": "32KGsXgiKA",
    "contest_id": "103774",
    "problem_index": "B",
    "submission_id": "314978429",
    "code_index": 1,
    "code": "#include <vector>\n#include <cmath>\n#include <cstdint>\n#include <algorithm>\n\nint64_t min_total_length(std::vector<int> r, std::vector<int> b) {\n    int n = r.size();\n    int m = b.size();\n    int i = 0, j = 0; // Pointers for red and blue arrays\n    int64_t total_length = 0;\n\n    // Create arrays to store the minimum connection distances\n    std::vector<int> min_red(n, INT32_MAX);\n    std::vector<int> min_blue(m, INT32_MAX);\n\n    // First pass: Calculate minimum distances from red to blue\n    while (i < n && j < m) {\n        if (r[i] < b[j]) {\n            min_red[i] = std::min(min_red[i], std::abs(r[i] - b[j]));\n            ++i;\n        } else {\n            min_blue[j] = std::min(min_blue[j], std::abs(b[j] - r[i]));\n            ++j;\n        }\n    }\n\n    // Second pass: Calculate minimum distances in the reverse direction\n    i = n - 1;\n    j = m - 1;\n    while (i >= 0 && j >= 0) {\n        if (r[i] > b[j]) {\n            min_red[i] = std::min(min_red[i], std::abs(r[i] - b[j]));\n            --i;\n        } else {\n            min_blue[j] = std::min(min_blue[j], std::abs(b[j] - r[i]));\n            --j;\n        }\n    }\n\n    // Compute the total length of wires\n    for (int x = 0; x < n; ++x) {\n        total_length += min_red[x];\n    }\n    for (int y = 0; y < m; ++y) {\n        total_length += min_blue[y];\n    }\n\n    return total_length;\n}"
  },
  {
    "date": "IOI 2017 day 1",
    "timestamp": "2025-04-11 16:34:38",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103774/problem/B",
    "title": "B. Wiring",
    "group_id": "32KGsXgiKA",
    "contest_id": "103774",
    "problem_index": "B",
    "submission_id": "314978500",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\n#include <cstdint>\nusing namespace std;\n\nint64_t min_total_length(vector<int> r, vector<int> b) {\n    int n = r.size(); // Number of red points\n    int m = b.size(); // Number of blue points\n    int i = 0, j = 0; // Pointers for red and blue points\n    int64_t total_length = 0;\n\n    // Use two-pointer technique\n    while (i < n && j < m) {\n        // Connect the closest red and blue points\n        if (r[i] <= b[j]) {\n            // r[i] is closer to b[j] than the next blue point\n            total_length += abs(r[i] - b[j]);\n            i++; // Move to the next red point\n        } else {\n            // b[j] is closer to r[i] than the next red point\n            total_length += abs(r[i] - b[j]);\n            j++; // Move to the next blue point\n        }\n    }\n\n    // Connect remaining red points to their closest blue points\n    while (i < n) {\n        total_length += abs(r[i] - b[m - 1]); // Closest is the last blue point\n        i++;\n    }\n\n    // Connect remaining blue points to their closest red points\n    while (j < m) {\n        total_length += abs(b[j] - r[n - 1]); // Closest is the last red point\n        j++;\n    }\n\n    return total_length;\n}"
  },
  {
    "date": "IOI 2017 day 1",
    "timestamp": "2025-04-11 16:35:16",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103774/problem/B",
    "title": "B. Wiring",
    "group_id": "32KGsXgiKA",
    "contest_id": "103774",
    "problem_index": "B",
    "submission_id": "314978552",
    "code_index": 3,
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdint>\n#include <cmath>\n\n// Your code will be placed here\nint64_t min_total_length(std::vector<int> r, std::vector<int> b) {\n    int n = r.size(); // Number of red connection points\n    int m = b.size(); // Number of blue connection points\n    \n    // Maintain minimum total length\n    int64_t total_length = 0;\n\n    // Pointers for iterating through red and blue arrays\n    int i = 0, j = 0;\n\n    // Process each connection point\n    while (i < n || j < m) {\n        if (i < n && (j == m || r[i] < b[j])) {\n            // Red point needs to be connected\n            int closest_blue = (j > 0 ? b[j - 1] : b[j]);\n            int next_blue = (j < m ? b[j] : b[j - 1]);\n            int distance = std::min(std::abs(r[i] - closest_blue), std::abs(r[i] - next_blue));\n            total_length += distance;\n            i++;\n        } else {\n            // Blue point needs to be connected\n            int closest_red = (i > 0 ? r[i - 1] : r[i]);\n            int next_red = (i < n ? r[i] : r[i - 1]);\n            int distance = std::min(std::abs(b[j] - closest_red), std::abs(b[j] - next_red));\n            total_length += distance;\n            j++;\n        }\n    }\n\n    return total_length;\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 16:36:14",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/B",
    "title": "B. Roller Coaster Railroad",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "B",
    "submission_id": "314978652",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\nusing namespace std;\n\nint64_t plan_roller_coaster(vector<int> s, vector<int> t) {\n    int n = s.size();\n\n    // Subtask 3: Check if the roller coaster can be constructed with zero-length tracks\n    // This requires that the exit speed of one section is always less than or equal to the entry speed of the next section.\n    vector<pair<int, int>> sections(n);\n    for (int i = 0; i < n; i++) {\n        sections[i] = {t[i], s[i]};\n    }\n    sort(sections.begin(), sections.end());\n\n    for (int i = 1; i < n; i++) {\n        if (sections[i - 1].first > sections[i].second) {\n            // Not possible to connect with zero-length tracks\n            return 1;\n        }\n    }\n\n    // If we are here, zero-length tracks are possible\n    return 0;\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 16:37:00",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/B",
    "title": "B. Roller Coaster Railroad",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "B",
    "submission_id": "314978652",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\n// Function to compute the minimum track length or check feasibility\nint64_t plan_roller_coaster(vector<int> s, vector<int> t) {\n    int n = s.size();\n    \n    // Subtask 3: Check if zero-length tracks are possible\n    if (n <= 200000) {\n        // Sort sections by exit speed to check feasibility of zero-length tracks\n        vector<pair<int, int>> sections(n);\n        for (int i = 0; i < n; ++i) {\n            sections[i] = {t[i], s[i]};\n        }\n        sort(sections.begin(), sections.end()); // Sort by exit speed\n\n        // Start with initial speed of 1 km/h\n        int current_speed = 1;\n        for (int i = 0; i < n; ++i) {\n            int max_entry_speed = sections[i].second; // speed limit of this section\n            if (current_speed > max_entry_speed) {\n                return 1; // Not feasible for zero-length tracks\n            }\n            current_speed = sections[i].first; // Update speed after leaving this section\n        }\n        return 0; // Feasible for zero-length tracks\n    }\n\n    // Subtasks 1, 2, and 4: Minimize total track length\n    // Use dynamic programming to calculate the minimum track length\n    vector<int64_t> dp(n, numeric_limits<int64_t>::max());\n    dp[0] = 0; // Starting with first section\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (t[j] <= s[i]) { // Valid transition\n                dp[i] = min(dp[i], dp[j] + max(0, s[i] - t[j]));\n            }\n        }\n    }\n\n    return *min_element(dp.begin(), dp.end());\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 16:37:41",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/B",
    "title": "B. Roller Coaster Railroad",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "B",
    "submission_id": "314978787",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\nusing namespace std;\n\nint64_t plan_roller_coaster(vector<int> s, vector<int> t) {\n    int n = s.size();\n    \n    // Sort sections based on their exit speeds (t_i) in ascending order.\n    // If two sections have the same t_i, sort by s_i in descending order.\n    vector<pair<int, int>> sections(n);\n    for (int i = 0; i < n; i++) {\n        sections[i] = {t[i], s[i]};\n    }\n    sort(sections.begin(), sections.end());\n\n    // Start with the initial speed of the train\n    int current_speed = 1;\n    int64_t total_length = 0;\n\n    for (int i = 0; i < n; i++) {\n        int t_i = sections[i].first;\n        int s_i = sections[i].second;\n\n        // Ensure the train's speed does not violate the speed limit when entering\n        if (current_speed > s_i) {\n            total_length += (current_speed - s_i);\n            current_speed = s_i;\n        }\n\n        // Train leaves the section at the specified exit speed\n        current_speed = t_i;\n    }\n\n    return total_length;\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 16:38:20",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/B",
    "title": "B. Roller Coaster Railroad",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "B",
    "submission_id": "314978841",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nusing namespace std;\n\nint64_t plan_roller_coaster(vector<int> s, vector<int> t) {\n    int n = s.size();\n    vector<pair<int, int>> sections(n); // Pair of (exit speed t[i], entry speed limit s[i])\n    \n    for (int i = 0; i < n; ++i) {\n        sections[i] = {t[i], s[i]};\n    }\n    \n    // Sort sections by exit speed (t[i]) in ascending order\n    sort(sections.begin(), sections.end());\n    \n    int64_t total_track_length = 0;\n    int current_speed = 1; // Initial speed of the train\n    \n    for (int i = 0; i < n; ++i) {\n        int speed_limit = sections[i].second; // s[i]\n        int exit_speed = sections[i].first;  // t[i]\n        \n        // Ensure the train enters the section within the speed limit\n        if (current_speed > speed_limit) {\n            // If the current speed is too high, we need to add track to slow down\n            total_track_length += (current_speed - speed_limit);\n            current_speed = speed_limit;\n        }\n        \n        // After exiting the section, the train speed is set to t[i]\n        current_speed = exit_speed;\n    }\n    \n    return total_track_length;\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 16:39:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/C",
    "title": "C. Shortcut",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "C",
    "submission_id": "314978938",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n#include <numeric>\n#include <limits>\nusing namespace std;\n\nint64_t find_shortcut(int n, vector<int> l, vector<int> d, int c) {\n    // Calculate prefix sums for the main line distances\n    vector<int64_t> prefix_sum(n, 0);\n    for (int i = 1; i < n; i++) {\n        prefix_sum[i] = prefix_sum[i - 1] + l[i - 1];\n    }\n\n    // Compute distances from station 0 to all stations (left-to-right)\n    vector<int64_t> dist_to_left(n, 0);\n    for (int i = 0; i < n; i++) {\n        dist_to_left[i] = prefix_sum[i];\n    }\n\n    // Compute distances from station n-1 to all stations (right-to-left)\n    vector<int64_t> dist_to_right(n, 0);\n    for (int i = 0; i < n; i++) {\n        dist_to_right[i] = prefix_sum[n - 1] - prefix_sum[i];\n    }\n\n    // Compute max distances for stations considering secondary lines\n    vector<int64_t> max_dist(n, 0);\n    for (int i = 0; i < n; i++) {\n        max_dist[i] = max(dist_to_left[i], dist_to_right[i]);\n        if (d[i] > 0) {\n            max_dist[i] = max(max_dist[i], d[i]);\n        }\n    }\n\n    // Precompute the global maximum distance without any shortcut\n    int64_t global_max = *max_element(max_dist.begin(), max_dist.end());\n\n    // Try adding the express line between all pairs of stations (i, j)\n    int64_t result = numeric_limits<int64_t>::max();\n    int64_t min_left = numeric_limits<int64_t>::max();\n\n    for (int i = 0, j = 0; i < n; i++) {\n        // Update the minimum distance to the left\n        min_left = min(min_left, dist_to_left[i] + d[i]);\n\n        // Calculate the potential new diameter if we connect i and j\n        int64_t candidate_diameter = max(global_max, max(dist_to_left[i], dist_to_right[j]) + c);\n        result = min(result, candidate_diameter);\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 16:39:48",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/C",
    "title": "C. Shortcut",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "C",
    "submission_id": "314978988",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n#include <numeric>\n#include <limits>\n\nusing namespace std;\n\nint64_t find_shortcut(int n, vector<int> l, vector<int> d, int c) {\n    // Step 1: Precompute distances on the main line\n    vector<int64_t> prefix_sum(n, 0);\n    for (int i = 1; i < n; ++i) {\n        prefix_sum[i] = prefix_sum[i - 1] + l[i - 1];\n    }\n\n    // Step 2: Precompute maximum distances to secondary stations\n    vector<int64_t> max_secondary_dist(n, 0);\n    for (int i = 0; i < n; ++i) {\n        max_secondary_dist[i] = d[i];\n    }\n\n    // Step 3: Calculate the initial diameter of the main line\n    int64_t initial_diameter = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int64_t dist = prefix_sum[j] - prefix_sum[i];\n            initial_diameter = max(initial_diameter, dist);\n        }\n    }\n\n    // Step 4: Evaluate all possible shortcuts\n    int64_t result = numeric_limits<int64_t>::max();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            // Shortcut between station i and station j\n            int64_t shortcut_diameter = 0;\n\n            // Compute maximum distance for each station\n            for (int k = 0; k < n; ++k) {\n                int64_t to_i = abs(prefix_sum[k] - prefix_sum[i]);\n                int64_t to_j = abs(prefix_sum[k] - prefix_sum[j]);\n                int64_t dist_via_shortcut = min(to_i + c, to_j + c);\n                int64_t max_dist = min(dist_via_shortcut, max_secondary_dist[k]);\n                shortcut_diameter = max(shortcut_diameter, max_dist);\n            }\n\n            // Update the result with the minimum diameter\n            result = min(result, shortcut_diameter);\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 16:40:27",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/C",
    "title": "C. Shortcut",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "C",
    "submission_id": "314979041",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cstdint>\nusing namespace std;\n\nint64_t find_shortcut(int n, vector<int> l, vector<int> d, int c) {\n    // Calculate prefix sums to efficiently compute distances along the main line\n    vector<int64_t> prefix_sum(n, 0);\n    for (int i = 1; i < n; ++i) {\n        prefix_sum[i] = prefix_sum[i - 1] + l[i - 1];\n    }\n\n    // Calculate distances from each station to the furthest reachable point via secondary lines\n    vector<int64_t> max_distance_from(n, 0);\n    vector<int64_t> max_distance_to(n, 0);\n\n    for (int i = 0; i < n; ++i) {\n        if (d[i] > 0) {\n            max_distance_from[i] = prefix_sum[i] + d[i];\n            max_distance_to[i] = prefix_sum[i] - d[i];\n        } else {\n            max_distance_from[i] = prefix_sum[i];\n            max_distance_to[i] = prefix_sum[i];\n        }\n    }\n\n    // Compute the initial diameter of the network\n    int64_t initial_diameter = 0;\n    int64_t min_distance_to = *min_element(max_distance_to.begin(), max_distance_to.end());\n    int64_t max_distance_from = *max_element(max_distance_from.begin(), max_distance_from.end());\n    initial_diameter = max_distance_from - min_distance_to;\n\n    // Try adding the express line between all pairs of stations and minimize the diameter\n    int64_t result = initial_diameter;\n\n    int64_t min_prefix = prefix_sum[0];\n    for (int i = 0; i < n; ++i) {\n        // Update the minimum prefix encountered so far\n        min_prefix = min(min_prefix, prefix_sum[i]);\n        // Calculate the maximum possible distance reduction by connecting station i to any earlier station\n        result = min(result, max(max_distance_from[i], max_distance_from[n - 1]) - (min(min_prefix + c, min_distance_to)));\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 16:41:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/C",
    "title": "C. Shortcut",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "C",
    "submission_id": "314979119",
    "code_index": 3,
    "code": "// Your code will be placed here\n\n#include <vector>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\nint64_t find_shortcut(int n, vector<int> l, vector<int> d, int c) {\n    // Step 1: Compute prefix sums for distances on the main line\n    vector<int64_t> prefix_sum(n, 0);\n    for (int i = 1; i < n; ++i) {\n        prefix_sum[i] = prefix_sum[i - 1] + l[i - 1];\n    }\n\n    // Step 2: Compute distances to secondary stations\n    vector<int64_t> to_secondary(n, numeric_limits<int64_t>::max());\n    for (int i = 0; i < n; ++i) {\n        if (d[i] > 0) {\n            to_secondary[i] = d[i];\n        }\n    }\n\n    // Step 3: Compute the initial diameter of the network\n    int64_t initial_diameter = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int64_t dist = prefix_sum[j] - prefix_sum[i]; // Distance between station i and j\n            initial_diameter = max(initial_diameter, dist);\n        }\n        // Include secondary station distances\n        if (to_secondary[i] != numeric_limits<int64_t>::max()) {\n            initial_diameter = max(initial_diameter, to_secondary[i]);\n        }\n    }\n\n    // Step 4: Evaluate all express line placements\n    int64_t min_diameter = numeric_limits<int64_t>::max();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            // Add express line between station i and j\n            int64_t new_diameter = 0;\n\n            // Compute maximum distance considering the express line\n            for (int k = 0; k < n; ++k) {\n                for (int m = k + 1; m < n; ++m) {\n                    int64_t dist_main = prefix_sum[m] - prefix_sum[k];\n                    int64_t dist_with_express = numeric_limits<int64_t>::max();\n\n                    if ((k <= i && i <= m) || (k <= j && j <= m)) {\n                        dist_with_express = min(dist_with_express, dist_main);\n                    }\n                    new_diameter = max(new_diameter, dist_with_express);\n                }\n            }\n            min_diameter = min(min_diameter, new_diameter);\n        }\n    }\n\n    return min_diameter;\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 16:42:05",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/E",
    "title": "E. Memory",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "E",
    "submission_id": "314979210",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\n// Grader function (provided by the grader)\nchar faceup(int C);\n\n// Function to implement the game logic\nvoid play() {\n    // Data structure to store discovered cards for each letter\n    unordered_map<char, vector<int>> letter_to_cards;\n    \n    // Iterate through all 50 cards\n    for (int i = 1; i <= 50; ++i) {\n        // Flip the current card\n        char letter = faceup(i);\n\n        // Check if this letter has been seen before\n        if (letter_to_cards[letter].empty()) {\n            // First occurrence of this letter, store its index\n            letter_to_cards[letter].push_back(i);\n        } else {\n            // Second occurrence of this letter, form a pair\n            int previous_card = letter_to_cards[letter][0];\n            \n            // Flip the second card to form a matching pair\n            faceup(previous_card);\n            \n            // Once paired, we don't need to track this letter anymore\n            letter_to_cards[letter].clear();\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 16:42:50",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/E",
    "title": "E. Memory",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "E",
    "submission_id": "314979293",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <utility>  // for std::pair\n\n// Function to play the game\nvoid play() {\n    // Map to store the first occurrence of each letter\n    std::unordered_map<char, int> seen;\n    \n    // Iterate over all 50 cards\n    for (int i = 1; i <= 50; ++i) {\n        // Turn the card face up and get the letter\n        char letter = faceup(i);\n        \n        // Check if the letter has been seen before\n        if (seen.count(letter)) {\n            // If seen, we found a pair\n            int firstCard = seen[letter];\n            \n            // Turn the first card face up to confirm the pair\n            faceup(firstCard);\n            \n            // Remove the letter from the map (pair is complete)\n            seen.erase(letter);\n        } else {\n            // If not seen, record the position of this card\n            seen[letter] = i;\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 16:43:28",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/E",
    "title": "E. Memory",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "E",
    "submission_id": "314979340",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <utility>\n\nvoid play() {\n    // A map to keep track of the first occurrence of each letter\n    std::unordered_map<char, int> letter_to_card;\n    \n    // Iterate through all 50 cards\n    for (int i = 1; i <= 50; ++i) {\n        // Turn the current card face up\n        char letter = faceup(i);\n\n        // Check if we've already seen this letter before\n        if (letter_to_card.find(letter) != letter_to_card.end()) {\n            // If we have, turn the card that we previously saw face up\n            faceup(letter_to_card[letter]);\n            \n            // Remove the letter from the map since we've matched it\n            letter_to_card.erase(letter);\n        } else {\n            // Otherwise, store the current card position as the first occurrence of this letter\n            letter_to_card[letter] = i;\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 16:44:14",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/E",
    "title": "E. Memory",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "E",
    "submission_id": "314979421",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <utility>\nusing namespace std;\n\n// Grader-provided function.\nchar faceup(int C);\n\n// Function to implement the Memory game strategy.\nvoid play() {\n    // Map to store the positions of each revealed letter\n    unordered_map<char, vector<int>> card_positions;\n\n    // Iterate through all cards.\n    for (int i = 1; i <= 50; ++i) {\n        // Reveal the card.\n        char letter = faceup(i);\n\n        // Check if the letter has already been revealed once.\n        if (card_positions[letter].size() == 1) {\n            // If this is the second occurrence of the letter, pair it with the first.\n            int first_card = card_positions[letter][0];\n            faceup(first_card); // Turn the first card face up again.\n            // After this step, Jack gets a candy, and the grader turns both cards face down.\n        } else {\n            // Otherwise, store the position of the card for future matching.\n            card_positions[letter].push_back(i);\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 16:44:55",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/E",
    "title": "E. Memory",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "E",
    "submission_id": "314979495",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <utility>\nusing namespace std;\n\n// Function to play the Memory game\nvoid play() {\n    unordered_map<char, pair<int, int>> letter_positions; // Map to store positions of each letter\n    vector<int> unvisited_cards(50); // List of unvisited cards\n    for (int i = 0; i < 50; ++i) {\n        unvisited_cards[i] = i + 1; // Cards are numbered 1 to 50\n    }\n\n    // Iterate over all unvisited cards to discover letter positions\n    for (int i = 0; i < 50; ++i) {\n        int card = unvisited_cards[i];\n        char letter = faceup(card); // Turn the card face up to reveal its letter\n        if (letter_positions.find(letter) == letter_positions.end()) {\n            // First occurrence of this letter\n            letter_positions[letter] = {card, -1};\n        } else {\n            // Second occurrence of this letter\n            letter_positions[letter].second = card;\n\n            // Turn both cards face up to collect the candy\n            faceup(letter_positions[letter].first);\n            faceup(letter_positions[letter].second);\n        }\n    }\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 16:45:41",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/A",
    "title": "A. Arranging Shoes",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "A",
    "submission_id": "314979579",
    "code_index": 0,
    "code": "#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\n\n// Your code will be placed here\nint64_t count_swaps(vector<int> S) {\n    int n = S.size() / 2;\n    vector<int> left_positions(n + 1, -1);\n    vector<int> right_positions(n + 1, -1);\n\n    // Separate left and right shoe positions by size\n    for (int i = 0; i < 2 * n; ++i) {\n        int size = abs(S[i]);\n        if (S[i] < 0) {\n            left_positions[size] = i;\n        } else {\n            right_positions[size] = i;\n        }\n    }\n\n    // Initialize total swaps counter\n    int64_t total_swaps = 0;\n\n    // Traverse the positions to fix pairs in order\n    for (int i = 0; i < n; ++i) {\n        int left_index = 2 * i;\n        int right_index = 2 * i + 1;\n\n        // Fix the left shoe\n        if (S[left_index] >= 0 || abs(S[left_index]) != i + 1) {\n            int target_index = left_positions[i + 1];\n            while (target_index > left_index) {\n                swap(S[target_index], S[target_index - 1]);\n                --target_index;\n                ++total_swaps;\n            }\n            left_positions[i + 1] = left_index;\n        }\n\n        // Fix the right shoe\n        if (S[right_index] <= 0 || abs(S[right_index]) != i + 1) {\n            int target_index = right_positions[i + 1];\n            while (target_index > right_index) {\n                swap(S[target_index], S[target_index - 1]);\n                --target_index;\n                ++total_swaps;\n            }\n            right_positions[i + 1] = right_index;\n        }\n    }\n\n    return total_swaps;\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 16:46:27",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/A",
    "title": "A. Arranging Shoes",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "A",
    "submission_id": "314979654",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nint64_t count_swaps(std::vector<int> S) {\n    int n = S.size() / 2; // Number of pairs\n    int64_t swaps = 0; // Total swaps counter\n\n    // Iterate over each pair to be formed\n    for (int i = 0; i < n; ++i) {\n        // Determine the left shoe position\n        int target_left = -1; // Position of the left shoe (-x)\n        for (int j = 2 * i; j < S.size(); ++j) {\n            if (S[j] < 0 && std::abs(S[j]) == i + 1) {\n                target_left = j;\n                break;\n            }\n        }\n\n        // Bring the left shoe to position 2*i\n        for (int j = target_left; j > 2 * i; --j) {\n            std::swap(S[j], S[j - 1]);\n            ++swaps;\n        }\n\n        // Determine the right shoe position\n        int target_right = -1; // Position of the right shoe (+x)\n        for (int j = 2 * i + 1; j < S.size(); ++j) {\n            if (S[j] > 0 && S[j] == i + 1) {\n                target_right = j;\n                break;\n            }\n        }\n\n        // Bring the right shoe to position 2*i + 1\n        for (int j = target_right; j > 2 * i + 1; --j) {\n            std::swap(S[j], S[j - 1]);\n            ++swaps;\n        }\n    }\n\n    return swaps;\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 16:47:06",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/A",
    "title": "A. Arranging Shoes",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "A",
    "submission_id": "314979732",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nint64_t count_swaps(std::vector<int> S) {\n    int64_t swaps = 0;\n    int n = S.size() / 2; // Number of pairs\n    \n    // Iterate through each pair\n    for (int i = 0; i < n; ++i) {\n        int left_pos = 2 * i;\n        int right_pos = 2 * i + 1;\n\n        // Ensure the left shoe is at position 2i\n        if (S[left_pos] > 0 || abs(S[left_pos]) != abs(S[right_pos])) {\n            // Find the correct left shoe (negative value with the same size as S[right_pos])\n            for (int j = left_pos + 1; j < S.size(); ++j) {\n                if (S[j] < 0 && abs(S[j]) == abs(S[right_pos])) {\n                    // Swap S[j] to position left_pos\n                    for (int k = j; k > left_pos; --k) {\n                        std::swap(S[k], S[k - 1]);\n                        ++swaps;\n                    }\n                    break;\n                }\n            }\n        }\n\n        // Ensure the right shoe is at position 2i+1\n        if (S[right_pos] < 0 || abs(S[left_pos]) != abs(S[right_pos])) {\n            // Find the correct right shoe (positive value with the same size as S[left_pos])\n            for (int j = right_pos + 1; j < S.size(); ++j) {\n                if (S[j] > 0 && abs(S[j]) == abs(S[left_pos])) {\n                    // Swap S[j] to position right_pos\n                    for (int k = j; k > right_pos; --k) {\n                        std::swap(S[k], S[k - 1]);\n                        ++swaps;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    \n    return swaps;\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 16:47:49",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/A",
    "title": "A. Arranging Shoes",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "A",
    "submission_id": "314979809",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\n#include <unordered_map>\nusing namespace std;\n\nint64_t count_swaps(vector<int> S) {\n    int n = S.size() / 2;\n    vector<pair<int, int>> left_positions(n + 1, {-1, -1});\n    vector<pair<int, int>> right_positions(n + 1, {-1, -1});\n    vector<int> left_indices, right_indices;\n    \n    // Separate left and right shoes and store their positions\n    for (int i = 0; i < S.size(); i++) {\n        int size = abs(S[i]);\n        if (S[i] < 0) { // Left shoe\n            if (left_positions[size].first == -1) {\n                left_positions[size].first = i;\n            } else {\n                left_positions[size].second = i;\n            }\n            left_indices.push_back(i);\n        } else { // Right shoe\n            if (right_positions[size].first == -1) {\n                right_positions[size].first = i;\n            } else {\n                right_positions[size].second = i;\n            }\n            right_indices.push_back(i);\n        }\n    }\n\n    // Calculate swaps to align left shoes\n    int64_t swaps = 0;\n    for (int i = 0; i < n; i++) {\n        int target_pos = 2 * i; // Target position for left shoe\n        int current_pos = left_indices[i];\n        swaps += abs(current_pos - target_pos);\n\n        // Update positions in the array\n        for (int j = i + 1; j < n; j++) {\n            if (left_indices[j] > current_pos) {\n                left_indices[j]--;\n            }\n        }\n    }\n\n    // Calculate swaps to align right shoes\n    for (int i = 0; i < n; i++) {\n        int target_pos = 2 * i + 1; // Target position for right shoe\n        int current_pos = right_indices[i];\n        swaps += abs(current_pos - target_pos);\n\n        // Update positions in the array\n        for (int j = i + 1; j < n; j++) {\n            if (right_indices[j] > current_pos) {\n                right_indices[j]--;\n            }\n        }\n    }\n\n    return swaps;\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 16:48:37",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/A",
    "title": "A. Rail",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "A",
    "submission_id": "314979912",
    "code_index": 0,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid findLocation(int n, int first, int location[], int stype[]) {\n    // Set the block number and type for station 0\n    location[0] = first;\n    stype[0] = 1; // Station 0 is always type C\n\n    // Determine the block number and type for each station\n    for (int i = 1; i < n; ++i) {\n        // Get the distance from station 0 to station i\n        int dist = getDistance(0, i);\n\n        // Calculate the block number for station i\n        location[i] = first + dist;\n\n        // Determine the block type for station i\n        if (getDistance(i, 0) == dist) {\n            stype[i] = 1; // Type C\n        } else {\n            stype[i] = 2; // Type D\n        }\n    }\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 16:49:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/A",
    "title": "A. Rail",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "A",
    "submission_id": "314979989",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to find the location and type of each station\nvoid findLocation(int n, int first, int location[], int stype[]) {\n    vector<pair<int, int>> distances; // Pair of (distance, station index)\n\n    // Query distances from station 0 to all other stations\n    for (int i = 0; i < n; i++) {\n        int dist = getDistance(0, i);\n        distances.push_back({dist, i});\n    }\n\n    // Sort stations by their distance from station 0\n    sort(distances.begin(), distances.end());\n\n    // Assign locations and types\n    for (int i = 0; i < n; i++) {\n        int station = distances[i].second;\n        location[station] = first + distances[i].first * (i % 2 == 0 ? 1 : -1); // Calculate block number\n        stype[station] = (i % 2 == 0 ? 1 : 2); // ALternate types\n    }\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 16:50:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/A",
    "title": "A. Rail",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "A",
    "submission_id": "314980063",
    "code_index": 2,
    "code": "#include <vector>\n#include <algorithm>\n\n// Function to find the location and type of each station\nvoid findLocation(int n, int first, int location[], int stype[]) {\n    // Initialize the location and type for station 0\n    location[0] = first;\n    stype[0] = 1; // Station 0 is always in a type C block (1)\n\n    // Vector to store distances from station 0 to all other stations\n    std::vector<int> distances(n);\n\n    // Query distances from station 0 to all other stations\n    for (int i = 0; i < n; ++i) {\n        distances[i] = getDistance(0, i);\n    }\n\n    // Sort stations based on their distance from station 0\n    // This helps in determining the relative positions\n    std::vector<int> sortedStations(n);\n    for (int i = 0; i < n; ++i) {\n        sortedStations[i] = i;\n    }\n    std::sort(sortedStations.begin(), sortedStations.end(), [&](int a, int b) {\n        return distances[a] < distances[b];\n    });\n\n    // Assign block locations and types based on distances\n    for (int i = 1; i < n; ++i) {\n        int station = sortedStations[i];\n        location[station] = first + distances[station];\n        stype[station] = (distances[station] % 2 == 0) ? 1 : 2; // Alternate between type C and type D\n    }\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 16:50:42",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/A",
    "title": "A. Rail",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "A",
    "submission_id": "314980143",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function prototype provided by the problem\nint getDistance(int i, int j);\n\nvoid findLocation(int n, int first, int location[], int stype[]) {\n    // Station 0 is already known\n    location[0] = first;\n    stype[0] = 1; // Type C\n\n    // Query distances from station 0 to all other stations\n    for (int i = 1; i < n; ++i) {\n        int dist = getDistance(0, i);\n\n        // Determine the block location:\n        // Since station 0 is at 'first', station i must be at (first ± dist/2).\n        location[i] = first + dist / 2;\n\n        // Determine the type of the station:\n        // If the distance is even, the station type alternates.\n        // Station 0 is type C. If distance is even, station i is type D (2).\n        // If distance is odd, station i is type C (1).\n        stype[i] = (dist % 2 == 0) ? 2 : 1;\n    }\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 16:51:25",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/A",
    "title": "A. Rail",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "A",
    "submission_id": "314980210",
    "code_index": 4,
    "code": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Your code will be placed here\nvoid findLocation(int n, int first, int location[], int stype[]) {\n    // Query distances from station 0 to all other stations\n    vector<int> distances(n);\n    for (int i = 0; i < n; ++i) {\n        distances[i] = getDistance(0, i); // Distance from station 0 to station i\n    }\n\n    // Determine block numbers and types for all stations\n    for (int i = 0; i < n; ++i) {\n        location[i] = first + distances[i]; // Block number is determined by distance\n        stype[i] = (distances[i] % 2 == 0) ? 1 : 2; // Type alternates based on parity of distance\n    }\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 16:52:12",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/B",
    "title": "B. Art class",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "B",
    "submission_id": "314980294",
    "code_index": 0,
    "code": "#include \"artclass.h\"\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nint style(int H, int W, int R[500][500], int G[500][500], int B[500][500]) {\n    // Compute average values for R, G, B\n    double avgR = 0, avgG = 0, avgB = 0;\n    double varR = 0, varG = 0, varB = 0;\n    int totalPixels = H * W;\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            avgR += R[i][j];\n            avgG += G[i][j];\n            avgB += B[i][j];\n        }\n    }\n    avgR /= totalPixels;\n    avgG /= totalPixels;\n    avgB /= totalPixels;\n\n    // Compute variance for R, G, B\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            varR += (R[i][j] - avgR) * (R[i][j] - avgR);\n            varG += (G[i][j] - avgG) * (G[i][j] - avgG);\n            varB += (B[i][j] - avgB) * (B[i][j] - avgB);\n        }\n    }\n    varR /= totalPixels;\n    varG /= totalPixels;\n    varB /= totalPixels;\n\n    // Analyze painting style based on features\n    // Style 1: Neoplastic modern art - high variance in colors and balanced averages\n    if (varR > 8000 && varG > 8000 && varB > 8000 && std::abs(avgR - avgG) < 30 && std::abs(avgG - avgB) < 30) {\n        return 1;\n    }\n\n    // Style 2: Impressionist landscapes - high green average and low variance\n    if (avgG > avgR && avgG > avgB && varR < 5000 && varG < 5000 && varB < 5000) {\n        return 2;\n    }\n\n    // Style 3: Expressionist action paintings - high red average and high variance\n    if (avgR > avgG && avgR > avgB && varR > 8000 && varG > 8000 && varB > 8000) {\n        return 3;\n    }\n\n    // Style 4: Colour field paintings - low variance and average values close to each other\n    if (varR < 3000 && varG < 3000 && varB < 3000 && std::abs(avgR - avgG) < 20 && std::abs(avgG - avgB) < 20) {\n        return 4;\n    }\n\n    // Default case (fallback, should not happen ideally)\n    return 1;\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 16:52:51",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/B",
    "title": "B. Art class",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "B",
    "submission_id": "314980365",
    "code_index": 1,
    "code": "#include \"artclass.h\"\n#include <vector>\n#include <numeric>\n#include <cmath>\n\nint style(int H, int W, int R[500][500], int G[500][500], int B[500][500]) {\n    // Your code will be placed here\n    long long totalR = 0, totalG = 0, totalB = 0;\n    long long totalPixels = H * W;\n\n    // Calculate the average R, G, B values for the entire image\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            totalR += R[i][j];\n            totalG += G[i][j];\n            totalB += B[i][j];\n        }\n    }\n\n    double avgR = static_cast<double>(totalR) / totalPixels;\n    double avgG = static_cast<double>(totalG) / totalPixels;\n    double avgB = static_cast<double>(totalB) / totalPixels;\n\n    // Analyze the style based on the average RGB values\n    // These thresholds are based on hypothetical observations of the styles\n    if (avgR > avgG && avgR > avgB) {\n        if (avgB < 100 && avgG < 100) {\n            return 1; // Likely neoplastic modern art\n        } else {\n            return 3; // Likely expressionist action paintings\n        }\n    } else if (avgG > avgR && avgG > avgB) {\n        return 2; // Likely impressionist landscapes\n    } else if (avgB > avgR && avgB > avgG) {\n        return 4; // Likely color field paintings\n    }\n\n    // Fallback (if no clear style is detected)\n    return 1;\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 16:53:43",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/B",
    "title": "B. Art class",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "B",
    "submission_id": "314980460",
    "code_index": 2,
    "code": "#include \"artclass.h\"\n#include <vector>\n#include <cmath>\n\nint style(int H, int W, int R[500][500], int G[500][500], int B[500][500]) {\n    // Initialize variables for color statistics\n    double red_mean = 0.0, green_mean = 0.0, blue_mean = 0.0;\n    double red_var = 0.0, green_var = 0.0, blue_var = 0.0;\n    int total_pixels = H * W;\n\n    // Compute the mean of each color channel\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            red_mean += R[i][j];\n            green_mean += G[i][j];\n            blue_mean += B[i][j];\n        }\n    }\n    red_mean /= total_pixels;\n    green_mean /= total_pixels;\n    blue_mean /= total_pixels;\n\n    // Compute the variance of each color channel\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            red_var += (R[i][j] - red_mean) * (R[i][j] - red_mean);\n            green_var += (G[i][j] - green_mean) * (G[i][j] - green_mean);\n            blue_var += (B[i][j] - blue_mean) * (B[i][j] - blue_mean);\n        }\n    }\n    red_var /= total_pixels;\n    green_var /= total_pixels;\n    blue_var /= total_pixels;\n\n    // Compute the standard deviation\n    double red_std = std::sqrt(red_var);\n    double green_std = std::sqrt(green_var);\n    double blue_std = std::sqrt(blue_var);\n\n    // Determine the style based on heuristics\n    // Style 1: High red variance and low overall brightness (neoplastic modern art)\n    if (red_std > 50 && red_mean < 100 && green_mean < 100 && blue_mean < 100) {\n        return 1;\n    }\n\n    // Style 2: High green mean and moderate variance (impressionist landscapes)\n    if (green_mean > 150 && green_std < 50) {\n        return 2;\n    }\n\n    // Style 3: High variance across all channels (expressionist action paintings)\n    if (red_std > 70 && green_std > 70 && blue_std > 70) {\n        return 3;\n    }\n\n    // Style 4: Low variance and high brightness (color field paintings)\n    if (red_std < 30 && green_std < 30 && blue_std < 30 && red_mean > 200 && green_mean > 200 && blue_mean > 200) {\n        return 4;\n    }\n\n    // Default case (fallback, should not happen for valid inputs)\n    return 1;\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 16:54:25",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/B",
    "title": "B. Art class",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "B",
    "submission_id": "314980532",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include \"artclass.h\"\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint style(int H, int W, int R[500][500], int G[500][500], int B[500][500]) {\n    // Calculate average RGB values\n    long long totalR = 0, totalG = 0, totalB = 0;\n    long long totalPixels = H * W;\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            totalR += R[i][j];\n            totalG += G[i][j];\n            totalB += B[i][j];\n        }\n    }\n\n    double avgR = (double)totalR / totalPixels;\n    double avgG = (double)totalG / totalPixels;\n    double avgB = (double)totalB / totalPixels;\n\n    // Calculate variance of RGB values\n    double varianceR = 0, varianceG = 0, varianceB = 0;\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            varianceR += pow(R[i][j] - avgR, 2);\n            varianceG += pow(G[i][j] - avgG, 2);\n            varianceB += pow(B[i][j] - avgB, 2);\n        }\n    }\n\n    varianceR /= totalPixels;\n    varianceG /= totalPixels;\n    varianceB /= totalPixels;\n\n    // Use heuristics to classify the style\n    if (varianceR + varianceG + varianceB < 1000) {\n        return 4; // Likely a color field painting\n    } else if (avgG > avgR && avgG > avgB) {\n        return 2; // Likely an impressionist landscape\n    } else if (varianceR > 5000 || varianceG > 5000 || varianceB > 5000) {\n        return 3; // Likely an expressionist action painting\n    } else {\n        return 1; // Likely a neoplastic modern art\n    }\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 16:55:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/B",
    "title": "B. Art class",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "B",
    "submission_id": "314980598",
    "code_index": 4,
    "code": "#include \"artclass.h\"\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to compute the mean of a 2D array\ndouble computeMean(int H, int W, int arr[500][500]) {\n    long long sum = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            sum += arr[i][j];\n        }\n    }\n    return static_cast<double>(sum) / (H * W);\n}\n\n// Helper function to compute the standard deviation of a 2D array\ndouble computeStdDev(int H, int W, int arr[500][500], double mean) {\n    long long sumSquaredDiffs = 0;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            double diff = arr[i][j] - mean;\n            sumSquaredDiffs += diff * diff;\n        }\n    }\n    return sqrt(static_cast<double>(sumSquaredDiffs) / (H * W));\n}\n\nint style(int H, int W, int R[500][500], int G[500][500], int B[500][500]) {\n    // Compute means for R, G, B\n    double meanR = computeMean(H, W, R);\n    double meanG = computeMean(H, W, G);\n    double meanB = computeMean(H, W, B);\n\n    // Compute standard deviations for R, G, B\n    double stdDevR = computeStdDev(H, W, R, meanR);\n    double stdDevG = computeStdDev(H, W, G, meanG);\n    double stdDevB = computeStdDev(H, W, B, meanB);\n\n    // Compute overall brightness (average of all channels)\n    double overallBrightness = (meanR + meanG + meanB) / 3.0;\n\n    // Rule-based classification (example rules)\n    if (stdDevR > 50 && stdDevG > 50 && stdDevB > 50) {\n        // High variance in all channels -> Style 3 (Expressionist action paintings)\n        return 3;\n    } else if (overallBrightness > 200) {\n        // Very bright image -> Style 4 (Colour field paintings)\n        return 4;\n    } else if (meanG > meanR && meanG > meanB) {\n        // Dominant green channel -> Style 2 (Impressionist landscapes)\n        return 2;\n    } else {\n        // Default to Style 1 (Neoplastic modern art)\n        return 1;\n    }\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 16:55:52",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/F",
    "title": "F. Ancient Books",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "F",
    "submission_id": "314980671",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\n#include <cstdint>\nusing namespace std;\n\nint64_t minimum_walk(vector<int> p, int s) {\n    int n = p.size();\n    vector<bool> visited(n, false);\n    int64_t total_distance = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            // Start a new cycle\n            int cycle_start = i;\n            int cycle_length = 0;\n            int current_position = i;\n            int64_t cycle_distance = 0;\n\n            // Traverse the cycle\n            while (!visited[current_position]) {\n                visited[current_position] = true;\n                int next_position = p[current_position];\n                cycle_distance += abs(next_position - current_position);\n                current_position = next_position;\n                ++cycle_length;\n            }\n\n            // If the cycle contains more than 1 element, we need to account for walking\n            if (cycle_length > 1) {\n                // Add the cost of resolving the cycle\n                total_distance += cycle_distance;\n\n                // Add the cost of walking from s to the cycle and back\n                total_distance += min(abs(cycle_start - s), abs(current_position - s));\n            }\n        }\n    }\n\n    return total_distance;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 16:56:34",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/F",
    "title": "F. Ancient Books",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "F",
    "submission_id": "314980763",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nint64_t minimum_walk(std::vector<int> p, int s) {\n    int n = p.size();\n    std::vector<bool> visited(n, false);\n    int64_t total_distance = 0;\n\n    // Traverse all tables and process cycles\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            int current = i;\n            int cycle_distance = 0;\n            int cycle_start = current;\n            int cycle_length = 0;\n\n            // Follow the cycle\n            do {\n                visited[current] = true;\n                int next = p[current];\n                cycle_distance += std::abs(next - current);\n                current = next;\n                ++cycle_length;\n            } while (current != cycle_start);\n\n            // Add the distance to close the cycle (return to start of cycle)\n            total_distance += cycle_distance;\n        }\n    }\n\n    // Add the distance to return to the starting table\n    total_distance += std::abs(s - s);\n    return total_distance;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 16:57:13",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/F",
    "title": "F. Ancient Books",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "F",
    "submission_id": "314980816",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\n#include <cstdint>\n#include <algorithm>\n\nint64_t minimum_walk(std::vector<int> p, int s) {\n    int n = p.size();\n    std::vector<bool> visited(n, false);\n    int64_t total_distance = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i] && p[i] != i) {\n            // Start a new cycle\n            int cycle_start = i;\n            int current = i;\n            int cycle_length = 0;\n            int cycle_min_distance = INT32_MAX;\n            int cycle_max_distance = INT32_MIN;\n\n            // Traverse the cycle\n            do {\n                visited[current] = true;\n                cycle_min_distance = std::min(cycle_min_distance, current);\n                cycle_max_distance = std::max(cycle_max_distance, current);\n                ++cycle_length;\n                current = p[current];\n            } while (current != cycle_start);\n\n            // Calculate distance for this cycle\n            total_distance += (cycle_max_distance - cycle_min_distance) * 2;\n        }\n    }\n\n    // Calculate the additional distance to return to the starting table\n    total_distance += std::abs(s - 0);\n\n    return total_distance;\n}"
  },
  {
    "date": "IOI 2017 day 2",
    "timestamp": "2025-04-11 16:57:54",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103775/problem/F",
    "title": "F. Ancient Books",
    "group_id": "32KGsXgiKA",
    "contest_id": "103775",
    "problem_index": "F",
    "submission_id": "314980887",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cstdlib>\n#include <cstdint>\nusing namespace std;\n\nint64_t minimum_walk(vector<int> p, int s) {\n    int n = p.size();\n    vector<bool> visited(n, false);\n    int64_t total_distance = 0;\n    int current_pos = s;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            // Start a new cycle\n            vector<int> cycle;\n            int x = i;\n            while (!visited[x]) {\n                visited[x] = true;\n                cycle.push_back(x);\n                x = p[x];\n            }\n\n            // If the cycle has length 1, skip it (no movement needed)\n            if (cycle.size() == 1) continue;\n\n            // Calculate the walking distance for this cycle\n            int64_t cycle_distance = 0;\n\n            // Start at the current position and walk to the first position in the cycle\n            cycle_distance += abs(current_pos - cycle[0]);\n            current_pos = cycle[0];\n\n            // Walk through the cycle\n            for (size_t j = 1; j < cycle.size(); ++j) {\n                cycle_distance += abs(cycle[j] - current_pos);\n                current_pos = cycle[j];\n            }\n\n            // Return to the starting point of the cycle\n            cycle_distance += abs(cycle[0] - current_pos);\n            current_pos = cycle[0];\n\n            total_distance += cycle_distance;\n        }\n    }\n\n    // Finally, return to the starting position s\n    total_distance += abs(current_pos - s);\n\n    return total_distance;\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 16:58:45",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/B",
    "title": "B. Wall",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "B",
    "submission_id": "314980973",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nvoid buildWall(int n, int k, int op[], int left[], int right[], int height[], int finalHeight[]) {\n    // Initialize the finalHeight array with zeros\n    for (int i = 0; i < n; i++) {\n        finalHeight[i] = 0;\n    }\n\n    // Process each phase\n    for (int phase = 0; phase < k; phase++) {\n        int operation = op[phase];\n        int l = left[phase];\n        int r = right[phase];\n        int h = height[phase];\n\n        // Apply the operation to the specified range\n        if (operation == 1) { // Adding phase\n            for (int i = l; i <= r; i++) {\n                if (finalHeight[i] < h) {\n                    finalHeight[i] = h;\n                }\n            }\n        } else if (operation == 2) { // Removing phase\n            for (int i = l; i <= r; i++) {\n                if (finalHeight[i] > h) {\n                    finalHeight[i] = h;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 16:59:27",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/B",
    "title": "B. Wall",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "B",
    "submission_id": "314981030",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nvoid buildWall(int n, int k, int op[], int left[], int right[], int height[], int finalHeight[]) {\n    // Initialize the finalHeight array with 0 (all columns start empty).\n    vector<int> columns(n, 0);\n\n    // Process each phase\n    for (int phase = 0; phase < k; ++phase) {\n        int operation = op[phase];\n        int l = left[phase];\n        int r = right[phase];\n        int h = height[phase];\n\n        // Apply the operation to the specified range\n        for (int i = l; i <= r; ++i) {\n            if (operation == 1) {  // Adding phase\n                if (columns[i] < h) {\n                    columns[i] = h;\n                }\n            } else if (operation == 2) {  // Removing phase\n                if (columns[i] > h) {\n                    columns[i] = h;\n                }\n            }\n        }\n    }\n\n    // Copy the final column heights into the output array\n    for (int i = 0; i < n; ++i) {\n        finalHeight[i] = columns[i];\n    }\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 17:00:09",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/B",
    "title": "B. Wall",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "B",
    "submission_id": "314981115",
    "code_index": 2,
    "code": "#include <vector>\nusing namespace std;\n\nvoid buildWall(int n, int k, int op[], int left[], int right[], int height[], int finalHeight[]) {\n    // Initialize the wall with zero height\n    for (int i = 0; i < n; ++i) {\n        finalHeight[i] = 0;\n    }\n\n    // Process each phase\n    for (int i = 0; i < k; ++i) {\n        int operation = op[i];\n        int l = left[i];\n        int r = right[i];\n        int h = height[i];\n\n        if (operation == 1) { // Adding phase\n            for (int j = l; j <= r; ++j) {\n                if (finalHeight[j] < h) {\n                    finalHeight[j] = h;\n                }\n            }\n        } else if (operation == 2) { // Removing phase\n            for (int j = l; j <= r; ++j) {\n                if (finalHeight[j] > h) {\n                    finalHeight[j] = h;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 17:00:48",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/B",
    "title": "B. Wall",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "B",
    "submission_id": "314981187",
    "code_index": 3,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid buildWall(int n, int k, int op[], int left[], int right[], int height[], int finalHeight[]) {\n    // Initialize the finalHeight array with zeros\n    vector<int> wall(n, 0);\n\n    // Process each phase\n    for (int i = 0; i < k; ++i) {\n        int operation = op[i];\n        int l = left[i];\n        int r = right[i];\n        int h = height[i];\n\n        // Update the wall based on operation type\n        if (operation == 1) { // Add operation\n            for (int j = l; j <= r; ++j) {\n                if (wall[j] < h) {\n                    wall[j] = h;\n                }\n            }\n        } else if (operation == 2) { // Remove operation\n            for (int j = l; j <= r; ++j) {\n                if (wall[j] > h) {\n                    wall[j] = h;\n                }\n            }\n        }\n    }\n\n    // Copy the final wall heights to the output array\n    for (int i = 0; i < n; ++i) {\n        finalHeight[i] = wall[i];\n    }\n}"
  },
  {
    "date": "IOI 2014 day 1",
    "timestamp": "2025-04-11 17:01:26",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103767/problem/B",
    "title": "B. Wall",
    "group_id": "32KGsXgiKA",
    "contest_id": "103767",
    "problem_index": "B",
    "submission_id": "314981265",
    "code_index": 4,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid buildWall(int n, int k, int op[], int left[], int right[], int height[], int finalHeight[]) {\n    // Initialize the wall with all columns having zero height\n    vector<int> wall(n, 0);\n\n    // Process each phase\n    for (int i = 0; i < k; ++i) {\n        int type = op[i];\n        int l = left[i];\n        int r = right[i];\n        int h = height[i];\n\n        // Update the wall based on the operation type\n        for (int j = l; j <= r; ++j) {\n            if (type == 1) { // Adding phase\n                if (wall[j] < h) {\n                    wall[j] = h;\n                }\n            } else if (type == 2) { // Removing phase\n                if (wall[j] > h) {\n                    wall[j] = h;\n                }\n            }\n        }\n    }\n\n    // Copy the final heights to the output array\n    for (int i = 0; i < n; ++i) {\n        finalHeight[i] = wall[i];\n    }\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 17:02:25",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/D",
    "title": "D. Languages",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "D",
    "submission_id": "314981369",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\n// Global data structures to track symbols observed for each language\nstd::unordered_map<int, std::unordered_set<int>> language_symbols;\n\n// Function to process an excerpt and make a language guess\nvoid excerpt(std::vector<int> E) {\n    // Variables to track the best guess and its similarity score\n    int best_language = 0;\n    int max_similarity = -1;\n\n    // Iterate over all observed languages and calculate similarity\n    for (const auto& [language, symbols] : language_symbols) {\n        int similarity = 0;\n        for (int symbol : E) {\n            if (symbols.find(symbol) != symbols.end()) {\n                ++similarity;\n            }\n        }\n        if (similarity > max_similarity) {\n            max_similarity = similarity;\n            best_language = language;\n        }\n    }\n\n    // Make a guess using the language() function\n    int correct_language = language(best_language);\n\n    // Update the language_symbols map with the correct language\n    if (language_symbols.find(correct_language) == language_symbols.end()) {\n        language_symbols[correct_language] = std::unordered_set<int>();\n    }\n    language_symbols[correct_language].insert(E.begin(), E.end());\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 17:03:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/D",
    "title": "D. Languages",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "D",
    "submission_id": "314981432",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <numeric>\n\n// Global data structure to store symbol occurrences for each language\nstd::vector<std::unordered_set<int>> language_symbols(56);\n\n// Function to compute similarity between an excerpt and a language\nint compute_similarity(const std::unordered_set<int>& excerpt_symbols, const std::unordered_set<int>& language_set) {\n    int similarity = 0;\n    for (int symbol : excerpt_symbols) {\n        if (language_set.find(symbol) != language_set.end()) {\n            ++similarity;\n        }\n    }\n    return similarity;\n}\n\n// Required function to process an excerpt\nvoid excerpt(std::vector<int> E) {\n    // Extract distinct symbols from the excerpt\n    std::unordered_set<int> excerpt_symbols(E.begin(), E.end());\n\n    // Variable to store the best guess\n    int best_language = 0;\n    int max_similarity = -1;\n\n    // Compare the excerpt with all known languages\n    for (int lang = 0; lang < 56; ++lang) {\n        int similarity = compute_similarity(excerpt_symbols, language_symbols[lang]);\n        if (similarity > max_similarity) {\n            max_similarity = similarity;\n            best_language = lang;\n        }\n    }\n\n    // Make a guess for the language\n    int correct_language = language(best_language);\n\n    // Update the language symbol set with the current excerpt's symbols\n    for (int symbol : excerpt_symbols) {\n        language_symbols[correct_language].insert(symbol);\n    }\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 17:03:55",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/D",
    "title": "D. Languages",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "D",
    "submission_id": "314981522",
    "code_index": 2,
    "code": "#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\n// A global mapping to store observed symbols for each language\nstd::vector<std::unordered_set<int>> language_symbols(56);\n\n// Function to guess the language of the given excerpt\nvoid excerpt(std::vector<int> E) {\n    // Compute similarity scores for all languages\n    std::vector<int> similarity(56, 0);\n    for (int i = 0; i < 56; ++i) {\n        for (int symbol : E) {\n            if (language_symbols[i].count(symbol)) {\n                ++similarity[i];\n            }\n        }\n    }\n\n    // Find the language with the highest similarity score\n    int best_language = std::distance(similarity.begin(), std::max_element(similarity.begin(), similarity.end()));\n\n    // Make the guess\n    int correct_language = language(best_language);\n\n    // Update the mapping with the correct language\n    for (int symbol : E) {\n        language_symbols[correct_language].insert(symbol);\n    }\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 17:04:34",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/D",
    "title": "D. Languages",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "D",
    "submission_id": "314981595",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n// A mapping from language ID to the set of symbols seen in excerpts of that language\nunordered_map<int, unordered_set<int>> languageSymbolMap;\n\nvoid excerpt(vector<int> E) {\n    // This will store the best language guess and its similarity score\n    int bestLanguage = 0;\n    int bestScore = -1;\n\n    // Iterate over all languages we've seen so far\n    for (const auto& [language, symbols] : languageSymbolMap) {\n        int similarityScore = 0;\n\n        // Calculate similarity score for this language\n        for (int symbol : E) {\n            if (symbols.count(symbol)) {\n                similarityScore++;\n            }\n        }\n\n        // Update the best language guess if this one is better\n        if (similarityScore > bestScore) {\n            bestScore = similarityScore;\n            bestLanguage = language;\n        }\n    }\n\n    // Make a guess using the best language (default to 0 if no languages seen yet)\n    language(bestLanguage);\n\n    // Get the correct language from the grader\n    int correctLanguage = language(bestLanguage);\n\n    // If the guess was incorrect, update the correct language's symbol set\n    if (languageSymbolMap.find(correctLanguage) == languageSymbolMap.end()) {\n        // If this is the first time we've seen this language, create a new set\n        languageSymbolMap[correctLanguage] = unordered_set<int>();\n    }\n\n    // Add the symbols from the current excerpt to the correct language's symbol set\n    for (int symbol : E) {\n        languageSymbolMap[correctLanguage].insert(symbol);\n    }\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 17:05:29",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/D",
    "title": "D. Languages",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "D",
    "submission_id": "314981696",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\n// Data structure to store symbols for each language\nvector<unordered_set<int>> languageSymbols(56);\n\n// Function to process each excerpt\nvoid excerpt(vector<int> E) {\n    // Initialize similarity scores for each language\n    vector<int> similarity(56, 0);\n\n    // Calculate similarity for each language\n    for (int lang = 0; lang < 56; ++lang) {\n        for (int symbol : E) {\n            if (languageSymbols[lang].count(symbol)) {\n                similarity[lang]++;\n            }\n        }\n    }\n\n    // Find the language with the highest similarity score\n    int bestLanguage = 0;\n    int maxSimilarity = similarity[0];\n    for (int lang = 1; lang < 56; ++lang) {\n        if (similarity[lang] > maxSimilarity) {\n            maxSimilarity = similarity[lang];\n            bestLanguage = lang;\n        }\n    }\n\n    // Make a guess for the language\n    int correctLanguage = language(bestLanguage);\n\n    // Update the symbol set for the correct language\n    for (int symbol : E) {\n        languageSymbols[correctLanguage].insert(symbol);\n    }\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 17:06:22",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/B",
    "title": "B. Hotter Colder",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "B",
    "submission_id": "314981796",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n\nint Guess(int G); // Provided by the grader\n\nvoid HC(int N) {\n    int low = 1, high = N;\n    int prev_guess = -1;\n    int prev_response = 0;\n\n    while (low < high) {\n        int mid = (low + high) / 2;\n        int response = Guess(mid);\n\n        if (response == 0) {\n            // If response is \"same\", we've found the number\n            return;\n        } else if (response == 1) {\n            // \"Hotter\" means the number is closer to this guess than the previous one\n            if (prev_guess < mid) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        } else if (response == -1) {\n            // \"Colder\" means the number is farther from this guess than the previous one\n            if (prev_guess < mid) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        prev_guess = mid;\n        prev_response = response;\n    }\n\n    // At this point, low == high, which means we've narrowed down to a single number\n    Guess(low);\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 17:07:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/B",
    "title": "B. Hotter Colder",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "B",
    "submission_id": "314981862",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function declaration\nint Guess(int G);\n\nvoid HC(int N) {\n    int low = 1, high = N;\n    int prevGuess = (low + high) / 2; // Initial guess in the middle\n    int prevResponse = Guess(prevGuess); // First call always returns 0 (same)\n    \n    while (low < high) { // Continue until the range collapses\n        int mid = (low + high) / 2; // Make a new guess in the middle of the range\n        int response = Guess(mid); // Get the response to the guess\n        \n        if (response == 0) {\n            // If the response is \"same\", we have found Jill's number\n            return;\n        } else if (response == 1) {\n            // \"Hotter\": Move closer to the current guess\n            if (mid > prevGuess) {\n                low = mid + 1; // Narrow the search to the upper half\n            } else {\n                high = mid - 1; // Narrow the search to the lower half\n            }\n        } else if (response == -1) {\n            // \"Colder\": Move farther from the current guess\n            if (mid > prevGuess) {\n                high = mid - 1; // Narrow the search to the lower half\n            } else {\n                low = mid + 1; // Narrow the search to the upper half\n            }\n        }\n        // Update the previous guess and response\n        prevGuess = mid;\n        prevResponse = response;\n    }\n    \n    // Once the loop ends, `low` and `high` should be the same, pointing to Jill's number\n    Guess(low); // Final confirmation (this call will always return 0)\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 17:07:47",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/B",
    "title": "B. Hotter Colder",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "B",
    "submission_id": "314981928",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function to implement the Hotter-Colder game\nint HC(int N) {\n    // Initialize search range\n    int low = 1, high = N;\n\n    // Make the first guess at the midpoint\n    int mid = (low + high) / 2;\n    int last_response = Guess(mid); // First call to Guess; response will be 0\n\n    // Binary search with feedback\n    while (low < high) {\n        int next_mid = (low + high) / 2;\n\n        // Make a guess and get the response\n        int response = Guess(next_mid);\n\n        if (response == 0) {\n            // If response is \"same\", we've found the number\n            return next_mid;\n        } else if (response == 1) {\n            // Hotter: the number is closer to the current guess\n            if (next_mid > mid) {\n                low = mid + 1; // Move the lower bound up\n            } else {\n                high = mid - 1; // Move the upper bound down\n            }\n        } else if (response == -1) {\n            // Colder: the number is further from the current guess\n            if (next_mid > mid) {\n                high = mid - 1; // Move the upper bound down\n            } else {\n                low = mid + 1; // Move the lower bound up\n            }\n        }\n\n        // Update the current midpoint\n        mid = next_mid;\n        last_response = response;\n    }\n\n    // When low == high, we've narrowed it down to the exact number\n    return low;\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 17:08:31",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/B",
    "title": "B. Hotter Colder",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "B",
    "submission_id": "314982007",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\n\n// Function prototype for the grader-provided Guess function\nint Guess(int G);\n\nvoid HC(int N) {\n    int low = 1, high = N; // Range of possible numbers\n    int prev_guess = -1;   // Previous guess (initialized to an invalid value)\n    int prev_response = 0; // Previous response (0 for the first guess)\n\n    // First guess: pick the middle of the range\n    int current_guess = (low + high) / 2;\n    prev_response = Guess(current_guess);\n\n    // Binary search loop\n    while (true) {\n        if (prev_response == 0) {\n            // If the response is \"same\", we found the number\n            return;\n        }\n\n        // Make a new guess based on the feedback\n        int mid = (low + high) / 2;\n        if (prev_response == 1) {\n            // \"hotter\": The number is closer to the current guess\n            if (prev_guess < current_guess) {\n                low = current_guess + 1; // Move the lower bound up\n            } else {\n                high = current_guess - 1; // Move the upper bound down\n            }\n        } else if (prev_response == -1) {\n            // \"colder\": The number is farther from the current guess\n            if (prev_guess < current_guess) {\n                high = current_guess - 1; // Move the upper bound down\n            } else {\n                low = current_guess + 1; // Move the lower bound up\n            }\n        }\n\n        // Update the previous guess and response\n        prev_guess = current_guess;\n        current_guess = (low + high) / 2;\n        prev_response = Guess(current_guess);\n    }\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 17:09:17",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/B",
    "title": "B. Hotter Colder",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "B",
    "submission_id": "314982084",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function prototype for Guess(G) provided by the grader\nint Guess(int G);\n\nvoid HC(int N) {\n    int low = 1, high = N;\n    int prev_guess = -1; // Previous guess\n    int current_guess = (low + high) / 2; // Start with the midpoint\n    int feedback = Guess(current_guess); // Make the first guess\n    \n    while (feedback != 0) { // Continue until we find the correct number\n        if (prev_guess == -1) {\n            // First iteration: no previous guess, just update bounds based on feedback\n            prev_guess = current_guess;\n            current_guess = (low + high) / 2;\n        } else {\n            // Adjust range and refine the search\n            if (feedback == 1) { // Hotter: move closer to the last guess\n                if (current_guess > prev_guess) {\n                    low = prev_guess + 1; // Narrow the range toward the higher end\n                } else {\n                    high = prev_guess - 1; // Narrow the range toward the lower end\n                }\n            } else if (feedback == -1) { // Colder: move farther from the last guess\n                if (current_guess > prev_guess) {\n                    high = prev_guess - 1; // Narrow the range away from the higher end\n                } else {\n                    low = prev_guess + 1; // Narrow the range away from the lower end\n                }\n            }\n            \n            // Update the guess to the midpoint of the new range\n            prev_guess = current_guess;\n            current_guess = (low + high) / 2;\n        }\n        \n        // Make the next guess and get feedback\n        feedback = Guess(current_guess);\n    }\n    \n    // Return the correct number\n    return current_guess;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 17:10:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/A",
    "title": "A. Combo",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "A",
    "submission_id": "314852789",
    "code_index": 0,
    "code": "#include <string>\n#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nstring guess_sequence(int N) {\n    string characters = \"ABXY\"; // Possible characters\n    string S; // Reconstructed secret sequence\n\n    // Step 1: Determine the first character of S\n    for (char c : characters) {\n        string test = string(1, c); // Test string with one character\n        if (press(test) == 1) { // The first character results in a match length of 1\n            S += c; // Found the first character\n            break;\n        }\n    }\n\n    // Step 2: Build the rest of the string incrementally\n    while (S.size() < N) {\n        for (char c : characters) {\n            string test = S + c; // Append candidate character to the current prefix\n            if (press(test) == S.size() + 1) { // Check if the match length increases\n                S += c; // Append the character to the reconstructed string\n                break;\n            }\n        }\n    }\n\n    // Step 3: Return the reconstructed string\n    return S;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 17:10:54",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/A",
    "title": "A. Combo",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "A",
    "submission_id": "314982173",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <string>\n#include <vector>\nusing namespace std;\n\n// Function signature as required by the problem\nstring guess_sequence(int N) {\n    string S = \"\"; // The secret string we are building\n    string candidates = \"ABXY\"; // Possible characters\n\n    // Step 1: Identify the first character of S\n    for (char c : candidates) {\n        if (press(string(1, c)) == 1) {\n            S += c; // Found the first character\n            break;\n        }\n    }\n\n    // Step 2: Build the rest of the string iteratively\n    for (int i = 1; i < N; ++i) {\n        for (char c : candidates) {\n            string test = S + c;\n            if (press(test) == test.length()) {\n                S += c; // Found the next character\n                break;\n            }\n        }\n    }\n\n    return S;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 17:11:38",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/A",
    "title": "A. Combo",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "A",
    "submission_id": "314982310",
    "code_index": 2,
    "code": "#include <string>\nusing namespace std;\n\n// The function press is provided by the grader.\n// int press(string p);\n\nstring guess_sequence(int N) {\n    string S = \"\";  // The sequence being built\n    string candidates = \"ABXY\";  // Possible characters\n    \n    // Step 1: Find the first character\n    for (char c : candidates) {\n        if (press(string(1, c)) == 1) {\n            S += c;\n            break;\n        }\n    }\n    \n    // Step 2: Build the rest of the sequence\n    while (S.length() < N) {\n        for (char c : candidates) {\n            string test = S + c;\n            if (press(test) == S.length() + 1) {\n                S += c;\n                break;\n            }\n        }\n    }\n    \n    return S;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 17:12:18",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/A",
    "title": "A. Combo",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "A",
    "submission_id": "314982388",
    "code_index": 3,
    "code": "#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Function to guess the secret sequence\nstring guess_sequence(int N) {\n    string result = \"\";  // This will store the final sequence S\n    string buttons = \"ABXY\";  // Possible buttons in the game\n\n    // Determine the first character of the sequence\n    for (char c : buttons) {\n        string query(1, c);\n        if (press(query) == 1) {\n            result += c;\n            break;\n        }\n    }\n\n    // Determine the rest of the sequence\n    while (result.size() < N) {\n        for (char c : buttons) {\n            string query = result + c;  // Append the current character to the known sequence\n            if (press(query) == result.size() + 1) {\n                result += c;  // Add the character to the result\n                break;\n            }\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2018 day 1",
    "timestamp": "2025-04-11 17:13:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103776/problem/A",
    "title": "A. Combo",
    "group_id": "32KGsXgiKA",
    "contest_id": "103776",
    "problem_index": "A",
    "submission_id": "314982466",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <string>\n#include <vector>\nusing namespace std;\n\nstring guess_sequence(int N) {\n    string S = \"\";\n    string buttons = \"ABXY\";\n\n    // Step 1: Determine the first character of S\n    for (char c : buttons) {\n        if (press(string(1, c)) == 1) {\n            S += c;\n            break;\n        }\n    }\n\n    // Step 2: Iteratively determine the rest of S\n    while (S.size() < N) {\n        for (char c : buttons) {\n            string candidate = S + c;\n            if (press(candidate) == S.size() + 1) {\n                S += c;\n                break;\n            }\n        }\n    }\n\n    // Step 3: Return the final string S\n    return S;\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:14:00",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/E",
    "title": "E. Supper",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "E",
    "submission_id": "314982579",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <set>\n\n// Function to write advice bits\nvoid WriteAdvice(unsigned char a);\n\n// ComputeAdvice function\nvoid ComputeAdvice(int *C, int N, int K, int M) {\n    // Use advice to encode the sequence of requests\n    // Use M bits to store the sequence C directly (if possible)\n    for (int i = 0; i < N; i++) {\n        // Convert each color to binary and write it as advice\n        for (int bit = K - 1; bit >= 0; bit--) {\n            unsigned char advice_bit = (C[i] >> bit) & 1;\n            WriteAdvice(advice_bit);\n        }\n    }\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:14:45",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/E",
    "title": "E. Supper",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "E",
    "submission_id": "314982656",
    "code_index": 1,
    "code": "#include <vector>\nusing namespace std;\n\n// Provided function to output advice bits\nvoid WriteAdvice(unsigned char a);\n\n// Function to compute advice\nvoid ComputeAdvice(int *C, int N, int K, int M) {\n    // Encode the entire sequence C into the advice sequence as bits\n    for (int i = 0; i < N; ++i) {\n        int color = C[i];\n        for (int bit = 0; bit < 8; ++bit) {\n            WriteAdvice((color >> bit) & 1); // Write each bit of the color\n        }\n    }\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:15:29",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/E",
    "title": "E. Supper",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "E",
    "submission_id": "314982739",
    "code_index": 2,
    "code": "#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvoid WriteAdvice(unsigned char a);\n\nvoid ComputeAdvice(int *C, int N, int K, int M) {\n    // Precompute the next occurrence of each color for every position in C\n    vector<int> next(N, N); // Default: no next occurrence\n    unordered_map<int, int> last_position;\n    \n    for (int i = N - 1; i >= 0; --i) {\n        if (last_position.count(C[i])) {\n            next[i] = last_position[C[i]];\n        }\n        last_position[C[i]] = i;\n    }\n\n    // Encode the next occurrences into the advice sequence\n    for (int i = 0; i < N; ++i) {\n        // Encode the next occurrence of C[i] in advice (e.g., binary form)\n        int next_occurrence = next[i];\n        for (int b = 0; b < 20 && M > 0; ++b) { // Assume 20 bits max for encoding\n            WriteAdvice((next_occurrence >> b) & 1);\n            --M;\n        }\n    }\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:16:14",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/E",
    "title": "E. Supper",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "E",
    "submission_id": "314982826",
    "code_index": 3,
    "code": "#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n\nvoid WriteAdvice(unsigned char a);\n\nvoid ComputeAdvice(int *C, int N, int K, int M) {\n    // Generate a compressed advice sequence A based on the input sequence C\n    std::vector<int> advice;\n    \n    // Strategy: Store the future positions of each color for optimal replacement\n    std::unordered_map<int, std::queue<int>> future_positions;\n    for (int i = 0; i < N; ++i) {\n        future_positions[C[i]].push(i);\n    }\n\n    // Create advice sequence\n    for (int i = 0; i < N; ++i) {\n        advice.push_back(C[i]);\n        future_positions[C[i]].pop(); // Remove current occurrence from future positions\n    }\n\n    // Compress advice sequence into bits and write advice\n    for (int i = 0; i < N && M > 0; ++i) {\n        unsigned char bit = (advice[i] & 1); // Simplistic encoding\n        WriteAdvice(bit);\n        --M;\n    }\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:17:01",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/E",
    "title": "E. Supper",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "E",
    "submission_id": "314982921",
    "code_index": 4,
    "code": "#include <vector>\n#include <unordered_map>\n#include <queue>\nusing namespace std;\n\nvoid ComputeAdvice(int *C, int N, int K, int M) {\n    // Compute next occurrence of each color in the sequence.\n    vector<int> nextOccurrence(N, -1);\n    unordered_map<int, queue<int>> occurrences;\n    for (int i = N - 1; i >= 0; --i) {\n        if (occurrences[C[i]].empty()) {\n            nextOccurrence[i] = -1; // No future occurrence.\n        } else {\n            nextOccurrence[i] = occurrences[C[i]].front(); // Next occurrence.\n        }\n        occurrences[C[i]].push(i);\n    }\n\n    // Encode advice: we store the next occurrence index for each request.\n    for (int i = 0; i < N; ++i) {\n        unsigned char adviceBit = (nextOccurrence[i] == -1) ? 1 : 0;\n        WriteAdvice(adviceBit);\n        // Note: This naive implementation uses 1 bit per request.\n        // You can optimize this further based on M.\n    }\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 17:17:51",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/D",
    "title": "D. Packing Biscuits",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "D",
    "submission_id": "314983026",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cstdint>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nint64_t count_tastiness(int64_t x, vector<int64_t> a) {\n    unordered_set<int64_t> achievable; // Set to track all achievable tastiness values for one bag\n    achievable.insert(0); // Start with a tastiness of 0\n    \n    for (int i = 0; i < a.size(); ++i) {\n        int64_t tastiness = 1LL << i; // Tastiness value of a single biscuit of type i\n        int64_t max_biscuits = a[i]; // Total biscuits of type i available\n        int64_t max_per_bag = max_biscuits / x; // Max biscuits of type i usable per bag\n        \n        // If no biscuits of this type can be used in any bag, skip\n        if (max_per_bag == 0) continue;\n        \n        // Use binary splitting to efficiently distribute biscuits\n        vector<int64_t> additions; // Temporary storage for new achievable values\n        for (int64_t count = 1; max_per_bag > 0; count *= 2) {\n            int64_t use = min(count, max_per_bag); // Use up to 'use' biscuits in this batch\n            max_per_bag -= use; // Decrease remaining biscuits\n            \n            // Generate new achievable values\n            for (int64_t current : achievable) {\n                additions.push_back(current + use * tastiness);\n            }\n        }\n        \n        // Add new achievable values to the set\n        for (int64_t value : additions) {\n            achievable.insert(value);\n        }\n    }\n    \n    return achievable.size(); // The size of the set is the number of distinct tastiness values\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 17:18:31",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/D",
    "title": "D. Packing Biscuits",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "D",
    "submission_id": "314983112",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <set>\n#include <cmath>\n#include <cstdint>\nusing namespace std;\n\nint64_t count_tastiness(int64_t x, vector<int64_t> a) {\n    int k = a.size();\n    set<int64_t> possible_sums;\n    possible_sums.insert(0); // Initially, we can achieve a sum of 0.\n\n    for (int i = 0; i < k; ++i) {\n        int64_t tastiness = (1LL << i); // Tastiness value of biscuit type i\n        int64_t max_biscuits = a[i];\n        set<int64_t> new_sums;\n\n        for (int64_t current_sum : possible_sums) {\n            int64_t total_to_distribute = max_biscuits;\n            int64_t bags = x;\n\n            // Distribute biscuits of type i among the bags\n            while (bags > 0 && total_to_distribute > 0)  {"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 17:19:13",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/D",
    "title": "D. Packing Biscuits",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "D",
    "submission_id": "314983198",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <set>\n#include <cstdint>\n#include <algorithm>\n\nusing namespace std;\n\nint64_t count_tastiness(int64_t x, vector<int64_t> a) {\n    int k = a.size();\n    set<int64_t> achievable;\n    achievable.insert(0); // Start with the base case: tastiness 0 is achievable with no biscuits.\n\n    for (int i = 0; i < k; ++i) {\n        int64_t tastiness = (1LL << i); // Tastiness of a single biscuit of type i.\n        int64_t max_biscuits = min(a[i], x); // Maximum biscuits of type i we can use per bag.\n\n        // Temporary set to store new achievable values for this type of biscuit.\n        set<int64_t> new_achievable;\n\n        for (int64_t used = 1; used <= max_biscuits; ++used) {\n            int64_t contribution = used * tastiness; // Contribution of `used` biscuits of this type.\n            for (int64_t value : achievable) {\n                new_achievable.insert(value + contribution);\n            }\n        }\n\n        // Merge the new achievable values into the main set.\n        for (int64_t value : new_achievable) {\n            achievable.insert(value);\n        }\n    }\n\n    return achievable.size();\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 17:19:52",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/D",
    "title": "D. Packing Biscuits",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "D",
    "submission_id": "314983286",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <set>\n#include <cstdint>\nusing namespace std;\n\nint64_t count_tastiness(int64_t x, vector<int64_t> a) {\n    int k = a.size();\n    set<int64_t> possible_tastiness;\n    possible_tastiness.insert(0); // Start with a tastiness value of 0\n\n    // Iterate over each type of biscuit\n    for (int i = 0; i < k; ++i) {\n        int64_t tastiness_value = (1LL << i); // 2^i\n        int64_t max_biscuits = a[i];\n        set<int64_t> new_tastiness;\n\n        // For each existing tastiness value, add multiples of the current biscuit's tastiness\n        for (int64_t t : possible_tastiness) {\n            int64_t current_tastiness = t;\n\n            // Distribute biscuits of this type across bags\n            for (int64_t count = 0; count <= max_biscuits && count <= x; ++count) {\n                new_tastiness.insert(current_tastiness);\n                current_tastiness += tastiness_value;\n            }\n        }\n\n        // Update the set of possible tastiness values\n        possible_tastiness = move(new_tastiness);\n    }\n\n    return possible_tastiness.size();\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 17:20:34",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/D",
    "title": "D. Packing Biscuits",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "D",
    "submission_id": "314983368",
    "code_index": 4,
    "code": "#include <vector>\n#include <set>\n#include <cstdint>\nusing namespace std;\n\n// Your code will be placed here\nint64_t count_tastiness(int64_t x, vector<int64_t> a) {\n    int k = a.size();\n    \n    // Step 1: Compute possible tastiness values for 1 bag using DP\n    set<int64_t> possible_tastiness_single;\n    possible_tastiness_single.insert(0); // Start with 0 tastiness\n\n    for (int i = 0; i < k; ++i) {\n        set<int64_t> new_tastiness;\n        int64_t tastiness_value = (1LL << i); // 2^i\n\n        // Add all possible contributions of type i biscuits\n        for (int64_t count = 1; count <= a[i]; ++count) {\n            int64_t contribution = count * tastiness_value;\n            for (auto t : possible_tastiness_single) {\n                new_tastiness.insert(t + contribution);\n            }\n        }\n\n        // Merge new_tastiness into possible_tastiness_single\n        possible_tastiness_single.insert(new_tastiness.begin(), new_tastiness.end());\n    }\n\n    // Step 2: Compute possible tastiness values for x bags\n    set<int64_t> possible_tastiness_multiple;\n    for (auto t : possible_tastiness_single) {\n        possible_tastiness_multiple.insert(t % x);\n    }\n\n    // The size of the set gives the number of distinct tastiness values\n    return possible_tastiness_multiple.size();\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 17:21:24",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/F",
    "title": "F. Stations",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "F",
    "submission_id": "314983470",
    "code_index": 0,
    "code": "// Your code will be placed here\n\n#include <vector>\n#include <queue>\n#include <unordered_map>\nusing namespace std;\n\n// Function to assign labels to stations\nvector<int> label(int n, int k, vector<int> u, vector<int> v) {\n    // Create adjacency list for the graph\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < n - 1; ++i) {\n        adj[u[i]].push_back(v[i]);\n        adj[v[i]].push_back(u[i]);\n    }\n\n    // Use BFS to assign labels\n    vector<int> labels(n, -1); // Initialize labels\n    queue<int> q;\n    q.push(0); // Start BFS from node 0\n    labels[0] = 0; // Assign label 0 to the root\n\n    int current_label = 1; // Start assigning labels from 1\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        for (int neighbor : adj[node]) {\n            if (labels[neighbor] == -1) { // If neighbor is not yet labeled\n                labels[neighbor] = current_label++;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    return labels;\n}\n\n// Function to find the next station to forward a packet\nint find_next_station(int s, int t, vector<int> c) {\n    // The next station is the neighbor closest to the target label\n    int closest_neighbor = c[0];\n    for (int neighbor : c) {\n        if (abs(neighbor - t) < abs(closest_neighbor - t)) {\n            closest_neighbor = neighbor;\n        }\n    }\n    return closest_neighbor;\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 17:22:08",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/F",
    "title": "F. Stations",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "F",
    "submission_id": "314983539",
    "code_index": 1,
    "code": "// Your code will be placed here\n\n#include <vector>\n#include <queue>\n#include <unordered_map>\nusing namespace std;\n\n// Function to assign labels to stations\nvector<int> label(int n, int k, vector<int> u, vector<int> v) {\n    // Assign labels as the indices themselves\n    vector<int> labels(n);\n    for (int i = 0; i < n; i++) {\n        labels[i] = i;\n    }\n    return labels;\n}\n\n// Function to find the next station along the path to the target\nint find_next_station(int s, int t, vector<int> c) {\n    // The next station is the one in the neighbors (c) that is closer to the target\n    // Since `c` is sorted, we just need to return the first valid neighbor\n    if (!c.empty()) {\n        return c[0]; // Return the first neighbor (arbitrarily, for simplicity)\n    }\n    return -1; // If no neighbors exist (should not happen in a valid tree)\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 17:22:46",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/F",
    "title": "F. Stations",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "F",
    "submission_id": "314983631",
    "code_index": 2,
    "code": "#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to perform BFS to assign labels for `label` function\nvoid bfs_labeling(int start, const vector<vector<int>>& adj, vector<int>& labels) {\n    queue<int> q;\n    q.push(start);\n    int current_label = 0;\n    labels[start] = current_label++;\n    \n    while (!q.empty()) {\n        int node = q.front(); q.pop();\n        for (int neighbor : adj[node]) {\n            if (labels[neighbor] == -1) {\n                labels[neighbor] = current_label++;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\n// Procedure `label`: Assigns labels to stations based on the provided graph structure\nvector<int> label(int n, int k, vector<int> u, vector<int> v) {\n    // Build adjacency list for the graph\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < n - 1; ++i) {\n        adj[u[i]].push_back(v[i]);\n        adj[v[i]].push_back(u[i]);\n    }\n\n    // Assign labels using BFS starting from station 0\n    vector<int> labels(n, -1);\n    bfs_labeling(0, adj, labels);\n\n    return labels;\n}\n\n// Procedure `find_next_station`: Determines the next station to forward the packet\nint find_next_station(int s, int t, vector<int> c) {\n    // The packet should be forwarded to the neighbor whose label is \"closer\" to the target label `t`\n    int closest_label = c[0];\n    for (int neighbor_label : c) {\n        if (abs(neighbor_label - t) < abs(closest_label - t)) {\n            closest_label = neighbor_label;\n        }\n    }\n    return closest_label;\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 17:23:27",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/F",
    "title": "F. Stations",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "F",
    "submission_id": "314983730",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to assign labels to stations\nvector<int> label(int n, int k, vector<int> u, vector<int> v) {\n    // Adjacency list to represent the graph\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < n - 1; i++) {\n        adj[u[i]].push_back(v[i]);\n        adj[v[i]].push_back(u[i]);\n    }\n\n    // Array to store labels\n    vector<int> labels(n, -1);\n\n    // DFS to assign labels\n    int current_label = 0;\n    function<void(int, int)> dfs = [&](int node, int parent) {\n        labels[node] = current_label++;\n        for (int neighbor : adj[node]) {\n            if (neighbor != parent) {\n                dfs(neighbor, node);\n            }\n        }\n    };\n\n    // Start DFS from node 0\n    dfs(0, -1);\n\n    return labels;\n}\n\n// Function to determine the next station to forward the packet\nint find_next_station(int s, int t, vector<int> c) {\n    // Find the neighbor closest to the target label\n    int closest_neighbor = c[0];\n    int min_difference = abs(c[0] - t);\n\n    for (int neighbor : c) {\n        int difference = abs(neighbor - t);\n        if (difference < min_difference) {\n            closest_neighbor = neighbor;\n            min_difference = difference;\n        }\n    }\n\n    return closest_neighbor;\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 17:24:08",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/F",
    "title": "F. Stations",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "F",
    "submission_id": "314983798",
    "code_index": 4,
    "code": "#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to build an adjacency list for the graph\nvector<vector<int>> build_adjacency_list(int n, const vector<int>& u, const vector<int>& v) {\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < u.size(); ++i) {\n        adj[u[i]].push_back(v[i]);\n        adj[v[i]].push_back(u[i]);\n    }\n    return adj;\n}\n\n// BFS to assign labels based on distance from a root node\nvoid bfs_assign_labels(int root, const vector<vector<int>>& adj, vector<int>& labels) {\n    queue<int> q;\n    q.push(root);\n    labels[root] = 0; // Root node gets label 0\n    int curr_label = 1;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (int neighbor : adj[node]) {\n            if (labels[neighbor] == -1) { // If not visited\n                labels[neighbor] = curr_label++;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\n// Function to assign labels to stations\nvector<int> label(int n, int k, vector<int> u, vector<int> v) {\n    // Build the adjacency list for the graph\n    vector<vector<int>> adj = build_adjacency_list(n, u, v);\n\n    // Assign labels using BFS\n    vector<int> labels(n, -1);\n    bfs_assign_labels(0, adj, labels);\n\n    return labels;\n}\n\n// Function to find the next station in the path\nint find_next_station(int s, int t, vector<int> c) {\n    // The next station in the path is the one closest to the target (t)\n    // Since `c` is sorted in ascending order, we return the smallest label\n    return *min_element(c.begin(), c.end());\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:25:09",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/F",
    "title": "F. Jousting tournament",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "F",
    "submission_id": "314983914",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint GetBestPosition(int N, int C, int R, int* K, int* S, int* E) {\n    // Convert K array to vector for easier manipulation\n    vector<int> knights(K, K + (N - 1));\n    vector<int> start(S, S + C);\n    vector<int> end(E, E + C);\n\n    int maxWins = -1;\n    int bestPosition = 0;\n\n    // Try placing the late knight at every possible position\n    for (int pos = 0; pos <= N - 1; ++pos) {\n        // Create the initial lineup with the late knight inserted at position `pos`\n        vector<int> lineup = knights;\n        lineup.insert(lineup.begin() + pos, R);\n\n        int wins = 0;  // Count the number of rounds the late knight wins\n        for (int round = 0; round < C; ++round) {\n            int s = start[round];\n            int e = end[round];\n\n            // Find the knight with the highest rank in the range [s, e]\n            int maxRank = -1;\n            int maxIndex = -1;\n            for (int i = s; i <= e; ++i) {\n                if (lineup[i] > maxRank) {\n                    maxRank = lineup[i];\n                    maxIndex = i;\n                }\n            }\n\n            // Check if the late knight wins this round\n            if (lineup[maxIndex] == R) {\n                ++wins;\n            }\n\n            // Remove all knights except the winner from the range [s, e]\n            lineup.erase(lineup.begin() + s, lineup.begin() + e + 1);\n            lineup.insert(lineup.begin() + s, maxRank);\n        }\n\n        // Update the best position if this placement results in more wins\n        if (wins > maxWins) {\n            maxWins = wins;\n            bestPosition = pos;\n        }\n    }\n\n    return bestPosition;\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:25:54",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/F",
    "title": "F. Jousting tournament",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "F",
    "submission_id": "314984011",
    "code_index": 1,
    "code": "#include <vector>\nusing namespace std;\n\n// Helper function to simulate the tournament and calculate rounds won by the late knight\nint simulateTournament(int N, int C, int R, vector<int> line, const vector<int>& S, const vector<int>& E) {\n    int roundsWon = 0;\n\n    for (int i = 0; i < C; ++i) {\n        int start = S[i];\n        int end = E[i];\n\n        // Determine the knight with the highest rank in the range [start, end]\n        int maxRank = -1, maxIndex = -1;\n        for (int j = start; j <= end; ++j) {\n            if (line[j] > maxRank) {\n                maxRank = line[j];\n                maxIndex = j;\n            }\n        }\n\n        // Check if the late knight wins this round\n        if (line[maxIndex] == R) {\n            ++roundsWon;\n        }\n\n        // Remove all knights except the winner, and pack them\n        vector<int> newLine;\n        for (int j = 0; j < line.size(); ++j) {\n            if (j < start || j > end || j == maxIndex) {\n                newLine.push_back(line[j]);\n            }\n        }\n        line = newLine;\n    }\n\n    return roundsWon;\n}\n\n// Main function to get the best position for the late knight\nint GetBestPosition(int N, int C, int R, int *K, int *S, int *E) {\n    vector<int> knights(K, K + N - 1); // Convert K to a vector\n    vector<int> S_vec(S, S + C);      // Convert S to a vector\n    vector<int> E_vec(E, E + C);      // Convert E to a vector\n\n    int bestPosition = 0;\n    int maxRoundsWon = 0;\n\n    // Try inserting the late knight at every position\n    for (int pos = 0; pos < N; ++pos) {\n        vector<int> currentLine = knights;\n        currentLine.insert(currentLine.begin() + pos, R); // Insert late knight at position `pos`\n\n        // Simulate the tournament and calculate rounds won by the late knight\n        int roundsWon = simulateTournament(N, C, R, currentLine, S_vec, E_vec);\n\n        // Update the best position if this placement results in more rounds won\n        if (roundsWon > maxRoundsWon) {\n            maxRoundsWon = roundsWon;\n            bestPosition = pos;\n        }\n    }\n\n    return bestPosition;\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:26:41",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/F",
    "title": "F. Jousting tournament",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "F",
    "submission_id": "314984100",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint GetBestPosition(int N, int C, int R, int *K, int *S, int *E) {\n    int maxWins = -1;\n    int bestPosition = 0;\n\n    // Convert K into a vector for easier manipulation\n    vector<int> knights(K, K + (N - 1));\n\n    // Try placing the late knight at each position\n    for (int pos = 0; pos <= N - 1; ++pos) {\n        // Create a temporary lineup with the late knight inserted at position `pos`\n        vector<int> lineup = knights;\n        lineup.insert(lineup.begin() + pos, R);\n\n        int wins = 0;\n\n        // Simulate the tournament\n        for (int i = 0; i < C; ++i) {\n            int start = S[i];\n            int end = E[i];\n\n            // Find the strongest knight in the current range\n            int strongest = start;\n            for (int j = start + 1; j <= end; ++j) {\n                if (lineup[j] > lineup[strongest]) {\n                    strongest = j;\n                }\n            }\n\n            // Check if the late knight wins this round\n            if (lineup[strongest] == R) {\n                ++wins;\n            }\n\n            // Remove the losers and pack the lineup\n            vector<int> newLineup;\n            for (int j = 0; j < lineup.size(); ++j) {\n                if (j == strongest || j < start || j > end) {\n                    newLineup.push_back(lineup[j]);\n                }\n            }\n            lineup = move(newLineup);\n        }\n\n        // Update the best position if this position results in more wins\n        if (wins > maxWins || (wins == maxWins && pos < bestPosition)) {\n            maxWins = wins;\n            bestPosition = pos;\n        }\n    }\n\n    return bestPosition;\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:27:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/F",
    "title": "F. Jousting tournament",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "F",
    "submission_id": "314984176",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\nint GetBestPosition(int N, int C, int R, int *K, int *S, int *E) {\n    // Convert input arrays to vectors for easier manipulation\n    vector<int> knights(K, K + N - 1);\n    vector<int> roundsStart(S, S + C);\n    vector<int> roundsEnd(E, E + C);\n\n    // Function to simulate the tournament and count wins for a specific position\n    auto simulate = [&](int position) -> int {\n        vector<int> lineup = knights;\n        lineup.insert(lineup.begin() + position, R); // Insert the late knight\n        int wins = 0;\n\n        for (int i = 0; i < C; ++i) {\n            int start = roundsStart[i];\n            int end = roundsEnd[i];\n\n            // Determine the winner of the current round\n            int maxRank = -1;\n            int winnerIndex = -1;\n            for (int j = start; j <= end; ++j) {\n                if (lineup[j] > maxRank) {\n                    maxRank = lineup[j];\n                    winnerIndex = j;\n                }\n            }\n\n            // Check if the late knight wins this round\n            if (lineup[winnerIndex] == R) {\n                ++wins;\n            }\n\n            // Remove all knights except the winner\n            vector<int> newLineup;\n            for (int j = 0; j < lineup.size(); ++j) {\n                if (j < start || j > end || j == winnerIndex) {\n                    newLineup.push_back(lineup[j]);\n                }\n            }\n            lineup = newLineup;\n        }\n\n        return wins;\n    };\n\n    // Try placing the late knight in every position and find the best one\n    int bestPosition = 0;\n    int maxWins = 0;\n\n    for (int position = 0; position <= N - 1; ++position) {\n        int currentWins = simulate(position);\n        if (currentWins > maxWins) {\n            maxWins = currentWins;\n            bestPosition = position;\n        }\n    }\n\n    return bestPosition;\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:28:06",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/F",
    "title": "F. Jousting tournament",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "F",
    "submission_id": "314984265",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint GetBestPosition(int N, int C, int R, int *K, int *S, int *E) {\n    // Convert K array into a vector for easier manipulation\n    vector<int> knights(K, K + N - 1);\n\n    int maxRoundsWon = -1;\n    int bestPosition = 0;\n\n    // Try inserting the late knight at each position\n    for (int pos = 0; pos <= N - 1; ++pos) {\n        // Create a temporary vector for simulation\n        vector<int> currentKnights = knights;\n        currentKnights.insert(currentKnights.begin() + pos, R);\n\n        int roundsWon = 0;\n\n        // Simulate the rounds\n        for (int round = 0; round < C; ++round) {\n            int start = S[round];\n            int end = E[round];\n\n            // Find the winner of the current round\n            int winnerRank = *max_element(currentKnights.begin() + start, currentKnights.begin() + end + 1);\n\n            // Check if the late knight wins this round\n            if (winnerRank == R) {\n                ++roundsWon;\n            }\n\n            // Remove all knights except the winner from the current round\n            vector<int> newKnights;\n            for (int i = 0; i < currentKnights.size(); ++i) {\n                if (i < start || i > end || currentKnights[i] == winnerRank) {\n                    newKnights.push_back(currentKnights[i]);\n                }\n            }\n            currentKnights = newKnights;\n        }\n\n        // Update the best position if this one is better\n        if (roundsWon > maxRoundsWon) {\n            maxRoundsWon = roundsWon;\n            bestPosition = pos;\n        }\n    }\n\n    return bestPosition;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 17:29:08",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/C",
    "title": "C. Fountain Parks",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "C",
    "submission_id": "314984395",
    "code_index": 0,
    "code": "#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// Union-Find / Disjoint Set Union (DSU) for connectivity checks\nclass DSU {\npublic:\n    vector<int> parent, rank;\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        int xr = find(x), yr = find(y);\n        if (xr == yr) return;\n        if (rank[xr] < rank[yr]) {\n            parent[xr] = yr;\n        } else if (rank[xr] > rank[yr]) {\n            parent[yr] = xr;\n        } else {\n            parent[yr] = xr;\n            rank[xr]++;\n        }\n    }\n};\n\n// Function to implement\nint construct_roads(vector<int> x, vector<int> y) {\n    int n = x.size();\n    DSU dsu(n);\n    vector<pair<int, int>> fountains(n);\n    unordered_map<int, vector<int>> x_map, y_map;\n\n    // Map fountains by x and y coordinates\n    for (int i = 0; i < n; i++) {\n        fountains[i] = {x[i], y[i]};\n        x_map[x[i]].push_back(i);\n        y_map[y[i]].push_back(i);\n    }\n\n    // Connect fountains with valid roads using DSU\n    vector<pair<int, int>> roads;\n    for (int i = 0; i < n; i++) {\n        // Check horizontal neighbors\n        for (int j : x_map[x[i]]) {\n            if (abs(y[j] - y[i]) == 2 && dsu.find(i) != dsu.find(j)) {\n                dsu.unite(i, j);\n                roads.push_back({i, j});\n            }\n        }\n        // Check vertical neighbors\n        for (int j : y_map[y[i]]) {\n            if (abs(x[j] - x[i]) == 2 && dsu.find(i) != dsu.find(j)) {\n                dsu.unite(i, j);\n                roads.push_back({i, j});\n            }\n        }\n    }\n\n    // Check if all fountains are connected\n    int root = dsu.find(0);\n    for (int i = 1; i < n; i++) {\n        if (dsu.find(i) != root) return 0; // Not all nodes are connected\n    }\n\n    // Assign benches\n    vector<int> u, v, a, b;\n    unordered_set<long long> benches; // To ensure unique benches\n    for (auto& road : roads) {\n        int i = road.first, j = road.second;\n        int bench_x = (x[i] + x[j]) / 2 + 1; // Pick an odd coordinate\n        int bench_y = (y[i] + y[j]) / 2 + 1; // Pick an odd coordinate\n        while (benches.count((long long)bench_x * 200001 + bench_y)) {\n            bench_x += 2; bench_y += 2; // Ensure uniqueness\n        }\n        benches.insert((long long)bench_x * 200001 + bench_y);\n        u.push_back(i);\n        v.push_back(j);\n        a.push_back(bench_x);\n        b.push_back(bench_y);\n    }\n\n    // Call build\n    build(u, v, a, b);\n    return 1;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 17:29:53",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/C",
    "title": "C. Fountain Parks",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "C",
    "submission_id": "314984480",
    "code_index": 1,
    "code": "#include <vector>\n#include <tuple>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// Helper function to calculate Manhattan distance between two points\nint manhattan_distance(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\n// Disjoint Set Union (DSU) for Kruskal's MST\nclass DSU {\npublic:\n    vector<int> parent, rank;\n\n    DSU(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n\n    int find(int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    }\n\n    bool unite(int u, int v) {\n        int root_u = find(u);\n        int root_v = find(v);\n        if (root_u == root_v) return false;\n        if (rank[root_u] < rank[root_v]) {\n            parent[root_u] = root_v;\n        } else if (rank[root_u] > rank[root_v]) {\n            parent[root_v] = root_u;\n        } else {\n            parent[root_v] = root_u;\n            rank[root_u]++;\n        }\n        return true;\n    }\n};\n\n// Function to construct roads and benches\nint construct_roads(vector<int> x, vector<int> y) {\n    int n = x.size();\n    vector<tuple<int, int, int>> edges; // (distance, node1, node2)\n\n    // Generate all possible edges (Manhattan distance between fountains)\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (x[i] == x[j] || y[i] == y[j]) { // Valid road (horizontal or vertical)\n                int dist = manhattan_distance(x[i], y[i], x[j], y[j]);\n                edges.emplace_back(dist, i, j);\n            }\n        }\n    }\n\n    // Sort edges by distance (for Kruskal's MST)\n    sort(edges.begin(), edges.end());\n\n    // Kruskal's MST algorithm\n    DSU dsu(n);\n    vector<int> u, v, a, b; // Roads and benches\n    for (const auto& [dist, node1, node2] : edges) {\n        if (dsu.unite(node1, node2)) {\n            // Add road\n            u.push_back(node1);\n            v.push_back(node2);\n\n            // Calculate bench location\n            int mid_x = (x[node1] + x[node2]) / 2;\n            int mid_y = (y[node1] + y[node2]) / 2;\n\n            // Offset midpoint to find a valid bench location\n            a.push_back(mid_x + 1); // Odd x-coordinate\n            b.push_back(mid_y + 1); // Odd y-coordinate\n        }\n    }\n\n    // Check if the graph is connected\n    int root = dsu.find(0);\n    for (int i = 1; i < n; ++i) {\n        if (dsu.find(i) != root) return 0; // Not connected\n    }\n\n    // Call build function with the constructed roads and benches\n    build(u, v, a, b);\n    return 1;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 17:30:39",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/C",
    "title": "C. Fountain Parks",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "C",
    "submission_id": "314984581",
    "code_index": 2,
    "code": "#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n// Union-Find (Disjoint Set Union) structure to ensure connectivity.\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    void unite(int x, int y) {\n        int rootX = find(x), rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint construct_roads(vector<int> x, vector<int> y) {\n    int n = x.size();\n    vector<pair<int, int>> fountains;\n    for (int i = 0; i < n; ++i) {\n        fountains.emplace_back(x[i], y[i]);\n    }\n\n    vector<int> u, v, a, b; // Arrays for roads and benches.\n    UnionFind uf(n);\n\n    unordered_set<string> bench_positions; // To ensure distinct bench locations.\n\n    // Iterate over all pairs of fountains to construct roads.\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            int x1 = fountains[i].first, y1 = fountains[i].second;\n            int x2 = fountains[j].first, y2 = fountains[j].second;\n\n            // Check if fountains are exactly two units apart horizontally or vertically.\n            if ((abs(x1 - x2) == 2 && y1 == y2) || (abs(y1 - y2) == 2 && x1 == x2)) {\n                // Construct the road.\n                u.push_back(i);\n                v.push_back(j);\n\n                // Determine a valid bench position.\n                int benchX = (x1 + x2) / 2;\n                int benchY = (y1 + y2) / 2;\n\n                // Ensure benchX and benchY are odd integers.\n                benchX = benchX % 2 == 0 ? benchX + 1 : benchX;\n                benchY = benchY % 2 == 0 ? benchY + 1 : benchY;\n\n                string benchKey = to_string(benchX) + \",\" + to_string(benchY);\n                while (bench_positions.count(benchKey)) {\n                    benchX += 2; // Move to a new odd position.\n                    benchKey = to_string(benchX) + \",\" + to_string(benchY);\n                }\n\n                bench_positions.insert(benchKey);\n                a.push_back(benchX);\n                b.push_back(benchY);\n\n                // Unite the two fountains in the Union-Find structure.\n                uf.unite(i, j);\n            }\n        }\n    }\n\n    // Check if all fountains are connected.\n    int root = uf.find(0);\n    for (int i = 1; i < n; ++i) {\n        if (uf.find(i) != root) {\n            return 0; // Not all fountains are connected.\n        }\n    }\n\n    // Call the build function to report the solution.\n    build(u, v, a, b);\n    return 1;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 17:31:20",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/C",
    "title": "C. Fountain Parks",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "C",
    "submission_id": "314984663",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// Union-Find (Disjoint Set Union) implementation\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n    \n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 1);\n        for (int i = 0; i < n; ++i) parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n    \n    bool connected(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nint construct_roads(vector<int> x, vector<int> y) {\n    int n = x.size();\n    UnionFind uf(n);\n    \n    vector<int> u, v, a, b; // To store the result\n    \n    // Map from coordinates to fountain indices\n    unordered_map<int, unordered_map<int, int>> fountain_map;\n    for (int i = 0; i < n; ++i) {\n        fountain_map[x[i]][y[i]] = i;\n    }\n    \n    // Sort fountains by their coordinates for deterministic processing\n    vector<pair<int, int>> fountains;\n    for (int i = 0; i < n; ++i) {\n        fountains.emplace_back(x[i], y[i]);\n    }\n    sort(fountains.begin(), fountains.end());\n    \n    // Attempt to connect fountains\n    for (int i = 0; i < n; ++i) {\n        int xi = fountains[i].first;\n        int yi = fountains[i].second;\n        int fi = fountain_map[xi][yi];\n        \n        // Check right neighbor\n        if (fountain_map[xi + 2].count(yi)) {\n            int fj = fountain_map[xi + 2][yi];\n            if (!uf.connected(fi, fj)) {\n                uf.unite(fi, fj);\n                u.push_back(fi);\n                v.push_back(fj);\n                a.push_back(xi + 1);\n                b.push_back(yi + 1); // Valid bench position\n            }\n        }\n        \n        // Check upper neighbor\n        if (fountain_map[xi].count(yi + 2)) {\n            int fj = fountain_map[xi][yi + 2];\n            if (!uf.connected(fi, fj)) {\n                uf.unite(fi, fj);\n                u.push_back(fi);\n                v.push_back(fj);\n                a.push_back(xi + 1);\n                b.push_back(yi + 1); // Valid bench position\n            }\n        }\n    }\n    \n    // Check if all fountains are connected\n    int root = uf.find(0);\n    for (int i = 1; i < n; ++i) {\n        if (uf.find(i) != root) {\n            return 0; // Not all fountains are connected\n        }\n    }\n    \n    // Call the build function with the constructed roads and benches\n    build(u, v, a, b);\n    return 1;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 17:32:00",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/C",
    "title": "C. Fountain Parks",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "C",
    "submission_id": "314984741",
    "code_index": 4,
    "code": "#include <vector>\n#include <unordered_map>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\n// Helper structure for union-find\nclass UnionFind {\npublic:\n    vector<int> parent, rank;\n\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n};\n\nint construct_roads(vector<int> x, vector<int> y) {\n    int n = x.size();\n\n    // Step 1: Build graph edges (roads)\n    vector<pair<int, int>> fountains;\n    unordered_map<int, vector<int>> x_map, y_map;\n    for (int i = 0; i < n; ++i) {\n        fountains.emplace_back(x[i], y[i]);\n        x_map[x[i]].push_back(i);\n        y_map[y[i]].push_back(i);\n    }\n\n    vector<int> u, v, a, b; // Roads and benches\n    UnionFind uf(n);\n\n    // Horizontal roads\n    for (auto& [key, indices] : x_map) {\n        sort(indices.begin(), indices.end(), [&](int i, int j) { return y[i] < y[j]; });\n        for (size_t i = 1; i < indices.size(); ++i) {\n            int idx1 = indices[i - 1];\n            int idx2 = indices[i];\n            if (y[idx2] - y[idx1] == 2) {\n                u.push_back(idx1);\n                v.push_back(idx2);\n                a.push_back(x[idx1] + 1);\n                b.push_back(y[idx1] + 1);\n                uf.unite(idx1, idx2);\n            }\n        }\n    }\n\n    // Vertical roads\n    for (auto& [key, indices] : y_map) {\n        sort(indices.begin(), indices.end(), [&](int i, int j) { return x[i] < x[j]; });\n        for (size_t i = 1; i < indices.size(); ++i) {\n            int idx1 = indices[i - 1];\n            int idx2 = indices[i];\n            if (x[idx2] - x[idx1] == 2) {\n                u.push_back(idx1);\n                v.push_back(idx2);\n                a.push_back(x[idx1] + 1);\n                b.push_back(y[idx1] + 1);\n                uf.unite(idx1, idx2);\n            }\n        }\n    }\n\n    // Step 2: Check connectivity\n    int root = uf.find(0);\n    for (int i = 1; i < n; ++i) {\n        if (uf.find(i) != root) {\n            return 0; // Not all fountains are connected\n        }\n    }\n\n    // Step 3: Call build and return 1\n    build(u, v, a, b);\n    return 1;\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 17:32:47",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/C",
    "title": "C. Crayfish scrivener",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "C",
    "submission_id": "314984815",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Data structure to maintain the versions of the text\nvector<vector<char>> versions;\n\nvoid Init() {\n    // Initialize the data structure with an empty text\n    versions.clear();\n    versions.push_back({});\n}\n\nvoid TypeLetter(char L) {\n    // Create a new version by appending the letter to the current version\n    vector<char> newVersion = versions.back();\n    newVersion.push_back(L);\n    versions.push_back(newVersion);\n}\n\nvoid UndoCommands(int U) {\n    // Access the version that is U steps back\n    int targetVersion = versions.size() - 1 - U;\n    versions.push_back(versions[targetVersion]);\n}\n\nchar GetLetter(int P) {\n    // Access the current version and return the letter at position P\n    return versions.back()[P];\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 17:33:29",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/C",
    "title": "C. Crayfish scrivener",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "C",
    "submission_id": "314984887",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n\nstd::vector<std::string> versionHistory;\n\nvoid Init() {\n    // Initialize the version history with an empty string.\n    versionHistory.clear();\n    versionHistory.push_back(\"\");\n}\n\nvoid TypeLetter(char L) {\n    // Append the letter to the current version of the text and save it as a new version.\n    versionHistory.push_back(versionHistory.back() + L);\n}\n\nvoid UndoCommands(int U) {\n    // Undo U commands by going back U versions.\n    int currentVersion = versionHistory.size() - 1;\n    int targetVersion = currentVersion - U;\n    versionHistory.push_back(versionHistory[targetVersion]);\n}\n\nchar GetLetter(int P) {\n    // Return the letter at position P in the current version of the text.\n    return versionHistory.back()[P];\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 17:34:11",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/C",
    "title": "C. Crayfish scrivener",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "C",
    "submission_id": "314984887",
    "code_index": 2,
    "code": "// Your code will be placed here\n\n#include <vector>\n#include <string>\n\nstd::vector<std::string> states; // Stores all versions of the text\nint currentState = 0;            // Points to the current state\n\nvoid Init() {\n    states.clear();\n    states.push_back(\"\");        // Start with an empty text\n    currentState = 0;\n}\n\nvoid TypeLetter(char L) {\n    // Create a new state by appending the letter to the current text\n    states.push_back(states[currentState] + L);\n    currentState++;\n}\n\nvoid UndoCommands(int U) {\n    // Move the current state pointer backwards by U steps\n    currentState -= U;\n}\n\nchar GetLetter(int P) {\n    // Return the letter at position P in the current text\n    return states[currentState][P];\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 17:34:50",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/C",
    "title": "C. Crayfish scrivener",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "C",
    "submission_id": "314985029",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Persistent data structure to manage versions of text\nvector<string> textVersions;\n\nvoid Init() {\n    // Initialize with an empty string as the first version\n    textVersions.clear();\n    textVersions.push_back(\"\");\n}\n\nvoid TypeLetter(char L) {\n    // Append the character to the current version and create a new version\n    string newVersion = textVersions.back() + L;\n    textVersions.push_back(newVersion);\n}\n\nvoid UndoCommands(int U) {\n    // Undo the last U commands by reverting to an earlier version\n    int currentVersion = textVersions.size() - 1;\n    int newVersionIndex = currentVersion - U;\n    textVersions.push_back(textVersions[newVersionIndex]);\n}\n\nchar GetLetter(int P) {\n    // Retrieve the character at position P in the current version\n    return textVersions.back()[P];\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 17:35:36",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/C",
    "title": "C. Crayfish scrivener",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "C",
    "submission_id": "314985092",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Persistent data structure to track text states\nvector<vector<char>> states;\n\nvoid Init() {\n    // Initialize the first state as an empty text\n    states.clear();\n    states.push_back({});\n}\n\nvoid TypeLetter(char L) {\n    // Create a new state by appending the letter to the current state\n    states.push_back(states.back());\n    states.back().push_back(L);\n}\n\nvoid UndoCommands(int U) {\n    // Undo U commands by reverting to the state U commands ago\n    states.push_back(states[states.size() - 1 - U]);\n}\n\nchar GetLetter(int P) {\n    // Return the letter at position P in the current state\n    return states.back()[P];\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 17:36:29",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/B",
    "title": "B. Message",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "B",
    "submission_id": "314985204",
    "code_index": 0,
    "code": "// Your code will be placed here\n\n#include <vector>\n#include <algorithm>\n\nstd::vector<bool> send_packet(std::vector<bool> A);\n\nvoid send_message(std::vector<bool> M, std::vector<bool> C) {\n    // Identify the indices of uncontrollable bits (C[i] = 0)\n    std::vector<int> uncontrollable_indices;\n    for (int i = 0; i < 31; ++i) {\n        if (C[i] == 0) {\n            uncontrollable_indices.push_back(i);\n        }\n    }\n\n    // Number of uncontrollable bits in a single packet\n    int uncontrollable_count = uncontrollable_indices.size();\n\n    // Divide the message M into chunks that fit into the uncontrollable bits of a packet\n    int message_length = M.size();\n    for (int i = 0; i < message_length; i += uncontrollable_count) {\n        // Create a packet of length 31\n        std::vector<bool> packet(31, 0);\n\n        // Fill the uncontrollable bits with the corresponding message bits\n        for (int j = 0; j < uncontrollable_count && (i + j) < message_length; ++j) {\n            packet[uncontrollable_indices[j]] = M[i + j];\n        }\n\n        // Send the packet\n        send_packet(packet);\n    }\n}\n\nstd::vector<bool> receive_message(std::vector<std::vector<bool>> R) {\n    // Number of received packets\n    int num_packets = R.size();\n\n    // Determine the uncontrollable indices from the first packet\n    std::vector<int> uncontrollable_indices;\n    for (int i = 0; i < 31; ++i) {\n        bool consistent = true;\n        for (int j = 1; j < num_packets; ++j) {\n            if (R[j][i] != R[0][i]) {\n                consistent = false;\n                break;\n            }\n        }\n        if (consistent) {\n            uncontrollable_indices.push_back(i);\n        }\n    }\n\n    // Reconstruct the original message\n    std::vector<bool> message;\n    for (const auto& packet : R) {\n        for (int index : uncontrollable_indices) {\n            message.push_back(packet[index]);\n        }\n    }\n\n    return message;\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 17:37:09",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/B",
    "title": "B. Message",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "B",
    "submission_id": "314985267",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n\n// Send a message from Aisha to Basma\nvoid send_message(std::vector<bool> M, std::vector<bool> C) {\n    // Determine the indices of protected bits (C[i] == 0)\n    std::vector<int> protected_indices;\n    for (int i = 0; i < 31; ++i) {\n        if (C[i] == 0) {\n            protected_indices.push_back(i);\n        }\n    }\n\n    int S = M.size();  // Length of the message\n    int num_protected = protected_indices.size();  // Number of protected bits (16)\n\n    // Send packets to transmit the message\n    for (int i = 0; i < S; i += num_protected) {\n        // Construct a packet\n        std::vector<bool> packet(31, 0);  // Initialize all bits to 0\n\n        // Fill the protected bits with the current chunk of the message\n        for (int j = 0; j < num_protected && i + j < S; ++j) {\n            packet[protected_indices[j]] = M[i + j];\n        }\n\n        // Send the packet\n        send_packet(packet);\n    }\n}\n\n// Receive a message from Basma\nstd::vector<bool> receive_message(std::vector<std::vector<bool>> R) {\n    int num_packets = R.size();\n    int packet_length = 31;\n\n    // Determine the indices of protected bits (bits that are constant across all packets)\n    std::vector<int> protected_indices;\n    for (int i = 0; i < packet_length; ++i) {\n        bool is_protected = true;\n        for (int j = 1; j < num_packets; ++j) {\n            if (R[j][i] != R[0][i]) {\n                is_protected = false;\n                break;\n            }\n        }\n        if (is_protected) {\n            protected_indices.push_back(i);\n        }\n    }\n\n    // Reconstruct the original message\n    std::vector<bool> message;\n    for (const auto& packet : R) {\n        for (int index : protected_indices) {\n            message.push_back(packet[index]);\n        }\n    }\n\n    return message;\n}"
  },
  {
    "date": "IOI 2024 day 1",
    "timestamp": "2025-04-11 17:37:58",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105328/problem/B",
    "title": "B. Message",
    "group_id": "32KGsXgiKA",
    "contest_id": "105328",
    "problem_index": "B",
    "submission_id": "314985335",
    "code_index": 2,
    "code": "#include <vector>\n\n// Grader function declaration (provided by the system)\nstd::vector<bool> send_packet(std::vector<bool> A);\n\n// Aisha's function to send the message\nvoid send_message(std::vector<bool> M, std::vector<bool> C) {\n    // Identify the 16 uncontrolled indices\n    std::vector<int> uncontrolled_indices;\n    for (int i = 0; i < 31; ++i) {\n        if (C[i] == 0) {\n            uncontrolled_indices.push_back(i);\n        }\n    }\n\n    // Ensure we have exactly 16 uncontrolled indices\n    int chunk_size = uncontrolled_indices.size();\n    \n    // Divide the message into chunks of size 16\n    int S = M.size();\n    for (int i = 0; i < S; i += chunk_size) {\n        // Create a packet\n        std::vector<bool> packet(31, false); // Initialize all bits to 0\n        \n        // Fill the uncontrolled indices with the current chunk of the message\n        for (int j = 0; j < chunk_size && (i + j) < S; ++j) {\n            packet[uncontrolled_indices[j]] = M[i + j];\n        }\n        \n        // Send the packet\n        send_packet(packet);\n    }\n}\n\n// Basma's function to receive the message\nstd::vector<bool> receive_message(std::vector<std::vector<bool>> R) {\n    std::vector<bool> M; // Reconstructed message\n\n    // Iterate over each received packet\n    for (const auto& packet : R) {\n        // Extract the 16 bits from the uncontrolled indices\n        for (int i = 0; i < 31; ++i) {\n            if (packet[i] == 0 || packet[i] == 1) {\n                M.push_back(packet[i]);\n            }\n        }\n    }\n\n    return M;\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:39:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/D",
    "title": "D. Ideal city",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "D",
    "submission_id": "314985456",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000000;\n\nvoid DistanceSum(int N, vector<int> X, vector<int> Y, long long &result) {\n    // Sort the X and Y coordinates\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n\n    // Helper function to compute 1D contribution\n    auto compute_1D_contribution = [](const vector<int> &coords) -> long long {\n        long long sum = 0, prefix_sum = 0;\n        int n = coords.size();\n        for (int i = 0; i < n; ++i) {\n            long long current = coords[i];\n            sum = (sum + (current * i - prefix_sum) % MOD) % MOD;\n            prefix_sum = (prefix_sum + current) % MOD;\n        }\n        return sum;\n    };\n\n    // Compute contributions for X and Y\n    long long x_contribution = compute_1D_contribution(X);\n    long long y_contribution = compute_1D_contribution(Y);\n\n    // Combine results and take modulo\n    result = (x_contribution + y_contribution) % MOD;\n    if (result < 0) result += MOD;\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:39:50",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/D",
    "title": "D. Ideal city",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "D",
    "submission_id": "314985526",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nconst int MOD = 1'000'000'000;\n\nlong long computeCoordinateContribution(vector<int>& coords) {\n    int n = coords.size();\n    sort(coords.begin(), coords.end());\n    \n    vector<long long> prefixSum(n, 0);\n    prefixSum[0] = coords[0];\n    for (int i = 1; i < n; ++i) {\n        prefixSum[i] = (prefixSum[i - 1] + coords[i]) % MOD;\n    }\n    \n    long long contribution = 0;\n    for (int i = 0; i < n; ++i) {\n        long long leftSum = i > 0 ? prefixSum[i - 1] : 0;\n        long long rightSum = (prefixSum[n - 1] - prefixSum[i] + MOD) % MOD;\n        long long leftCount = i;\n        long long rightCount = n - i - 1;\n        \n        long long currentContribution = (leftCount * 1LL * coords[i] - leftSum + MOD) % MOD;\n        currentContribution = (currentContribution + (rightSum - rightCount * 1LL * coords[i] + MOD) % MOD) % MOD;\n        contribution = (contribution + currentContribution) % MOD;\n    }\n    \n    return contribution;\n}\n\nint DistanceSum(int N, vector<int> X, vector<int> Y) {\n    long long xContribution = computeCoordinateContribution(X);\n    long long yContribution = computeCoordinateContribution(Y);\n    return (xContribution + yContribution) % MOD;\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:40:31",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/D",
    "title": "D. Ideal city",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "D",
    "submission_id": "314985526",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000000;\n\nlong long compute_pairwise_sum(const vector<int>& coords) {\n    int n = coords.size();\n    vector<int> sorted_coords = coords;\n    sort(sorted_coords.begin(), sorted_coords.end());\n\n    long long prefix_sum = 0;\n    long long total_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        long long current = sorted_coords[i];\n        total_sum += (current * i - prefix_sum) % MOD;\n        total_sum %= MOD;\n        prefix_sum += current;\n        prefix_sum %= MOD;\n    }\n\n    return total_sum;\n}\n\nint DistanceSum(int N, vector<int> X, vector<int> Y) {\n    long long x_sum = compute_pairwise_sum(X);\n    long long y_sum = compute_pairwise_sum(Y);\n\n    long long result = (x_sum + y_sum) % MOD;\n    return (int)result;\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:41:14",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/D",
    "title": "D. Ideal city",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "D",
    "submission_id": "314985675",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000000;\n\nlong long calculateSum(vector<int>& coords, int N) {\n    // Sort the coordinates\n    sort(coords.begin(), coords.end());\n    \n    // Prefix sum array\n    vector<long long> prefixSum(N, 0);\n    prefixSum[0] = coords[0];\n    for (int i = 1; i < N; i++) {\n        prefixSum[i] = (prefixSum[i - 1] + coords[i]) % MOD;\n    }\n    \n    // Calculate the total sum of pairwise distances\n    long long totalSum = 0;\n    for (int i = 0; i < N; i++) {\n        long long leftSum = (1LL * coords[i] * i - (i > 0 ? prefixSum[i - 1] : 0)) % MOD;\n        long long rightSum = ((prefixSum[N - 1] - prefixSum[i] + MOD) % MOD - 1LL * coords[i] * (N - i - 1)) % MOD;\n        totalSum = (totalSum + leftSum + rightSum) % MOD;\n    }\n    \n    return totalSum;\n}\n\nint DistanceSum(int N, vector<int> X, vector<int> Y) {\n    // Calculate the sum of pairwise distances for X and Y separately\n    long long xSum = calculateSum(X, N);\n    long long ySum = calculateSum(Y, N);\n    \n    // Combine the results and return modulo MOD\n    return (xSum + ySum) % MOD;\n}"
  },
  {
    "date": "IOI 2012 day 2",
    "timestamp": "2025-04-11 17:41:56",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103761/problem/D",
    "title": "D. Ideal city",
    "group_id": "32KGsXgiKA",
    "contest_id": "103761",
    "problem_index": "D",
    "submission_id": "314985761",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MOD = 1000000000;\n\nlong long computeSum(const vector<int>& coords) {\n    int N = coords.size();\n    vector<int> sorted_coords = coords;\n    sort(sorted_coords.begin(), sorted_coords.end());\n    \n    long long prefix_sum = 0;\n    long long total_sum = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        long long current = sorted_coords[i];\n        // Contribution of sorted_coords[i]\n        total_sum += (current * i - prefix_sum) % MOD;\n        total_sum %= MOD;\n        prefix_sum += current;\n        prefix_sum %= MOD;\n    }\n    \n    return total_sum;\n}\n\nint DistanceSum(int N, vector<int> X, vector<int> Y) {\n    // Compute the sum of pairwise distances for X-coordinates and Y-coordinates\n    long long sum_x = computeSum(X);\n    long long sum_y = computeSum(Y);\n    \n    // Total sum is the sum of both contributions, modulo MOD\n    return (sum_x + sum_y) % MOD;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 17:42:45",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/C",
    "title": "C. Radio Towers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "C",
    "submission_id": "314856834",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <stack>\n\nusing namespace std;\n\nstruct Tower {\n    int height;\n    int index;\n};\n\nint N;\nvector<int> heights;\n\n// Function to initialize the tower heights\nvoid init(int N_, vector<int> H) {\n    N = N_;\n    heights = H;\n}\n\n// Function to compute the maximum number of towers that can be leased\nint max_towers(int L, int R, int D) {\n    // Filter the towers within the range [L, R]\n    vector<Tower> towers;\n    for (int i = L; i <= R; ++i) {\n        towers.push_back({heights[i], i});\n    }\n\n    // Sort the towers by height\n    sort(towers.begin(), towers.end(), [](const Tower &a, const Tower &b) {\n        return a.height < b.height;\n    });\n\n    // Use a dynamic programming approach to calculate the maximum number of towers\n    int size = towers.size();\n    vector<int> dp(size, 1);\n\n    for (int i = 0; i < size; ++i) {\n        for (int j = 0; j < i; ++j) {\n            // Check if towers[i] and towers[j] can communicate via an intermediary\n            if (towers[i].height <= towers[j].height + D) continue;\n\n            // Check for an intermediary tower\n            for (int k = j + 1; k < i; ++k) {\n                if (towers[k].height >= max(towers[j].height + D, towers[i].height + D)) {\n                    dp[i] = max(dp[i], dp[j] + 1);\n                    break;\n                }\n            }\n        }\n    }\n\n    // Return the maximum number of towers that can be leased\n    return *max_element(dp.begin(), dp.end());\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 17:43:24",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/C",
    "title": "C. Radio Towers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "C",
    "submission_id": "314985931",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint N;\nvector<int> H;\nvector<int> leftMax, rightMax;\n\n// Preprocess to compute the maximum height to the left and right of each tower\nvoid init(int N, vector<int> H) {\n    ::N = N;\n    ::H = H;\n    leftMax.resize(N);\n    rightMax.resize(N);\n\n    // Compute leftMax[i]: maximum height from H[0] to H[i-1]\n    leftMax[0] = -1; // No tower to the left of the first tower\n    for (int i = 1; i < N; ++i) {\n        leftMax[i] = max(leftMax[i-1], H[i-1]);\n    }\n\n    // Compute rightMax[i]: maximum height from H[i+1] to H[N-1]\n    rightMax[N-1] = -1; // No tower to the right of the last tower\n    for (int i = N-2; i >= 0; --i) {\n        rightMax[i] = max(rightMax[i+1], H[i+1]);\n    }\n}\n\nint max_towers(int L, int R, int D) {\n    vector<int> validTowers;\n\n    // Identify towers in range [L, R] that can potentially communicate\n    for (int i = L; i <= R; ++i) {\n        if ((leftMax[i] >= H[i] + D) || (rightMax[i] >= H[i] + D)) {\n            validTowers.push_back(H[i]);\n        }\n    }\n\n    // Sort valid towers by height to ensure proper ordering\n    sort(validTowers.begin(), validTowers.end());\n\n    // Find the largest subset of valid towers using a greedy approach\n    int count = 0;\n    int prevHeight = -1;\n    for (int height : validTowers) {\n        if (prevHeight == -1 || height >= prevHeight + D) {\n            count++;\n            prevHeight = height;\n        }\n    }\n\n    return count;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 17:44:15",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/C",
    "title": "C. Radio Towers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "C",
    "submission_id": "314986019",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nvector<int> heights;\nvector<int> sorted_indices;\n\nvoid init(int N, vector<int> H) {\n    heights = H;\n    sorted_indices.resize(N);\n    for (int i = 0; i < N; i++) {\n        sorted_indices[i] = i;\n    }\n    // Precompute sorted indices based on heights\n    sort(sorted_indices.begin(), sorted_indices.end(), [&](int a, int b) {\n        return heights[a] < heights[b];\n    });\n}\n\nint max_towers(int L, int R, int D) {\n    // Extract the relevant range of indices and filter based on the height condition\n    vector<int> candidates;\n    for (int idx : sorted_indices) {\n        if (idx >= L && idx <= R) {\n            candidates.push_back(idx);\n        }\n    }\n\n    int n = candidates.size();\n    vector<int> dp(n, 1); // dp[i] represents the max towers ending at candidates[i]\n\n    // Compute DP using the condition for communication\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            int k = candidates[i];\n            int l = candidates[j];\n            if (heights[k] <= heights[l] - D) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n\n    // Find the maximum value in dp\n    return *max_element(dp.begin(), dp.end());\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 17:44:56",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/C",
    "title": "C. Radio Towers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "C",
    "submission_id": "314986104",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\nusing namespace std;\n\nvector<int> heights;\nvector<vector<int>> sparseTable;\nint N;\n\n// Preprocess the height array for range maximum queries using a sparse table\nvoid buildSparseTable() {\n    int logN = log2(N) + 1;\n    sparseTable.assign(N, vector<int>(logN));\n    for (int i = 0; i < N; ++i) {\n        sparseTable[i][0] = heights[i];\n    }\n    for (int j = 1; (1 << j) <= N; ++j) {\n        for (int i = 0; i + (1 << j) - 1 < N; ++i) {\n            sparseTable[i][j] = max(sparseTable[i][j - 1], sparseTable[i + (1 << (j - 1))][j - 1]);\n        }\n    }\n}\n\n// Query the maximum value in the range [L, R]\nint rangeMax(int L, int R) {\n    int j = log2(R - L + 1);\n    return max(sparseTable[L][j], sparseTable[R - (1 << j) + 1][j]);\n}\n\nvoid init(int n, vector<int> H) {\n    N = n;\n    heights = H;\n    buildSparseTable();\n}\n\nint max_towers(int L, int R, int D) {\n    vector<pair<int, int>> rangeTowers;\n    for (int i = L; i <= R; ++i) {\n        rangeTowers.emplace_back(heights[i], i);\n    }\n    sort(rangeTowers.begin(), rangeTowers.end());\n\n    // DP to find the largest valid subset\n    int maxTowers = 0;\n    vector<int> dp(rangeTowers.size(), 1);\n\n    for (int i = 0; i < rangeTowers.size(); ++i) {\n        int h1 = rangeTowers[i].first;\n        int idx1 = rangeTowers[i].second;\n        for (int j = 0; j < i; ++j) {\n            int h2 = rangeTowers[j].first;\n            int idx2 = rangeTowers[j].second;\n            if (idx2 < idx1) {\n                int kMax = rangeMax(idx2 + 1, idx1 - 1);\n                if (h1 <= kMax - D && h2 <= kMax - D) {\n                    dp[i] = max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        maxTowers = max(maxTowers, dp[i]);\n    }\n\n    return maxTowers;\n}"
  },
  {
    "date": "IOI 2022 day 1",
    "timestamp": "2025-04-11 17:45:37",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103877/problem/C",
    "title": "C. Radio Towers",
    "group_id": "32KGsXgiKA",
    "contest_id": "103877",
    "problem_index": "C",
    "submission_id": "314986183",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n\nusing namespace std;\n\nint N;\nvector<int> heights;\nvector<int> sorted_indices;\n\n// Precomputes the sorted indices of the towers based on their heights\nvoid init(int N, vector<int> H) {\n    ::N = N;\n    heights = H;\n    sorted_indices.resize(N);\n    for (int i = 0; i < N; ++i) {\n        sorted_indices[i] = i;\n    }\n    sort(sorted_indices.begin(), sorted_indices.end(), [&](int a, int b) {\n        return heights[a] < heights[b];\n    });\n}\n\n// Returns the maximum number of towers that can be leased for the given query\nint max_towers(int L, int R, int D) {\n    vector<int> valid_towers; // Towers within range [L, R]\n    for (int i = L; i <= R; ++i) {\n        valid_towers.push_back(i);\n    }\n\n    // Sort valid towers by height\n    sort(valid_towers.begin(), valid_towers.end(), [&](int a, int b) {\n        return heights[a] < heights[b];\n    });\n\n    // Use a greedy strategy to find the maximum set of towers that can communicate\n    int max_count = 0;\n    for (int i = 0; i < valid_towers.size(); ++i) {\n        for (int j = i + 1; j < valid_towers.size(); ++j) {\n            int h_i = heights[valid_towers[i]];\n            int h_j = heights[valid_towers[j]];\n            bool found_intermediary = false;\n\n            // Check for an intermediary tower\n            for (int k : valid_towers) {\n                if (valid_towers[i] < k && k < valid_towers[j]) {\n                    if (h_i <= heights[k] - D && h_j <= heights[k] - D) {\n                        found_intermediary = true;\n                        break;\n                    }\n                }\n            }\n\n            if (found_intermediary) {\n                max_count = max(max_count, j - i + 1);\n            }\n        }\n    }\n\n    return max_count;\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 17:46:23",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/B",
    "title": "B. Race",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "B",
    "submission_id": "314986260",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nvoid dfs(int current, int parent, int current_length, int current_highways, int K, const vector<vector<pair<int, int>>>& adj, int& min_highways) {\n    // If the current length exceeds K, stop exploring this path\n    if (current_length > K) return;\n\n    // If the current length is exactly K, update the minimum number of highways\n    if (current_length == K) {\n        min_highways = min(min_highways, current_highways);\n        return;\n    }\n\n    // Explore neighbors\n    for (const auto& neighbor : adj[current]) {\n        int next_city = neighbor.first;\n        int highway_length = neighbor.second;\n\n        // Avoid revisiting the parent city\n        if (next_city != parent) {\n            dfs(next_city, current, current_length + highway_length, current_highways + 1, K, adj, min_highways);\n        }\n    }\n}\n\nint best_path(int N, int K, vector<vector<int>> H, vector<int> L) {\n    // Step 1: Build the adjacency list\n    vector<vector<pair<int, int>>> adj(N); // adjacency list: city -> [(neighbor, length)]\n    for (int i = 0; i < H.size(); ++i) {\n        int u = H[i][0];\n        int v = H[i][1];\n        int length = L[i];\n        adj[u].emplace_back(v, length);\n        adj[v].emplace_back(u, length);\n    }\n\n    // Step 2: Initialize the result\n    int min_highways = N + 1; // Initialize with a large value\n\n    // Step 3: Perform DFS from each city\n    for (int start_city = 0; start_city < N; ++start_city) {\n        dfs(start_city, -1, 0, 0, K, adj, min_highways);\n    }\n\n    // Step 4: Return the result\n    return (min_highways == N + 1) ? -1 : min_highways;\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 17:47:03",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/B",
    "title": "B. Race",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "B",
    "submission_id": "314986353",
    "code_index": 1,
    "code": "#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// Helper function to perform DFS and find paths with the desired length K\nvoid dfs(int node, int parent, const vector<vector<pair<int, int>>>& adj, int current_length, int current_highways, int K, int& min_highways) {\n    // If the current path length exceeds K, return early\n    if (current_length > K) return;\n\n    // If the path length is exactly K, update the minimum highways and return\n    if (current_length == K) {\n        min_highways = min(min_highways, current_highways);\n        return;\n    }\n\n    // Explore neighbors\n    for (const auto& neighbor : adj[node]) {\n        int next_node = neighbor.first;\n        int length = neighbor.second;\n\n        // Avoid revisiting the parent node\n        if (next_node != parent) {\n            dfs(next_node, node, adj, current_length + length, current_highways + 1, K, min_highways);\n        }\n    }\n}\n\n// Main function to find the best path\nint best_path(int N, int K, vector<vector<int>> H, vector<int> L) {\n    // Build adjacency list representation of the tree\n    vector<vector<pair<int, int>>> adj(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u = H[i][0];\n        int v = H[i][1];\n        int length = L[i];\n        adj[u].emplace_back(v, length);\n        adj[v].emplace_back(u, length);\n    }\n\n    // Initialize the minimum highways to a large value\n    int min_highways = INT_MAX;\n\n    // Perform DFS from each node as the starting point\n    for (int i = 0; i < N; ++i) {\n        dfs(i, -1, adj, 0, 0, K, min_highways);\n    }\n\n    // If no valid path is found, return -1\n    return (min_highways == INT_MAX) ? -1 : min_highways;\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 17:47:46",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/B",
    "title": "B. Race",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "B",
    "submission_id": "314986440",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nvoid dfs(int node, int parent, const vector<vector<pair<int, int>>>& graph, vector<int>& path, vector<int>& path_lengths, unordered_map<int, int>& edge_map) {\n    for (const auto& neighbor : graph[node]) {\n        int next_node = neighbor.first;\n        int edge_length = neighbor.second;\n        if (next_node != parent) {\n            path.push_back(next_node);\n            path_lengths.push_back(edge_length);\n            edge_map[next_node] = edge_length;\n            dfs(next_node, node, graph, path, path_lengths, edge_map);\n            path.pop_back();\n            path_lengths.pop_back();\n            edge_map.erase(next_node);\n        }\n    }\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 17:48:26",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/B",
    "title": "B. Race",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "B",
    "submission_id": "314986510",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\nvoid dfs(int node, int parent, int current_length, int current_edges, int K, vector<vector<pair<int, int>>> &adj, int &min_edges) {\n    if (current_length > K) return; // Prune if the path length exceeds K\n    if (current_length == K) {\n        min_edges = min(min_edges, current_edges); // Update minimum edges if length matches K\n        return;\n    }\n    \n    for (auto &[neighbor, weight] : adj[node]) {\n        if (neighbor != parent) { // Avoid revisiting the parent node\n            dfs(neighbor, node, current_length + weight, current_edges + 1, K, adj, min_edges);\n        }\n    }\n}\n\nint best_path(int N, int K, vector<vector<int>> H, vector<int> L) {\n    // Step 1: Build the adjacency list\n    vector<vector<pair<int, int>>> adj(N);\n    for (int i = 0; i < N - 1; ++i) {\n        int u = H[i][0];\n        int v = H[i][1];\n        int w = L[i];\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n    \n    // Step 2: Initialize the result\n    int min_edges = INT_MAX;\n    \n    // Step 3: Perform DFS from every node\n    for (int i = 0; i < N; ++i) {\n        dfs(i, -1, 0, 0, K, adj, min_edges);\n    }\n    \n    // Step 4: Return the result\n    return (min_edges == INT_MAX) ? -1 : min_edges;\n}"
  },
  {
    "date": "IOI 2011 day 1",
    "timestamp": "2025-04-11 17:49:09",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103758/problem/B",
    "title": "B. Race",
    "group_id": "32KGsXgiKA",
    "contest_id": "103758",
    "problem_index": "B",
    "submission_id": "314986592",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n#include <climits>\nusing namespace std;\n\nvoid dfs(int node, int parent, const vector<vector<pair<int, int>>>& graph, vector<int>& path_lengths, vector<int>& path_edges, int& result, int K) {\n    path_lengths.push_back(0);  // Start with current node\n    path_edges.push_back(0);    // Start with 0 edges\n\n    // Traverse the neighbors\n    for (const auto& [neighbor, length] : graph[node]) {\n        if (neighbor == parent) continue;\n\n        // Recur for the child node\n        dfs(neighbor, node, graph, path_lengths, path_edges, result, K);\n    }\n\n    // Sliding window to find paths of length K\n    int cumulative_length = 0;\n    for (int i = path_lengths.size() - 1; i >= 0; --i) {\n        cumulative_length += path_lengths[i];\n        if (cumulative_length == K) {\n            // Update result with minimum edges\n            result = min(result, path_edges.size());\n        }\n    }\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 17:49:57",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/C",
    "title": "C. Rectangles",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "C",
    "submission_id": "314986693",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint64_t count_rectangles(vector<vector<int>> a) {\n    int n = a.size();\n    int m = a[0].size();\n    \n    // Step 1: Preprocess to determine valid cells\n    vector<vector<bool>> is_valid(n, vector<bool>(m, false));\n    for (int i = 1; i < n - 1; ++i) {\n        for (int j = 1; j < m - 1; ++j) {\n            if (a[i][j] < a[i-1][j] && a[i][j] < a[i+1][j] &&\n                a[i][j] < a[i][j-1] && a[i][j] < a[i][j+1]) {\n                is_valid[i][j] = true;\n            }\n        }\n    }\n\n    // Step 2: Use dynamic programming to count rectangles\n    vector<vector<int>> dp(n, vector<int>(m, 0));\n    int64_t result = 0;\n\n    for (int j = 1; j < m - 1; ++j) {\n        for (int i = 1; i < n - 1; ++i) {\n            if (is_valid[i][j]) {\n                dp[i][j] = dp[i-1][j] + 1; // Extend the streak of valid cells vertically\n                int min_height = dp[i][j];\n\n                // Count rectangles ending at (i, j) by extending horizontally\n                for (int k = j; k >= 1; --k) {\n                    if (!is_valid[i][k]) break;\n                    min_height = min(min_height, dp[i][k]);\n                    result += min_height;\n                }\n            }\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 17:50:36",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/C",
    "title": "C. Rectangles",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "C",
    "submission_id": "314986761",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint64_t count_rectangles(vector<vector<int>> a) {\n    int n = a.size();\n    int m = a[0].size();\n    vector<vector<int>> max_left(n, vector<int>(m, 0));\n    vector<vector<int>> max_right(n, vector<int>(m, 0));\n    vector<vector<int>> max_up(n, vector<int>(m, 0));\n    vector<vector<int>> max_down(n, vector<int>(m, 0));\n\n    // Precompute max_left and max_right for each row\n    for (int i = 0; i < n; ++i) {\n        for (int j = 1; j < m; ++j) {\n            max_left[i][j] = max(a[i][j - 1], max_left[i][j - 1]);\n        }\n        for (int j = m - 2; j >= 0; --j) {\n            max_right[i][j] = max(a[i][j + 1], max_right[i][j + 1]);\n        }\n    }\n\n    // Precompute max_up and max_down for each column\n    for (int j = 0; j < m; ++j) {\n        for (int i = 1; i < n; ++i) {\n            max_up[i][j] = max(a[i - 1][j], max_up[i - 1][j]);\n        }\n        for (int i = n - 2; i >= 0; --i) {\n            max_down[i][j] = max(a[i + 1][j], max_down[i + 1][j]);\n        }\n    }\n\n    int64_t valid_rectangles = 0;\n\n    // Iterate over all possible starting and ending rows\n    for (int r1 = 1; r1 < n - 1; ++r1) {\n        for (int r2 = r1; r2 < n - 1; ++r2) {\n            vector<int> valid_cols(m, 1);\n\n            // Check each column for validity across rows r1 to r2\n            for (int j = 1; j < m - 1; ++j) {\n                for (int i = r1; i <= r2; ++i) {\n                    if (a[i][j] >= max_left[i][j] || a[i][j] >= max_right[i][j] ||\n                        a[i][j] >= max_up[i][j] || a[i][j] >= max_down[i][j]) {\n                        valid_cols[j] = 0;\n                        break;\n                    }\n                }\n            }\n\n            // Count valid rectangles using the valid columns\n            int consecutive = 0;\n            for (int j = 1; j < m - 1; ++j) {\n                if (valid_cols[j]) {\n                    consecutive++;\n                    valid_rectangles += consecutive;\n                } else {\n                    consecutive = 0;\n                }\n            }\n        }\n    }\n\n    return valid_rectangles;\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 17:51:17",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/C",
    "title": "C. Rectangles",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "C",
    "submission_id": "314986847",
    "code_index": 2,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nint64_t count_rectangles(vector<vector<int>> a) {\n    int n = a.size();        // Number of rows\n    int m = a[0].size();     // Number of columns\n    int64_t valid_count = 0;\n\n    // Iterate over all possible rectangles defined by r1, r2, c1, c2\n    for (int r1 = 1; r1 <= n - 2; ++r1) {\n        for (int r2 = r1; r2 <= n - 2; ++r2) {\n            for (int c1 = 1; c1 <= m - 2; ++c1) {\n                for (int c2 = c1; c2 <= m - 2; ++c2) {\n                    // Check if the rectangle is valid\n                    bool valid = true;\n\n                    for (int i = r1; i <= r2; ++i) {\n                        for (int j = c1; j <= c2; ++j) {\n                            // Check the four adjacent cells\n                            if (!(a[i][j] < a[i][c1 - 1] &&\n                                  a[i][j] < a[i][c2 + 1] &&\n                                  a[i][j] < a[r1 - 1][j] &&\n                                  a[i][j] < a[r2 + 1][j])) {\n                                valid = false;\n                                break;\n                            }\n                        }\n                        if (!valid) break;\n                    }\n\n                    if (valid) {\n                        ++valid_count;\n                    }\n                }\n            }\n        }\n    }\n\n    return valid_count;\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 17:51:59",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/C",
    "title": "C. Rectangles",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "C",
    "submission_id": "314986918",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint64_t count_rectangles(vector<vector<int>> a) {\n    int n = a.size();\n    int m = a[0].size();\n\n    // Boundary checks for valid rows and columns\n    if (n < 3 || m < 3) return 0;\n\n    // Create a 2D array to mark valid cells\n    vector<vector<bool>> is_valid(n, vector<bool>(m, false));\n\n    // Mark valid cells\n    for (int i = 1; i < n - 1; ++i) {\n        for (int j = 1; j < m - 1; ++j) {\n            if (a[i][j] < a[i - 1][j] && a[i][j] < a[i + 1][j] &&\n                a[i][j] < a[i][j - 1] && a[i][j] < a[i][j + 1]) {\n                is_valid[i][j] = true;\n            }\n        }\n    }\n\n    // Count valid rectangles\n    int64_t total_rectangles = 0;\n\n    // For each pair of rows r1 and r2\n    for (int r1 = 1; r1 < n - 1; ++r1) {\n        vector<int> continuous_valid(m, 0); // Count valid cells in the current row range\n        for (int r2 = r1; r2 < n - 1; ++r2) {\n            for (int col = 1; col < m - 1; ++col) {\n                if (is_valid[r2][col]) {\n                    continuous_valid[col]++;\n                } else {\n                    continuous_valid[col] = 0; // Reset if not valid\n                }\n            }\n\n            // Count rectangles in the current row range [r1, r2]\n            int consecutive = 0;\n            for (int col = 1; col < m - 1; ++col) {\n                if (continuous_valid[col] == (r2 - r1 + 1)) {\n                    ++consecutive;\n                } else {\n                    total_rectangles += (int64_t)consecutive * (consecutive + 1) / 2;\n                    consecutive = 0;\n                }\n            }\n            total_rectangles += (int64_t)consecutive * (consecutive + 1) / 2;\n        }\n    }\n\n    return total_rectangles;\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 17:52:38",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/C",
    "title": "C. Rectangles",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "C",
    "submission_id": "314986987",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint64_t count_rectangles(vector<vector<int>> a) {\n    int64_t count = 0;\n    int n = a.size();\n    int m = a[0].size();\n\n    // Precompute the max heights for adjacent columns\n    vector<vector<int>> left(n, vector<int>(m, 0));\n    vector<vector<int>> right(n, vector<int>(m, 0));\n    for (int i = 0; i < n; ++i) {\n        left[i][0] = a[i][0];\n        for (int j = 1; j < m; ++j) {\n            left[i][j] = max(left[i][j - 1], a[i][j]);\n        }\n        right[i][m - 1] = a[i][m - 1];\n        for (int j = m - 2; j >= 0; --j) {\n            right[i][j] = max(right[i][j + 1], a[i][j]);\n        }\n    }\n\n    // Precompute the max heights for adjacent rows\n    vector<vector<int>> up(n, vector<int>(m, 0));\n    vector<vector<int>> down(n, vector<int>(m, 0));\n    for (int j = 0; j < m; ++j) {\n        up[0][j] = a[0][j];\n        for (int i = 1; i < n; ++i) {\n            up[i][j] = max(up[i - 1][j], a[i][j]);\n        }\n        down[n - 1][j] = a[n - 1][j];\n        for (int i = n - 2; i >= 0; --i) {\n            down[i][j] = max(down[i + 1][j], a[i][j]);\n        }\n    }\n\n    // Iterate over all possible rectangles\n    for (int r1 = 1; r1 < n - 1; ++r1) {\n        for (int r2 = r1; r2 < n - 1; ++r2) {\n            vector<int> valid_start(m, 1); // Tracks valid columns for the current rectangle\n            for (int c = 1; c < m - 1; ++c) {\n                for (int i = r1; i <= r2; ++i) {\n                    if (a[i][c] >= left[i][c - 1] || a[i][c] >= right[i][c + 1] ||\n                        a[i][c] >= up[r1 - 1][c] || a[i][c] >= down[r2 + 1][c]) {\n                        valid_start[c] = 0;\n                        break;\n                    }\n                }\n            }\n\n            // Count valid rectangles for the current row range\n            int c1 = 1;\n            while (c1 < m - 1) {\n                if (valid_start[c1]) {\n                    int c2 = c1;\n                    while (c2 < m - 1 && valid_start[c2]) {\n                        ++c2;\n                    }\n                    int width = c2 - c1;\n                    count += width;\n                    c1 = c2; // Move to the next invalid column\n                } else {\n                    ++c1;\n                }\n            }\n        }\n    }\n\n    return count;\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 17:53:39",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/E",
    "title": "E. Sorting",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "E",
    "submission_id": "314987088",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\n\n// Your code will be placed here\nint findSwapPairs(int N, int S[], int M, int X[], int Y[], int P[], int Q[]) {\n    // Convert S[] into a vector for easier manipulation\n    std::vector<int> sequence(S, S + N);\n    std::vector<int> sorted_sequence = sequence;\n    std::sort(sorted_sequence.begin(), sorted_sequence.end()); // Target sorted sequence\n\n    int rounds = 0; // Count of swaps Aizhan makes\n\n    for (int i = 0; i < M; i++) {\n        // Ermek's swap\n        std::swap(sequence[X[i]], sequence[Y[i]]);\n\n        // Check if the sequence is already sorted\n        if (sequence == sorted_sequence) {\n            // Aizhan can swap two identical indices to terminate\n            P[rounds] = 0;\n            Q[rounds] = 0;\n            rounds++;\n            break;\n        }\n\n        // Aizhan's turn: Find a swap to bring the sequence closer to being sorted\n        for (int j = 0; j < N; j++) {\n            if (sequence[j] != sorted_sequence[j]) {\n                // Find the correct position for sequence[j]\n                int target_index = std::find(sequence.begin(), sequence.end(), sorted_sequence[j]) - sequence.begin();\n\n                // Perform the swap\n                std::swap(sequence[j], sequence[target_index]);\n\n                // Record the swap\n                P[rounds] = j;\n                Q[rounds] = target_index;\n                rounds++;\n                break;\n            }\n        }\n\n        // Check again if the sequence is sorted after Aizhan's swap\n        if (sequence == sorted_sequence) {\n            break;\n        }\n    }\n\n    return rounds;\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 17:54:21",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/E",
    "title": "E. Sorting",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "E",
    "submission_id": "314987159",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint findSwapPairs(int N, int S[], int M, int X[], int Y[], int P[], int Q[]) {\n    // Copy the input array S to work on it\n    vector<int> sequence(S, S + N);\n    vector<pair<int, int>> swaps; // To store Aizhan's swaps\n\n    // Create a sorted version of the sequence to compare against\n    vector<int> sortedSequence = sequence;\n    sort(sortedSequence.begin(), sortedSequence.end());\n\n    // A helper function to perform a swap on the sequence\n    auto performSwap = [&](int i, int j) {\n        if (i != j) {\n            swap(sequence[i], sequence[j]);\n        }\n    };\n\n    // Process each round\n    for (int i = 0; i < M; ++i) {\n        // Ermek's swap\n        performSwap(X[i], Y[i]);\n\n        // Check if the array is already sorted\n        if (sequence == sortedSequence) {\n            // If sorted, we can stop and fill in dummy swaps for remaining rounds\n            for (int j = swaps.size(); j < M; ++j) {\n                swaps.emplace_back(0, 0); // Dummy swaps\n            }\n            break;\n        }\n\n        // Aizhan's turn: Find a swap to help sort the sequence\n        // Use a greedy approach to put elements in their correct position\n        for (int j = 0; j < N; ++j) {\n            if (sequence[j] != sortedSequence[j]) {\n                // Element at position j is not in its correct position\n                // Find where the correct element for position j is located\n                int targetIndex = find(sequence.begin(), sequence.end(), sortedSequence[j]) - sequence.begin();\n                // Perform the swap\n                performSwap(j, targetIndex);\n                swaps.emplace_back(j, targetIndex);\n                break;\n            }\n        }\n    }\n\n    // Copy the swaps into P and Q\n    for (int i = 0; i < swaps.size(); ++i) {\n        P[i] = swaps[i].first;\n        Q[i] = swaps[i].second;\n    }\n\n    // Return the number of swaps performed by Aizhan\n    return swaps.size();\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 17:54:58",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/E",
    "title": "E. Sorting",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "E",
    "submission_id": "314987228",
    "code_index": 2,
    "code": "#include <vector>\n#include <algorithm>\n\n// Your code will be placed here\nint findSwapPairs(int N, int S[], int M, int X[], int Y[], int P[], int Q[]) {\n    // Create a vector from the array S for easier manipulation\n    std::vector<int> sequence(S, S + N);\n\n    // Prepare the target sorted sequence\n    std::vector<int> sorted_sequence = sequence;\n    std::sort(sorted_sequence.begin(), sorted_sequence.end());\n\n    // Track the swaps Aizhan makes\n    int rounds = 0;\n\n    // Keep track of the current sequence and perform swaps\n    for (int i = 0; i < M; ++i) {\n        // Ermek's swap\n        std::swap(sequence[X[i]], sequence[Y[i]]);\n\n        // Check if the sequence is already sorted\n        if (sequence == sorted_sequence) {\n            return rounds; // Return the number of swaps Aizhan made\n        }\n\n        // Aizhan's turn to make a swap\n        // Find the first pair of indices to swap that moves the sequence closer to sorted\n        for (int j = 0; j < N; ++j) {\n            if (sequence[j] != sorted_sequence[j]) {\n                // Find the index in the current sequence where the correct element for position j is located\n                auto it = std::find(sequence.begin(), sequence.end(), sorted_sequence[j]);\n                int idx = it - sequence.begin();\n\n                // Aizhan swaps the incorrect element into its correct position\n                std::swap(sequence[j], sequence[idx]);\n\n                // Record the swap in P and Q\n                P[rounds] = j;\n                Q[rounds] = idx;\n\n                ++rounds; // Increment the number of rounds\n                break; // Move to the next round\n            }\n        }\n\n        // Check if the sequence is sorted after Aizhan's swap\n        if (sequence == sorted_sequence) {\n            return rounds; // Return the number of swaps Aizhan made\n        }\n    }\n\n    return rounds; // Return the total number of swaps Aizhan made\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 17:55:40",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/E",
    "title": "E. Sorting",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "E",
    "submission_id": "314987305",
    "code_index": 3,
    "code": "#include <vector>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\n\n// Your code will be placed here\nint findSwapPairs(int N, int S[], int M, int X[], int Y[], int P[], int Q[]) {\n    // Step 1: Convert S to a vector and create a sorted version\n    vector<int> sequence(S, S + N);\n    vector<int> sorted_sequence = sequence;\n    sort(sorted_sequence.begin(), sorted_sequence.end());\n\n    // Step 2: Create a map to track the current positions of elements\n    unordered_map<int, int> position;\n    for (int i = 0; i < N; ++i) {\n        position[sequence[i]] = i;\n    }\n\n    int rounds = 0; // Count of Aizhan's swaps\n    for (int i = 0; i < M; ++i) {\n        // Step 3: Simulate Ermek's swap\n        int ermek_x = X[i];\n        int ermek_y = Y[i];\n        swap(sequence[ermek_x], sequence[ermek_y]);\n        position[sequence[ermek_x]] = ermek_x;\n        position[sequence[ermek_y]] = ermek_y;\n\n        // Step 4: Check if the sequence is already sorted\n        bool sorted = true;\n        for (int j = 0; j < N - 1; ++j) {\n            if (sequence[j] > sequence[j + 1]) {\n                sorted = false;\n                break;\n            }\n        }\n        if (sorted) break;\n\n        // Step 5: Determine Aizhan's optimal swap\n        for (int j = 0; j < N; ++j) {\n            int target_value = sorted_sequence[j];\n            int current_value = sequence[j];\n\n            if (current_value != target_value) {\n                int target_position = position[target_value];\n                // Perform the swap\n                swap(sequence[j], sequence[target_position]);\n                position[current_value] = target_position;\n                position[target_value] = j;\n\n                // Record the swap\n                P[rounds] = j;\n                Q[rounds] = target_position;\n                ++rounds;\n\n                break; // One swap per round\n            }\n        }\n    }\n\n    return rounds;\n}"
  },
  {
    "date": "IOI 2015 day 2",
    "timestamp": "2025-04-11 17:56:20",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103770/problem/E",
    "title": "E. Sorting",
    "group_id": "32KGsXgiKA",
    "contest_id": "103770",
    "problem_index": "E",
    "submission_id": "314987404",
    "code_index": 4,
    "code": "#include <vector>\n#include <algorithm>\n\n// Your code will be placed here\nint findSwapPairs(int N, int S[], int M, int X[], int Y[], int P[], int Q[]) {\n    // Convert S to a vector for easier manipulation\n    std::vector<int> sequence(S, S + N);\n\n    // Create a sorted version of the sequence for reference\n    std::vector<int> sorted_sequence = sequence;\n    std::sort(sorted_sequence.begin(), sorted_sequence.end());\n\n    // Track the swaps performed by Aizhan\n    int R = 0;\n\n    for (int i = 0; i < M; ++i) {\n        // Perform Ermek's swap\n        std::swap(sequence[X[i]], sequence[Y[i]]);\n\n        // Check if the sequence is sorted\n        if (sequence == sorted_sequence) {\n            // If sorted, Aizhan can perform a \"dummy\" swap\n            P[R] = 0;\n            Q[R] = 0;\n            ++R;\n            break;\n        }\n\n        // Find the first misplaced element and its correct position\n        int misplaced_index = -1;\n        for (int j = 0; j < N; ++j) {\n            if (sequence[j] != sorted_sequence[j]) {\n                misplaced_index = j;\n                break;\n            }\n        }\n\n        // If everything is sorted, stop\n        if (misplaced_index == -1) break;\n\n        // Find the correct position of the misplaced element\n        int correct_value = sorted_sequence[misplaced_index];\n        int correct_index = -1;\n        for (int j = 0; j < N; ++j) {\n            if (sequence[j] == correct_value) {\n                correct_index = j;\n                break;\n            }\n        }\n\n        // Perform Aizhan's swap\n        P[R] = misplaced_index;\n        Q[R] = correct_index;\n        ++R;\n        std::swap(sequence[misplaced_index], sequence[correct_index]);\n    }\n\n    return R;\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 17:57:06",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/A",
    "title": "A. Dreaming",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "A",
    "submission_id": "314987483",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <limits>\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\n// Function to find the diameter of a connected component\nint bfsDiameter(const vector<vector<pair<int, int>>> &graph, int start) {\n    int n = graph.size();\n    vector<int> dist(n, INF);\n    queue<int> q;\n\n    dist[start] = 0;\n    q.push(start);\n\n    int farthestNode = start;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (const auto &edge : graph[u]) {\n            int v = edge.first, w = edge.second;\n            if (dist[v] == INF) {\n                dist[v] = dist[u] + w;\n                q.push(v);\n                if (dist[v] > dist[farthestNode]) {\n                    farthestNode = v;\n                }\n            }\n        }\n    }\n\n    // Second BFS to find the diameter\n    dist.assign(n, INF);\n    dist[farthestNode] = 0;\n    q.push(farthestNode);\n\n    int diameter = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (const auto &edge : graph[u]) {\n            int v = edge.first, w = edge.second;\n            if (dist[v] == INF) {\n                dist[v] = dist[u] + w;\n                q.push(v);\n                diameter = max(diameter, dist[v]);\n            }\n        }\n    }\n\n    return diameter;\n}\n\nint travelTime(int N, int M, int L, vector<int> A, vector<int> B, vector<int> T) {\n    // Step 1: Build the graph\n    vector<vector<pair<int, int>>> graph(N);\n    for (int i = 0; i < M; ++i) {\n        graph[A[i]].emplace_back(B[i], T[i]);\n        graph[B[i]].emplace_back(A[i], T[i]);\n    }\n\n    // Step 2: Find connected components and their diameters\n    vector<bool> visited(N, false);\n    vector<int> componentDiameters;\n    vector<int> componentFarthestDistances;\n\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            // BFS to find diameter of the component\n            queue<int> q;\n            q.push(i);\n            visited[i] = true;\n\n            vector<int> componentNodes;\n            componentNodes.push_back(i);\n\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n\n                for (const auto &edge : graph[u]) {\n                    int v = edge.first;\n                    if (!visited[v]) {\n                        visited[v] = true;\n                        q.push(v);\n                        componentNodes.push_back(v);\n                    }\n                }\n            }\n\n            // Calculate diameter of the component\n            int diameter = bfsDiameter(graph, componentNodes[0]);\n            componentDiameters.push_back(diameter);\n        }\n    }\n\n    // Step 3: Combine components with new trails\n    int maxDiameter = 0;\n    for (int d : componentDiameters) {\n        maxDiameter = max(maxDiameter, d);\n    }\n\n    if (componentDiameters.size() > 1) {\n        sort(componentDiameters.rbegin(), componentDiameters.rend());\n        maxDiameter = max(maxDiameter, componentDiameters[0] + componentDiameters[1] + L);\n    }\n\n    return maxDiameter;\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 17:57:51",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/A",
    "title": "A. Dreaming",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "A",
    "submission_id": "314987571",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\n\n// Helper function to perform BFS and calculate distances\npair<int, int> bfs(int start, const vector<vector<pair<int, int>>>& graph) {\n    int n = graph.size();\n    vector<int> dist(n, INT_MAX);\n    queue<int> q;\n    dist[start] = 0;\n    q.push(start);\n\n    int farthest_node = start, max_distance = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (const auto& neighbor : graph[node]) {\n            int next_node = neighbor.first;\n            int weight = neighbor.second;\n\n            if (dist[next_node] == INT_MAX) {\n                dist[next_node] = dist[node] + weight;\n                q.push(next_node);\n\n                if (dist[next_node] > max_distance) {\n                    max_distance = dist[next_node];\n                    farthest_node = next_node;\n                }\n            }\n        }\n    }\n\n    return {farthest_node, max_distance};\n}\n\nint travelTime(int N, int M, int L, int A[], int B[], int T[]) {\n    // Build the graph from input\n    vector<vector<pair<int, int>>> graph(N);\n    for (int i = 0; i < M; ++i) {\n        graph[A[i]].emplace_back(B[i], T[i]);\n        graph[B[i]].emplace_back(A[i], T[i]);\n    }\n\n    // Find all connected components and their diameters\n    vector<bool> visited(N, false);\n    vector<int> component_diameters;\n    vector<int> farthest_distances;\n\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            // Perform BFS to find a node in the farthest point of the component\n            auto [farthest_node, _] = bfs(i, graph);\n\n            // Perform BFS again from the farthest node to find the diameter\n            auto [_, diameter] = bfs(farthest_node, graph);\n\n            // Mark all nodes in this component as visited\n            queue<int> q;\n            q.push(i);\n            visited[i] = true;\n\n            while (!q.empty()) {\n                int node = q.front();\n                q.pop();\n\n                for (const auto& neighbor : graph[node]) {\n                    int next_node = neighbor.first;\n                    if (!visited[next_node]) {\n                        visited[next_node] = true;\n                        q.push(next_node);\n                    }\n                }\n            }\n\n            // Store the diameter of this component\n            component_diameters.push_back(diameter);\n            farthest_distances.push_back(diameter / 2);\n        }\n    }\n\n    // Sort the farthest distances from all components\n    sort(farthest_distances.begin(), farthest_distances.end(), greater<int>());\n\n    // Calculate the final maximum travel time\n    int max_travel_time = 0;\n\n    if (farthest_distances.size() == 1) {\n        max_travel_time = component_diameters[0];\n    } else if (farthest_distances.size() == 2) {\n        max_travel_time = max(component_diameters[0], farthest_distances[0] + farthest_distances[1] + L);\n    } else {\n        max_travel_time = max({component_diameters[0], \n                               farthest_distances[0] + farthest_distances[1] + L, \n                               farthest_distances[1] + farthest_distances[2] + 2 * L});\n    }\n\n    return max_travel_time;\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 17:58:34",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/A",
    "title": "A. Dreaming",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "A",
    "submission_id": "314987571",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\n// Helper function to perform BFS and find the farthest node and its distance\npair<int, int> bfs(int start, const vector<vector<pair<int, int>>>& graph) {\n    int n = graph.size();\n    vector<int> distance(n, INT_MAX);\n    queue<int> q;\n\n    distance[start] = 0;\n    q.push(start);\n\n    int farthestNode = start;\n    int maxDistance = 0;\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        for (auto& edge : graph[current]) {\n            int neighbor = edge.first;\n            int weight = edge.second;\n\n            if (distance[neighbor] == INT_MAX) {\n                distance[neighbor] = distance[current] + weight;\n                q.push(neighbor);\n\n                if (distance[neighbor] > maxDistance) {\n                    maxDistance = distance[neighbor];\n                    farthestNode = neighbor;\n                }\n            }\n        }\n    }\n\n    return {farthestNode, maxDistance};\n}\n\n// Function to calculate the diameter of a connected component\nint calculateDiameter(const vector<vector<pair<int, int>>>& graph, int start) {\n    auto firstBFS = bfs(start, graph);\n    auto secondBFS = bfs(firstBFS.first, graph);\n    return secondBFS.second;\n}\n\nint travelTime(int N, int M, int L, vector<int> A, vector<int> B, vector<int> T) {\n    // Build the graph\n    vector<vector<pair<int, int>>> graph(N);\n    for (int i = 0; i < M; ++i) {\n        graph[A[i]].emplace_back(B[i], T[i]);\n        graph[B[i]].emplace_back(A[i], T[i]);\n    }\n\n    // Find connected components and their diameters\n    vector<bool> visited(N, false);\n    vector<int> componentDiameters;\n\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            // Perform BFS/DFS to find all nodes in this connected component\n            queue<int> q;\n            q.push(i);\n            visited[i] = true;\n\n            vector<int> componentNodes;\n            componentNodes.push_back(i);\n\n            while (!q.empty()) {\n                int current = q.front();\n                q.pop();\n\n                for (auto& edge : graph[current]) {\n                    int neighbor = edge.first;\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        q.push(neighbor);\n                        componentNodes.push_back(neighbor);\n                    }\n                }\n            }\n\n            // Calculate the diameter of this component\n            int diameter = calculateDiameter(graph, componentNodes[0]);\n            componentDiameters.push_back(diameter);\n        }\n    }\n\n    // Sort component diameters in descending order\n    sort(componentDiameters.begin(), componentDiameters.end(), greater<int>());\n\n    // If there is only one component, return its diameter\n    if (componentDiameters.size() == 1) {\n        return componentDiameters[0];\n    }\n\n    // Combine components using new trails\n    int maxTravelTime = componentDiameters[0];\n    int largestDiameter = componentDiameters[0];\n    int secondLargestDiameter = componentDiameters.size() > 1 ? componentDiameters[1] : 0;\n\n    // Combine the two largest diameters\n    maxTravelTime = max(maxTravelTime, largestDiameter + secondLargestDiameter + L);\n\n    // Combine all other components\n    for (size_t i = 2; i < componentDiameters.size(); ++i) {\n        maxTravelTime = max(maxTravelTime, componentDiameters[i] + L + L);\n    }\n\n    return maxTravelTime;\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 17:59:15",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/A",
    "title": "A. Dreaming",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "A",
    "submission_id": "314987722",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\nint travelTime(int N, int M, int L, int A[], int B[], int T[]) {\n    // Step 1: Represent the graph using adjacency list\n    vector<vector<pair<int, int>>> adj(N);\n    for (int i = 0; i < M; i++) {\n        adj[A[i]].emplace_back(B[i], T[i]);\n        adj[B[i]].emplace_back(A[i], T[i]);\n    }\n\n    // Step 2: Find connected components and their diameters\n    vector<bool> visited(N, false);\n    vector<int> componentDiameters;\n    vector<int> farthestPoints;\n\n    auto bfs = [&](int start) {\n        vector<int> dist(N, numeric_limits<int>::max());\n        queue<int> q;\n        q.push(start);\n        dist[start] = 0;\n        visited[start] = true;\n\n        int farthestNode = start;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            for (auto& [neighbor, weight] : adj[node]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    dist[neighbor] = dist[node] + weight;\n                    q.push(neighbor);\n                    if (dist[neighbor] > dist[farthestNode]) {\n                        farthestNode = neighbor;\n                    }\n                }\n            }\n        }\n        return make_pair(farthestNode, dist[farthestNode]);\n    };\n\n    for (int i = 0; i < N; i++) {\n        if (!visited[i]) {\n            // Find one end of the diameter\n            auto [farthestNode1, _] = bfs(i);\n\n            // Find the other end of the diameter\n            fill(visited.begin(), visited.end(), false);\n            auto [farthestNode2, diameter] = bfs(farthestNode1);\n\n            componentDiameters.push_back(diameter);\n            farthestPoints.push_back(farthestNode1);\n        }\n    }\n\n    // Step 3: Calculate the result by connecting components\n    int numComponents = componentDiameters.size();\n    if (numComponents == 1) {\n        return componentDiameters[0]; // If everything is already connected\n    }\n\n    sort(componentDiameters.begin(), componentDiameters.end(), greater<int>());\n\n    // If we connect the two largest components with a new trail of length L\n    int maxDiameter = max(componentDiameters[0], componentDiameters[1] + L);\n\n    // If there are more than two components, consider connecting the others\n    for (int i = 2; i < numComponents; i++) {\n        maxDiameter = max(maxDiameter, componentDiameters[i] + 2 * L);\n    }\n\n    return maxDiameter;\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 17:59:59",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/A",
    "title": "A. Dreaming",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "A",
    "submission_id": "314987799",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <limits>\nusing namespace std;\n\n// Helper function to perform BFS and calculate distances\npair<int, int> bfs(int start, const vector<vector<pair<int, int>>>& graph) {\n    int n = graph.size();\n    vector<int> dist(n, -1); // Distance array initialized to -1\n    queue<int> q;\n\n    dist[start] = 0;\n    q.push(start);\n\n    int farthest_node = start;\n    int max_distance = 0;\n\n    while (!q.empty()) {\n        int current = q.front();\n        q.pop();\n\n        for (const auto& neighbor : graph[current]) {\n            int next = neighbor.first;\n            int weight = neighbor.second;\n\n            if (dist[next] == -1) { // Not visited\n                dist[next] = dist[current] + weight;\n                q.push(next);\n\n                if (dist[next] > max_distance) {\n                    max_distance = dist[next];\n                    farthest_node = next;\n                }\n            }\n        }\n    }\n\n    return {farthest_node, max_distance};\n}\n\n// Function to calculate the diameter of a connected component\nint calculateDiameter(const vector<vector<pair<int, int>>>& graph, int start) {\n    auto [farthest_node, _] = bfs(start, graph); // First BFS to find one endpoint of the diameter\n    auto [_, diameter] = bfs(farthest_node, graph); // Second BFS to find the diameter\n    return diameter;\n}\n\nint travelTime(int N, int M, int L, int A[], int B[], int T[]) {\n    // Step 1: Build the adjacency list for the graph\n    vector<vector<pair<int, int>>> graph(N);\n    for (int i = 0; i < M; ++i) {\n        graph[A[i]].emplace_back(B[i], T[i]);\n        graph[B[i]].emplace_back(A[i], T[i]);\n    }\n\n    // Step 2: Find all connected components and their diameters\n    vector<bool> visited(N, false);\n    vector<int> component_diameters;\n    vector<int> farthest_distances;\n\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            // Perform BFS to find all nodes in the same connected component\n            vector<int> component_nodes;\n            queue<int> q;\n            q.push(i);\n            visited[i] = true;\n\n            while (!q.empty()) {\n                int current = q.front();\n                q.pop();\n                component_nodes.push_back(current);\n\n                for (const auto& neighbor : graph[current]) {\n                    int next = neighbor.first;\n                    if (!visited[next]) {\n                        visited[next] = true;\n                        q.push(next);\n                    }\n                }\n            }\n\n            // Calculate the diameter of the current connected component\n            int component_diameter = calculateDiameter(graph, component_nodes[0]);\n            component_diameters.push_back(component_diameter);\n\n            // Find the farthest distance within this component\n            auto [_, farthest_distance] = bfs(component_nodes[0], graph);\n            farthest_distances.push_back(farthest_distance);\n        }\n    }\n\n    // Step 3: Sort the farthest distances in descending order\n    sort(farthest_distances.rbegin(), farthest_distances.rend());\n\n    // Step 4: Calculate the maximum travel time after adding new trails\n    int max_travel_time = 0;\n    if (farthest_distances.size() == 1) {\n        max_travel_time = farthest_distances[0]; // Only one component\n    } else if (farthest_distances.size() == 2) {\n        max_travel_time = max(farthest_distances[0] + L + farthest_distances[1], farthest_distances[0]);\n    } else {\n        max_travel_time = max({\n            farthest_distances[0],\n            farthest_distances[1] + L + farthest_distances[2]\n        });\n    }\n\n    return max_travel_time;\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 18:01:13",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/H",
    "title": "H. Saveit",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "H",
    "submission_id": "314987924",
    "code_index": 0,
    "code": "#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n\nusing namespace std;\n\n// Function signatures for encoding and decoding\nvoid encode(int N, int H, int P, vector<int> A, vector<int> B);\nvoid decode(int N, int H);\n\n// Functions provided by the grader\nvoid encode_bit(int b);\nint decode_bit();\nvoid hops(int h, int c, int d);\n\n// Helper function to perform BFS and calculate shortest distances\nvector<int> bfs(int start, const vector<vector<int>>& adj, int N) {\n    vector<int> dist(N, -1);\n    queue<int> q;\n    dist[start] = 0;\n    q.push(start);\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : adj[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return dist;\n}\n\n// Function to encode a single integer as a sequence of bits\nvoid encode_integer(int x, int max_bits) {\n    for (int i = 0; i < max_bits; i++) {\n        encode_bit((x >> i) & 1);\n    }\n}\n\n// Function to decode a single integer from a sequence of bits\nint decode_integer(int max_bits) {\n    int x = 0;\n    for (int i = 0; i < max_bits; i++) {\n        x |= (decode_bit() << i);\n    }\n    return x;\n}\n\nvoid encode(int N, int H, int P, vector<int> A, vector<int> B) {\n    // Create adjacency list for the graph\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < P; i++) {\n        adj[A[i]].push_back(B[i]);\n        adj[B[i]].push_back(A[i]);\n    }\n\n    // Calculate shortest paths from each hub using BFS\n    vector<vector<int>> distances(H);\n    int max_distance = 0;\n    for (int h = 0; h < H; h++) {\n        distances[h] = bfs(h, adj, N);\n        for (int d : distances[h]) {\n            max_distance = max(max_distance, d);\n        }\n    }\n\n    // Determine the number of bits needed to encode the maximum distance\n    int max_bits = ceil(log2(max_distance + 1));\n\n    // Encode the number of bits needed\n    encode_integer(max_bits, 6); // 6 bits to encode max_bits (since max_bits <= 36)\n\n    // Encode all distances\n    for (int h = 0; h < H; h++) {\n        for (int c = 0; c < N; c++) {\n            encode_integer(distances[h][c], max_bits);\n        }\n    }\n}\n\nvoid decode(int N, int H) {\n    // Decode the number of bits used for encoding distances\n    int max_bits = decode_integer(6);\n\n    // Decode all distances\n    for (int h = 0; h < H; h++) {\n        for (int c = 0; c < N; c++) {\n            int d = decode_integer(max_bits);\n            hops(h, c, d);\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 18:01:57",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/H",
    "title": "H. Saveit",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "H",
    "submission_id": "314988004",
    "code_index": 1,
    "code": "#include <vector>\n#include <queue>\n#include <bitset>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\n// Function signatures for provided functions\nvoid encode_bit(int b);\nint decode_bit();\nvoid hops(int h, int c, int d);\n\n// Your code will be placed here\n// -----------------------------\n// Your code will be placed here\n// -----------------------------\n\n// Encode function\nvoid encode(int N, int H, int P, vector<int> A, vector<int> B) {\n    // Create adjacency list\n    vector<vector<int>> graph(N);\n    for (int i = 0; i < P; i++) {\n        graph[A[i]].push_back(B[i]);\n        graph[B[i]].push_back(A[i]);\n    }\n\n    // Compute shortest distances using BFS from each hub\n    vector<vector<int>> distances(H, vector<int>(N, -1));\n    for (int hub = 0; hub < H; hub++) {\n        queue<int> q;\n        q.push(hub);\n        distances[hub][hub] = 0;\n\n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n\n            for (int neighbor : graph[current]) {\n                if (distances[hub][neighbor] == -1) {\n                    distances[hub][neighbor] = distances[hub][current] + 1;\n                    q.push(neighbor);\n                }\n            }\n        }\n    }\n\n    // Encode distances into bits\n    for (int hub = 0; hub < H; hub++) {\n        for (int city = 0; city < N; city++) {\n            int d = distances[hub][city];\n            for (int bit = 0; bit < 10; bit++) { // Encode up to 10 bits per distance\n                encode_bit((d >> bit) & 1);\n            }\n        }\n    }\n}\n\n// Decode function\nvoid decode(int N, int H) {\n    // Decode distances from bits\n    vector<vector<int>> distances(H, vector<int>(N));\n    for (int hub = 0; hub < H; hub++) {\n        for (int city = 0; city < N; city++) {\n            int d = 0;\n            for (int bit = 0; bit < 10; bit++) { // Decode up to 10 bits per distance\n                d |= (decode_bit() << bit);\n            }\n            distances[hub][city] = d;\n        }\n    }\n\n    // Call hops(h, c, d) for each hub-city pair\n    for (int hub = 0; hub < H; hub++) {\n        for (int city = 0; city < N; city++) {\n            hops(hub, city, distances[hub][city]);\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 18:02:38",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/H",
    "title": "H. Saveit",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "H",
    "submission_id": "314988076",
    "code_index": 2,
    "code": "#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\n// Function prototypes for grader-provided functions\nvoid encode_bit(int b);\nint decode_bit();\nvoid hops(int h, int c, int d);\n\n// Your code will be placed here\n// Your code will be placed here\n\nvoid encode(int N, int H, int P, vector<int> A, vector<int> B) {\n    // Adjacency list for the graph\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < P; i++) {\n        adj[A[i]].push_back(B[i]);\n        adj[B[i]].push_back(A[i]);\n    }\n\n    // Compute shortest distances from each hub\n    vector<vector<int>> dist(H, vector<int>(N, INT_MAX));\n    for (int h = 0; h < H; h++) {\n        queue<int> q;\n        q.push(h);\n        dist[h][h] = 0;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            for (int neighbor : adj[node]) {\n                if (dist[h][neighbor] == INT_MAX) {\n                    dist[h][neighbor] = dist[h][node] + 1;\n                    q.push(neighbor);\n                }\n            }\n        }\n    }\n\n    // Find the maximum distance to determine the number of bits needed\n    int maxDist = 0;\n    for (int h = 0; h < H; h++) {\n        for (int c = 0; c < N; c++) {\n            maxDist = max(maxDist, dist[h][c]);\n        }\n    }\n\n    // Calculate the number of bits needed to encode each distance\n    int bitsPerDistance = ceil(log2(maxDist + 1));\n\n    // Encode the distances\n    for (int h = 0; h < H; h++) {\n        for (int c = 0; c < N; c++) {\n            int d = dist[h][c];\n            for (int i = bitsPerDistance - 1; i >= 0; i--) {\n                encode_bit((d >> i) & 1);\n            }\n        }\n    }\n}\n\nvoid decode(int N, int H) {\n    // Find the maximum distance to determine the number of bits per distance\n    int bitsPerDistance = 0;\n    int maxDist = 0;\n\n    // Decode the distances\n    vector<vector<int>> dist(H, vector<int>(N, 0));\n    for (int h = 0; h < H; h++) {\n        for (int c = 0; c < N; c++) {\n            int d = 0;\n            for (int i = 0; i < bitsPerDistance; i++) {\n                d = (d << 1) | decode_bit();\n            }\n            dist[h][c] = d;\n        }\n    }\n\n    // Output the results\n    for (int h = 0; h < H; h++) {\n        for (int c = 0; c < N; c++) {\n            hops(h, c, dist[h][c]);\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 18:03:20",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/H",
    "title": "H. Saveit",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "H",
    "submission_id": "314988146",
    "code_index": 3,
    "code": "#include <vector>\n#include <queue>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\n// Functions provided by the grader\nvoid encode_bit(int b);\nint decode_bit();\nvoid hops(int h, int c, int d);\n\n// Your code will be placed here\nvoid encode(int N, int H, int P, vector<int> A, vector<int> B) {\n    // Step 1: Build adjacency list\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < P; i++) {\n        adj[A[i]].push_back(B[i]);\n        adj[B[i]].push_back(A[i]);\n    }\n\n    // Step 2: Compute shortest paths from hubs to all cities\n    vector<vector<int>> distances(H, vector<int>(N, -1));\n    for (int hub = 0; hub < H; hub++) {\n        queue<int> q;\n        q.push(hub);\n        distances[hub][hub] = 0;\n\n        while (!q.empty()) {\n            int city = q.front();\n            q.pop();\n\n            for (int neighbor : adj[city]) {\n                if (distances[hub][neighbor] == -1) {\n                    distances[hub][neighbor] = distances[hub][city] + 1;\n                    q.push(neighbor);\n                }\n            }\n        }\n    }\n\n    // Step 3: Encode distances\n    for (int hub = 0; hub < H; hub++) {\n        for (int city = 0; city < N; city++) {\n            int d = distances[hub][city];\n            for (int i = 0; i < 8; i++) { // 8 bits for distance\n                encode_bit((d >> i) & 1);\n            }\n        }\n    }\n}\n\nvoid decode(int N, int H) {\n    // Step 1: Decode distances\n    vector<vector<int>> distances(H, vector<int>(N));\n    for (int hub = 0; hub < H; hub++) {\n        for (int city = 0; city < N; city++) {\n            int d = 0;\n            for (int i = 0; i < 8; i++) {\n                d |= (decode_bit() << i);\n            }\n            distances[hub][city] = d;\n        }\n    }\n\n    // Step 2: Call hops for each hub and city\n    for (int hub = 0; hub < H; hub++) {\n        for (int city = 0; city < N; city++) {\n            hops(hub, city, distances[hub][city]);\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 18:04:02",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/H",
    "title": "H. Saveit",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "H",
    "submission_id": "314988216",
    "code_index": 4,
    "code": "#include <vector>\n#include <queue>\n#include <bitset>\n#include <cassert>\n\nusing namespace std;\n\n// Function prototypes provided by the grader\nvoid encode_bit(int b);\nint decode_bit();\nvoid hops(int h, int c, int d);\n\nvoid encode(int N, int H, int P, vector<int> A, vector<int> B) {\n    // Represent the graph as an adjacency list\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < P; ++i) {\n        adj[A[i]].push_back(B[i]);\n        adj[B[i]].push_back(A[i]);\n    }\n\n    // Precompute shortest distances from each hub using BFS\n    vector<vector<int>> distances(H, vector<int>(N, -1)); // Distance from each hub to every city\n    for (int hub = 0; hub < H; ++hub) {\n        queue<int> q;\n        q.push(hub);\n        distances[hub][hub] = 0;\n\n        while (!q.empty()) {\n            int city = q.front();\n            q.pop();\n            for (int neighbor : adj[city]) {\n                if (distances[hub][neighbor] == -1) {\n                    distances[hub][neighbor] = distances[hub][city] + 1;\n                    q.push(neighbor);\n                }\n            }\n        }\n    }\n\n    // Encode distances into bits\n    for (int hub = 0; hub < H; ++hub) {\n        for (int city = 0; city < N; ++city) {\n            int d = distances[hub][city];\n            while (d > 0) {\n                encode_bit(d & 1); // Encode the least significant bit\n                d >>= 1;          // Shift right to process the next bit\n            }\n            encode_bit(0); // Separator bit to mark the end of encoding for this distance\n        }\n    }\n}\n\nvoid decode(int N, int H) {\n    // Decode the distances from the encoded bits\n    for (int hub = 0; hub < H; ++hub) {\n        for (int city = 0; city < N; ++city) {\n            int d = 0, shift = 0;\n            while (true) {\n                int bit = decode_bit();\n                if (bit == 0) break; // Separator bit\n                d |= (bit << shift); // Add the bit to the distance\n                ++shift;\n            }\n            hops(hub, city, d); // Call the hops function with the decoded distance\n        }\n    }\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 18:04:51",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/F",
    "title": "F. Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "F",
    "submission_id": "314988315",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <unordered_map>\n#include <vector>\n#include <numeric> // For std::gcd\n#include <utility> // For std::pair\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> Cell;\n\nunordered_map<Cell, ll, hash<Cell>> grid; // Sparse representation of the grid\nint R, C; // Dimensions of the grid\n\nvoid init(int R, int C) {\n    // Initialize the grid dimensions\n    ::R = R;\n    ::C = C;\n    grid.clear(); // Clear the sparse grid\n}\n\nvoid update(int P, int Q, ll K) {\n    // Update the cell (P, Q) with the value K\n    if (K == 0) {\n        grid.erase({P, Q}); // Remove the cell if K is zero\n    } else {\n        grid[{P, Q}] = K; // Set the value of the cell\n    }\n}\n\nll calculate(int P, int Q, int U, int V) {\n    // Calculate the GCD of all numbers in the rectangle (P, Q) to (U, V)\n    ll result = 0;\n    for (const auto& entry : grid) {\n        int row = entry.first.first;\n        int col = entry.first.second;\n        ll value = entry.second;\n\n        // Check if the cell is within the rectangle\n        if (P <= row && row <= U && Q <= col && col <= V) {\n            result = gcd(result, value);\n            if (result == 1) {\n                // Early termination: GCD of 1 cannot be reduced further\n                break;\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 18:05:34",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/F",
    "title": "F. Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "F",
    "submission_id": "314988394",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n// Hashmap to store non-zero cell values\n// Key: (row, column) as a single 64-bit integer, Value: cell value\nunordered_map<long long, long long> grid;\n\n// Dimensions of the grid\nint R, C;\n\n// Helper function to encode (row, column) into a single integer key\ninline long long encode(int row, int col) {\n    return (static_cast<long long>(row) << 32) | col;\n}\n\n// Initializes the grid dimensions\nvoid init(int r, int c) {\n    R = r;\n    C = c;\n    grid.clear(); // Clear any previous data\n}\n\n// Updates the value of cell (P, Q) to K\nvoid update(int P, int Q, long long K) {\n    long long key = encode(P, Q);\n    if (K == 0) {\n        // Remove the cell from the map if the value is set to 0\n        grid.erase(key);\n    } else {\n        // Update the value in the map\n        grid[key] = K;\n    }\n}\n\n// Calculates the GCD of all values in the rectangle (P, Q) to (U, V)\nlong long calculate(int P, int Q, int U, int V) {\n    long long result = 0; // Start with GCD as 0\n    for (auto& entry : grid) {\n        long long key = entry.first;\n        long long value = entry.second;\n\n        // Decode the key back into (row, column)\n        int row = key >> 32;\n        int col = key & 0xFFFFFFFF;\n\n        // Check if the cell is within the rectangle\n        if (row >= P && row <= U && col >= Q && col <= V) {\n            result = gcd(result, value);\n            if (result == 1) {\n                // Early exit: GCD of 1 cannot be improved further\n                return 1;\n            }\n        }\n    }\n    return result;\n}\n\n// Helper function to compute GCD of two numbers\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 18:06:24",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/F",
    "title": "F. Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "F",
    "submission_id": "314988488",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <bits/stdc++.h>\nusing namespace std;\n\nmap<pair<int, int>, long long> grid; // Sparse representation of the grid\nint R, C; // Dimensions of the grid\n\n// Function to compute the GCD of two numbers\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Initialize the grid dimensions\nvoid init(int r, int c) {\n    R = r;\n    C = c;\n    grid.clear(); // Clear any previous data\n}\n\n// Update the value at cell (P, Q) to K\nvoid update(int P, int Q, long long K) {\n    if (K == 0) {\n        // If the new value is zero, remove the cell from the map\n        grid.erase({P, Q});\n    } else {\n        // Otherwise, set the value in the sparse grid\n        grid[{P, Q}] = K;\n    }\n}\n\n// Calculate the GCD of all integers in the rectangular block\nlong long calculate(int P, int Q, int U, int V) {\n    long long result = 0;\n\n    // Iterate over all non-zero cells in the grid\n    for (const auto& cell : grid) {\n        int row = cell.first.first;\n        int col = cell.first.second;\n        long long value = cell.second;\n\n        // Check if the cell lies within the rectangle\n        if (row >= P && row <= U && col >= Q && col <= V) {\n            result = gcd(result, value);\n            // If GCD becomes 1, we can stop early\n            if (result == 1) {\n                break;\n            }\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 18:07:05",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/F",
    "title": "F. Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "F",
    "submission_id": "314988545",
    "code_index": 3,
    "code": "#include <vector>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n// Global variables\nunordered_map<long long, long long> grid; // Sparse representation of the grid\nint R, C; // Dimensions of the grid\n\n// Helper function to compute GCD\nlong long computeGCD(long long a, long long b) {\n    while (b) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Helper function to encode 2D coordinates into a single key for the hash map\nlong long encode(int P, int Q) {\n    return (static_cast<long long>(P) << 32) | Q;\n}\n\n// Initialize the grid dimensions\nvoid init(int rows, int cols) {\n    R = rows;\n    C = cols;\n    grid.clear();\n}\n\n// Update the value at cell (P, Q)\nvoid update(int P, int Q, long long K) {\n    long long key = encode(P, Q);\n    if (K == 0) {\n        grid.erase(key); // Remove the cell if updated to zero\n    } else {\n        grid[key] = K; // Update the cell with the new value\n    }\n}\n\n// Calculate the GCD of all values in the rectangle with corners (P, Q) and (U, V)\nlong long calculate(int P, int Q, int U, int V) {\n    long long result = 0;\n    for (const auto& [key, value] : grid) {\n        // Decode the key to get the row and column\n        int row = key >> 32;\n        int col = key & 0xFFFFFFFF;\n        // Check if the cell is within the rectangle\n        if (row >= P && row <= U && col >= Q && col <= V) {\n            if (result == 0) {\n                result = value; // Initialize result with the first value\n            } else {\n                result = computeGCD(result, value); // Compute GCD incrementally\n            }\n        }\n    }\n    return result;\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 18:07:49",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/F",
    "title": "F. Game",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "F",
    "submission_id": "314988629",
    "code_index": 4,
    "code": "#include <vector>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n\nusing namespace std;\n\n// Sparse representation of the grid\nmap<pair<int, int>, long long> grid;\n\n// Initialize dimensions of the grid (R x C)\nvoid init(int R, int C) {\n    // No need to explicitly store R and C since the grid is sparse\n    // Clear the grid map\n    grid.clear();\n}\n\n// Update the value at cell (P, Q) to K\nvoid update(int P, int Q, long long K) {\n    pair<int, int> cell = {P, Q};\n    grid[cell] = K; // Update the value in the sparse map\n}\n\n// Calculate the GCD of all values in the rectangle from (P, Q) to (U, V)\nlong long calculate(int P, int Q, int U, int V) {\n    long long result = 0; // Initialize GCD result\n\n    // Iterate over all stored updates in the grid map\n    for (const auto& entry : grid) {\n        int row = entry.first.first;\n        int col = entry.first.second;\n        long long value = entry.second;\n\n        // Check if the cell is inside the rectangle\n        if (row >= P && row <= U && col >= Q && col <= V) {\n            // Update the GCD\n            result = gcd(result, value);\n        }\n    }\n\n    return result; // Return the computed GCD\n}\n\n// Helper function to compute GCD\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 18:08:44",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/C",
    "title": "C. Soccer Stadium",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "C",
    "submission_id": "314988710",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint biggest_stadium(int N, vector<vector<int>> F) {\n    // Precompute prefix sums for rows and columns\n    vector<vector<int>> rowSum(N, vector<int>(N + 1, 0));\n    vector<vector<int>> colSum(N + 1, vector<int>(N, 0));\n    \n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            rowSum[r][c + 1] = rowSum[r][c] + F[r][c];\n            colSum[r + 1][c] = colSum[r][c] + F[r][c];\n        }\n    }\n\n    // Helper function to check if a range is empty in a row\n    auto isRowClear = [&](int r, int c1, int c2) {\n        return rowSum[r][c2 + 1] - rowSum[r][c1] == 0;\n    };\n\n    // Helper function to check if a range is empty in a column\n    auto isColClear = [&](int c, int r1, int r2) {\n        return colSum[r2 + 1][c] - colSum[r1][c] == 0;\n    };\n\n    int maxSize = 1; // Minimum possible size of a stadium\n\n    // Binary search for maximum size\n    int left = 1, right = N * N;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        bool found = false;\n\n        // Check all possible stadiums of size `mid`\n        for (int r1 = 0; r1 < N && !found; ++r1) {\n            for (int c1 = 0; c1 < N && !found; ++c1) {\n                int r2 = r1 + (mid - 1) / N; // Bottom-right row\n                int c2 = c1 + (mid - 1) % N; // Bottom-right column\n\n                if (r2 >= N || c2 >= N) continue;\n\n                // Check if all rows and columns in the stadium are clear\n                bool valid = true;\n                for (int r = r1; r <= r2; ++r) {\n                    if (!isRowClear(r, c1, c2)) {\n                        valid = false;\n                        break;\n                    }\n                }\n                for (int c = c1; c <= c2; ++c) {\n                    if (!isColClear(c, r1, r2)) {\n                        valid = false;\n                        break;\n                    }\n                }\n\n                if (valid) {\n                    found = true;\n                    break;\n                }\n            }\n        }\n\n        if (found) {\n            maxSize = mid;\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return maxSize;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 18:09:24",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/C",
    "title": "C. Soccer Stadium",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "C",
    "submission_id": "314988774",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint biggest_stadium(int N, vector<vector<int>> F) {\n    // Precompute row-wise prefix sums for empty cells\n    vector<vector<int>> rowPrefix(N, vector<int>(N + 1, 0));\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            rowPrefix[r][c + 1] = rowPrefix[r][c] + (F[r][c] == 0 ? 1 : 0);\n        }\n    }\n\n    // Precompute column-wise prefix sums for empty cells\n    vector<vector<int>> colPrefix(N + 1, vector<int>(N, 0));\n    for (int c = 0; c < N; ++c) {\n        for (int r = 0; r < N; ++r) {\n            colPrefix[r + 1][c] = colPrefix[r][c] + (F[r][c] == 0 ? 1 : 0);\n        }\n    }\n\n    // Function to check if a subgrid of size s is valid\n    auto is_valid = [&](int s) -> bool {\n        for (int r = 0; r + s - 1 < N; ++r) {\n            for (int c = 0; c + s - 1 < N; ++c) {\n                // Check all rows in the subgrid\n                bool valid = true;\n                for (int i = r; i < r + s; ++i) {\n                    if (rowPrefix[i][c + s] - rowPrefix[i][c] != s) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (!valid) continue;\n\n                // Check all columns in the subgrid\n                for (int j = c; j < c + s; ++j) {\n                    if (colPrefix[r + s][j] - colPrefix[r][j] != s) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) return true;\n            }\n        }\n        return false;\n    };\n\n    // Binary search for the maximum size of the stadium\n    int low = 1, high = N, best = 0;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (is_valid(mid)) {\n            best = mid;\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    return best * best;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 18:10:05",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/C",
    "title": "C. Soccer Stadium",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "C",
    "submission_id": "314988862",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint biggest_stadium(int N, vector<vector<int>> F) {\n    // Precompute the maximum consecutive zeros in rows and columns\n    vector<vector<int>> row(N, vector<int>(N, 0));\n    vector<vector<int>> col(N, vector<int>(N, 0));\n    \n    // Precompute row-wise consecutive zeros\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            if (F[r][c] == 0) {\n                row[r][c] = (c == 0) ? 1 : row[r][c - 1] + 1;\n            }\n        }\n    }\n\n    // Precompute column-wise consecutive zeros\n    for (int c = 0; c < N; ++c) {\n        for (int r = 0; r < N; ++r) {\n            if (F[r][c] == 0) {\n                col[r][c] = (r == 0) ? 1 : col[r - 1][c] + 1;\n            }\n        }\n    }\n\n    // Variable to store the maximum size of a valid stadium\n    int max_size = 0;\n\n    // Check every possible stadium center\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            if (F[r][c] == 1) continue; // Skip trees\n\n            // Minimum row and column span from this center\n            int min_row_span = N, min_col_span = N;\n\n            // Expand outward to form the largest possible stadium\n            for (int d = 0; r - d >= 0 && r + d < N && c - d >= 0 && c + d < N; ++d) {\n                // Update the minimum row and column span\n                min_row_span = min(min_row_span, row[r + d][c + d] - (c - d - 1 >= 0 ? row[r + d][c - d - 1] : 0));\n                min_col_span = min(min_col_span, col[r + d][c + d] - (r - d - 1 >= 0 ? col[r - d - 1][c + d] : 0));\n\n                // Check if the current stadium is valid\n                if (min_row_span >= 2 * d + 1 && min_col_span >= 2 * d + 1) {\n                    max_size = max(max_size, (2 * d + 1) * (2 * d + 1));\n                } else {\n                    break; // No need to expand further\n                }\n            }\n        }\n    }\n\n    return max_size;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 18:10:50",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/C",
    "title": "C. Soccer Stadium",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "C",
    "submission_id": "314988967",
    "code_index": 3,
    "code": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Your code will be placed here\nint biggest_stadium(int N, vector<vector<int>> F) {\n    // Auxiliary matrices for horizontal and vertical spans\n    vector<vector<int>> horizontal(N, vector<int>(N, 0));\n    vector<vector<int>> vertical(N, vector<int>(N, 0));\n    \n    // Compute horizontal spans\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (F[i][j] == 0) {\n                horizontal[i][j] = (j == 0) ? 1 : horizontal[i][j - 1] + 1;\n            } else {\n                horizontal[i][j] = 0;\n            }\n        }\n    }\n\n    // Compute vertical spans\n    for (int j = 0; j < N; j++) {\n        for (int i = 0; i < N; i++) {\n            if (F[i][j] == 0) {\n                vertical[i][j] = (i == 0) ? 1 : vertical[i - 1][j] + 1;\n            } else {\n                vertical[i][j] = 0;\n            }\n        }\n    }\n\n    int maxSize = 0;\n\n    // Evaluate potential stadiums\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (F[i][j] == 1) continue; // Skip cells with trees\n\n            int minHorizontal = horizontal[i][j];\n            for (int k = i; k < N && F[k][j] == 0; k++) {\n                minHorizontal = min(minHorizontal, horizontal[k][j]);\n                int height = k - i + 1;\n                int width = minHorizontal;\n                int size = height * width;\n\n                // Check if stadium is regular\n                if (size > maxSize) {\n                    maxSize = size;\n                }\n            }\n        }\n    }\n\n    return maxSize;\n}"
  },
  {
    "date": "IOI 2023 day 1",
    "timestamp": "2025-04-11 18:11:29",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/104548/problem/C",
    "title": "C. Soccer Stadium",
    "group_id": "32KGsXgiKA",
    "contest_id": "104548",
    "problem_index": "C",
    "submission_id": "314989025",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint biggest_stadium(int N, vector<vector<int>> F) {\n    // Prefix sums for rows and columns\n    vector<vector<int>> rowSum(N, vector<int>(N, 0));\n    vector<vector<int>> colSum(N, vector<int>(N, 0));\n    \n    // Precompute row and column prefix sums\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            rowSum[r][c] = (F[r][c] == 0) + (c > 0 ? rowSum[r][c - 1] : 0);\n            colSum[r][c] = (F[r][c] == 0) + (r > 0 ? colSum[r - 1][c] : 0);\n        }\n    }\n    \n    // DP table to store the largest stadium size ending at (r, c)\n    vector<vector<int>> dp(N, vector<int>(N, 0));\n    int maxStadiumSize = 0;\n\n    // Compute DP values\n    for (int r = 0; r < N; ++r) {\n        for (int c = 0; c < N; ++c) {\n            if (F[r][c] == 1) {\n                dp[r][c] = 0; // Cell is not empty\n            } else {\n                dp[r][c] = 1; // Single cell is always a valid stadium\n                if (r > 0 && c > 0) {\n                    // Check the minimum size of a rectangle that can extend to (r, c)\n                    int minWidth = dp[r - 1][c];\n                    int minHeight = dp[r][c - 1];\n                    int width = minWidth + 1;\n                    int height = minHeight + 1;\n\n                    // Validate the rectangle using prefix sums\n                    if (rowSum[r][c] - (c - width >= 0 ? rowSum[r][c - width] : 0) == width &&\n                        colSum[r][c] - (r - height >= 0 ? colSum[r - height][c] : 0) == height) {\n                        dp[r][c] = width * height;\n                    }\n                }\n                maxStadiumSize = max(maxStadiumSize, dp[r][c]);\n            }\n        }\n    }\n\n    return maxStadiumSize;\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 18:12:19",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/C",
    "title": "C. Wombats",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "C",
    "submission_id": "314989090",
    "code_index": 0,
    "code": "#include \"wombats.h\"\n#include <vector>\n#include <queue>\n#include <limits>\n#include <cstring>\n\nusing namespace std;\n\n// Constants for maximum dimensions\nconst int MAX_R = 5000;\nconst int MAX_C = 200;\nconst int INF = numeric_limits<int>::max();\n\n// Graph representation\nint R, C;\nint H[MAX_R][MAX_C - 1]; // Horizontal roads weight\nint V[MAX_R - 1][MAX_C]; // Vertical roads weight\n\n// Dijkstra's algorithm helper function\nint dijkstra(int startCol, int endCol) {\n    // Priority queue for Dijkstra's algorithm\n    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;\n\n    // Distance array\n    vector<vector<int>> dist(R, vector<int>(C, INF));\n    dist[0][startCol] = 0;\n\n    // Push starting point into the priority queue\n    pq.push({0, {0, startCol}});\n\n    while (!pq.empty()) {\n        auto [currentDist, currentPos] = pq.top();\n        pq.pop();\n        int row = currentPos.first;\n        int col = currentPos.second;\n\n        // If we've reached the desired destination\n        if (row == R - 1 && col == endCol) {\n            return currentDist;\n        }\n\n        // Skip if we already have a better distance\n        if (currentDist > dist[row][col]) {\n            continue;\n        }\n\n        // Explore neighbors\n        // Move right on the same row\n        if (col + 1 < C) {\n            int newDist = currentDist + H[row][col];\n            if (newDist < dist[row][col + 1]) {\n                dist[row][col + 1] = newDist;\n                pq.push({newDist, {row, col + 1}});\n            }\n        }\n        // Move left on the same row\n        if (col - 1 >= 0) {\n            int newDist = currentDist + H[row][col - 1];\n            if (newDist < dist[row][col - 1]) {\n                dist[row][col - 1] = newDist;\n                pq.push({newDist, {row, col - 1}});\n            }\n        }\n        // Move down to the next row\n        if (row + 1 < R) {\n            int newDist = currentDist + V[row][col];\n            if (newDist < dist[row + 1][col]) {\n                dist[row + 1][col] = newDist;\n                pq.push({newDist, {row + 1, col}});\n            }\n        }\n    }\n\n    return INF; // If no path is found (should not happen with valid input)\n}\n\n// Initialization function\nvoid init(int r, int c, int h[5000][200], int v[5000][200]) {\n    R = r;\n    C = c;\n\n    // Copy H and V arrays into the global variables\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C - 1; ++j) {\n            H[i][j] = h[i][j];\n        }\n    }\n    for (int i = 0; i < R - 1; ++i) {\n        for (int j = 0; j < C; ++j) {\n            V[i][j] = v[i][j];\n        }\n    }\n}\n\n// Update horizontal road weights\nvoid changeH(int P, int Q, int W) {\n    H[P][Q] = W;\n}\n\n// Update vertical road weights\nvoid changeV(int P, int Q, int W) {\n    V[P][Q] = W;\n}\n\n// Escape calculation using Dijkstra's algorithm\nint escape(int V1, int V2) {\n    return dijkstra(V1, V2);\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 18:13:04",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/C",
    "title": "C. Wombats",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "C",
    "submission_id": "314989156",
    "code_index": 1,
    "code": "#include \"wombats.h\"\n#include <vector>\n#include <queue>\n#include <limits>\nusing namespace std;\n\n// Constants for maximum rows and columns\nconst int MAX_R = 5000;\nconst int MAX_C = 200;\n\n// Global variables for the road weights\nvector<vector<int>> horizontal;\nvector<vector<int>> vertical;\nint R, C;\n\n// Priority queue element for Dijkstra's algorithm\nstruct Node {\n    int row, col, cost;\n    bool operator>(const Node &other) const {\n        return cost > other.cost;\n    }\n};\n\n// Initialize the grid\nvoid init(int r, int c, int H[MAX_R][MAX_C - 1], int V[MAX_R - 1][MAX_C]) {\n    R = r;\n    C = c;\n\n    // Initialize horizontal and vertical road weights based on input\n    horizontal.assign(R, vector<int>(C - 1));\n    vertical.assign(R - 1, vector<int>(C));\n\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C - 1; ++j) {\n            horizontal[i][j] = H[i][j];\n        }\n    }\n    for (int i = 0; i < R - 1; ++i) {\n        for (int j = 0; j < C; ++j) {\n            vertical[i][j] = V[i][j];\n        }\n    }\n}\n\n// Handle horizontal road weight updates\nvoid changeH(int P, int Q, int W) {\n    horizontal[P][Q] = W;\n}\n\n// Handle vertical road weight updates\nvoid changeV(int P, int Q, int W) {\n    vertical[P][Q] = W;\n}\n\n// Escape function to compute the minimum wombats passed\nint escape(int V1, int V2) {\n    // Dijkstra's algorithm to find the shortest path\n    vector<vector<int>> dist(R, vector<int>(C, numeric_limits<int>::max()));\n    priority_queue<Node, vector<Node>, greater<Node>> pq;\n\n    // Start from (0, V1)\n    dist[0][V1] = 0;\n    pq.push({0, V1, 0});\n\n    while (!pq.empty()) {\n        Node current = pq.top();\n        pq.pop();\n\n        int row = current.row;\n        int col = current.col;\n        int cost = current.cost;\n\n        // If we reach the destination (R-1, V2), return the cost\n        if (row == R - 1 && col == V2) {\n            return cost;\n        }\n\n        // Skip if this is not the shortest path to this node\n        if (cost > dist[row][col]) {\n            continue;\n        }\n\n        // Move left on the same horizontal road\n        if (col > 0) {\n            int newCost = cost + horizontal[row][col - 1];\n            if (newCost < dist[row][col - 1]) {\n                dist[row][col - 1] = newCost;\n                pq.push({row, col - 1, newCost});\n            }\n        }\n\n        // Move right on the same horizontal road\n        if (col < C - 1) {\n            int newCost = cost + horizontal[row][col];\n            if (newCost < dist[row][col + 1]) {\n                dist[row][col + 1] = newCost;\n                pq.push({row, col + 1, newCost});\n            }\n        }\n\n        // Move down on the vertical road\n        if (row < R - 1) {\n            int newCost = cost + vertical[row][col];\n            if (newCost < dist[row + 1][col]) {\n                dist[row + 1][col] = newCost;\n                pq.push({row + 1, col, newCost});\n            }\n        }\n    }\n\n    // If no path is found (shouldn't happen under valid input), return a large value\n    return numeric_limits<int>::max();\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 18:13:45",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/C",
    "title": "C. Wombats",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "C",
    "submission_id": "314989236",
    "code_index": 2,
    "code": "#include \"wombats.h\"\n#include <vector>\n#include <queue>\n#include <limits>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\nint R, C;\nvector<vector<int>> H, V;\n\n// Graph representation for Dijkstra\nstruct Edge {\n    int to, weight;\n};\n\nvector<vector<Edge>> graph;\n\n// Function to convert 2D grid coordinates to 1D node indices\ninline int nodeIndex(int row, int col) {\n    return row * C + col;\n}\n\n// Initialize the graph\nvoid buildGraph() {\n    graph.assign(R * C, vector<Edge>());\n\n    for (int p = 0; p < R; ++p) {\n        for (int q = 0; q < C; ++q) {\n            // Horizontal edges\n            if (q < C - 1) {\n                graph[nodeIndex(p, q)].push_back({nodeIndex(p, q + 1), H[p][q]});\n                graph[nodeIndex(p, q + 1)].push_back({nodeIndex(p, q), H[p][q]});\n            }\n            // Vertical edges\n            if (p < R - 1) {\n                graph[nodeIndex(p, q)].push_back({nodeIndex(p + 1, q), V[p][q]});\n            }\n        }\n    }\n}\n\n// Dijkstra's algorithm to find the shortest path\nint dijkstra(int start, int end) {\n    vector<int> dist(R * C, INF);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n\n    dist[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        auto [currentDist, u] = pq.top();\n        pq.pop();\n\n        if (currentDist > dist[u]) continue;\n\n        for (const auto &edge : graph[u]) {\n            int v = edge.to;\n            int weight = edge.weight;\n\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    return dist[end];\n}\n\nvoid init(int r, int c, int h[5000][200], int v[5000][200]) {\n    R = r;\n    C = c;\n\n    H.assign(R, vector<int>(C - 1));\n    V.assign(R - 1, vector<int>(C));\n\n    for (int p = 0; p < R; ++p) {\n        for (int q = 0; q < C - 1; ++q) {\n            H[p][q] = h[p][q];\n        }\n    }\n\n    for (int p = 0; p < R - 1; ++p) {\n        for (int q = 0; q < C; ++q) {\n            V[p][q] = v[p][q];\n        }\n    }\n\n    buildGraph();\n}\n\nvoid changeH(int P, int Q, int W) {\n    H[P][Q] = W;\n\n    // Update the graph\n    int u = nodeIndex(P, Q);\n    int v = nodeIndex(P, Q + 1);\n\n    for (auto &edge : graph[u]) {\n        if (edge.to == v) {\n            edge.weight = W;\n            break;\n        }\n    }\n\n    for (auto &edge : graph[v]) {\n        if (edge.to == u) {\n            edge.weight = W;\n            break;\n        }\n    }\n}\n\nvoid changeV(int P, int Q, int W) {\n    V[P][Q] = W;\n\n    // Update the graph\n    int u = nodeIndex(P, Q);\n    int v = nodeIndex(P + 1, Q);\n\n    for (auto &edge : graph[u]) {\n        if (edge.to == v) {\n            edge.weight = W;\n            break;\n        }\n    }\n}\n\nint escape(int V1, int V2) {\n    int start = nodeIndex(0, V1);\n    int end = nodeIndex(R - 1, V2);\n    return dijkstra(start, end);\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 18:14:22",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/C",
    "title": "C. Wombats",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "C",
    "submission_id": "314989301",
    "code_index": 3,
    "code": "#include \"wombats.h\"\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nstruct Edge {\n    int to, weight;\n};\n\nint R, C;\nvector<vector<Edge>> graph;\nvector<int> dist;\nvector<bool> visited;\n\nvoid buildGraph(int R, int C, int H[5000][200], int V[5000][200]) {\n    graph.assign(R * C, vector<Edge>());\n    for (int p = 0; p < R; ++p) {\n        for (int q = 0; q < C; ++q) {\n            int node = p * C + q;\n            // Horizontal edges\n            if (q < C - 1) {\n                int right = node + 1;\n                graph[node].push_back({right, H[p][q]});\n                graph[right].push_back({node, H[p][q]});\n            }\n            // Vertical edges\n            if (p < R - 1) {\n                int down = node + C;\n                graph[node].push_back({down, V[p][q]});\n                // No upward edges since motion is southward only\n            }\n        }\n    }\n}\n\nvoid updateEdge(int u, int v, int newWeight) {\n    for (Edge &edge : graph[u]) {\n        if (edge.to == v) {\n            edge.weight = newWeight;\n            break;\n        }\n    }\n}\n\nvoid init(int R_, int C_, int H[5000][200], int V[5000][200]) {\n    R = R_;\n    C = C_;\n    buildGraph(R, C, H, V);\n}\n\nvoid changeH(int P, int Q, int W) {\n    int node1 = P * C + Q;\n    int node2 = node1 + 1;\n    updateEdge(node1, node2, W);\n    updateEdge(node2, node1, W);\n}\n\nvoid changeV(int P, int Q, int W) {\n    int node1 = P * C + Q;\n    int node2 = node1 + C;\n    updateEdge(node1, node2, W);\n}\n\nint escape(int V1, int V2) {\n    int start = V1;\n    int end = (R - 1) * C + V2;\n\n    // Initialize distances and visited set\n    dist.assign(R * C, INF);\n    visited.assign(R * C, false);\n    dist[start] = 0;\n\n    // Priority queue for Dijkstra's Algorithm\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (visited[u]) continue;\n        visited[u] = true;\n\n        for (const Edge &edge : graph[u]) {\n            int v = edge.to;\n            int weight = edge.weight;\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    return dist[end];\n}"
  },
  {
    "date": "IOI 2013 day 1",
    "timestamp": "2025-04-11 18:15:06",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103762/problem/C",
    "title": "C. Wombats",
    "group_id": "32KGsXgiKA",
    "contest_id": "103762",
    "problem_index": "C",
    "submission_id": "314989377",
    "code_index": 4,
    "code": "#include \"wombats.h\"\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\nint R, C;\nvector<vector<int>> H; // Horizontal weights\nvector<vector<int>> V; // Vertical weights\n\n// Graph representation for Dijkstra's algorithm\nstruct Edge {\n    int to, weight;\n};\n\nvector<vector<Edge>> graph;\n\n// Initialize the graph based on the input\nvoid buildGraph() {\n    graph.clear();\n    graph.resize(R * C);\n\n    for (int p = 0; p < R; ++p) {\n        for (int q = 0; q < C; ++q) {\n            int node = p * C + q;\n\n            // Connect horizontal edges\n            if (q < C - 1) {\n                int rightNode = node + 1;\n                graph[node].push_back({rightNode, H[p][q]});\n                graph[rightNode].push_back({node, H[p][q]});\n            }\n\n            // Connect vertical edges\n            if (p < R - 1) {\n                int downNode = node + C;\n                graph[node].push_back({downNode, V[p][q]});\n                graph[downNode].push_back({node, V[p][q]});\n            }\n        }\n    }\n}\n\n// Dijkstra's algorithm to find the shortest path\nint dijkstra(int start, int end) {\n    vector<int> dist(R * C, INF);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n\n    dist[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        auto [currentDist, currentNode] = pq.top();\n        pq.pop();\n\n        if (currentDist > dist[currentNode]) continue;\n\n        for (const auto& edge : graph[currentNode]) {\n            int nextNode = edge.to;\n            int newDist = currentDist + edge.weight;\n\n            if (newDist < dist[nextNode]) {\n                dist[nextNode] = newDist;\n                pq.push({newDist, nextNode});\n            }\n        }\n    }\n\n    return dist[end];\n}\n\nvoid init(int R_, int C_, int H_[5000][200], int V_[5000][200]) {\n    R = R_;\n    C = C_;\n\n    // Copy the input grid into the global variables\n    H.assign(R, vector<int>(C - 1));\n    V.assign(R - 1, vector<int>(C));\n\n    for (int p = 0; p < R; ++p) {\n        for (int q = 0; q < C - 1; ++q) {\n            H[p][q] = H_[p][q];\n        }\n    }\n\n    for (int p = 0; p < R - 1; ++p) {\n        for (int q = 0; q < C; ++q) {\n            V[p][q] = V_[p][q];\n        }\n    }\n\n    // Build the initial graph\n    buildGraph();\n}\n\nvoid changeH(int P, int Q, int W) {\n    H[P][Q] = W;\n\n    // Update the graph\n    int node1 = P * C + Q;\n    int node2 = node1 + 1;\n\n    for (auto& edge : graph[node1]) {\n        if (edge.to == node2) {\n            edge.weight = W;\n        }\n    }\n\n    for (auto& edge : graph[node2]) {\n        if (edge.to == node1) {\n            edge.weight = W;\n        }\n    }\n}\n\nvoid changeV(int P, int Q, int W) {\n    V[P][Q] = W;\n\n    // Update the graph\n    int node1 = P * C + Q;\n    int node2 = node1 + C;\n\n    for (auto& edge : graph[node1]) {\n        if (edge.to == node2) {\n            edge.weight = W;\n        }\n    }\n\n    for (auto& edge : graph[node2]) {\n        if (edge.to == node1) {\n            edge.weight = W;\n        }\n    }\n}\n\nint escape(int V1, int V2) {\n    int start = V1;\n    int end = (R - 1) * C + V2;\n\n    return dijkstra(start, end);\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 18:16:07",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/D",
    "title": "D. Mutating DNA",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "D",
    "submission_id": "314989486",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\n// Global variables to store the DNA sequences and prefix counts\nstring global_a, global_b;\nvector<vector<int>> prefix_a, prefix_b;\n\n// Helper function to calculate the minimum number of swaps to transform one permutation into another\nint calculate_min_swaps(vector<int>& arr1, vector<int>& arr2) {\n    int n = arr1.size();\n    vector<bool> visited(n, false);\n    vector<pair<int, int>> sorted_arr1(n);\n    for (int i = 0; i < n; ++i) {\n        sorted_arr1[i] = {arr1[i], i};\n    }\n    sort(sorted_arr1.begin(), sorted_arr1.end());\n    \n    vector<int> target_index(n);\n    for (int i = 0; i < n; ++i) {\n        target_index[sorted_arr1[i].second] = i;\n    }\n    \n    int swaps = 0;\n    for (int i = 0; i < n; ++i) {\n        if (visited[i] || target_index[i] == i) {\n            continue;\n        }\n        \n        int cycle_size = 0;\n        int j = i;\n        while (!visited[j]) {\n            visited[j] = true;\n            j = target_index[j];\n            ++cycle_size;\n        }\n        swaps += cycle_size - 1;\n    }\n    return swaps;\n}\n\nvoid init(string a, string b) {\n    global_a = a;\n    global_b = b;\n    int n = a.size();\n    \n    // Initialize prefix sums for character counts\n    prefix_a = vector<vector<int>>(n + 1, vector<int>(3, 0));\n    prefix_b = vector<vector<int>>(n + 1, vector<int>(3, 0));\n    \n    for (int i = 0; i < n; ++i) {\n        prefix_a[i + 1] = prefix_a[i];\n        prefix_b[i + 1] = prefix_b[i];\n        if (a[i] == 'A') prefix_a[i + 1][0]++;\n        else if (a[i] == 'T') prefix_a[i + 1][1]++;\n        else if (a[i] == 'C') prefix_a[i + 1][2]++;\n        \n        if (b[i] == 'A') prefix_b[i + 1][0]++;\n        else if (b[i] == 'T') prefix_b[i + 1][1]++;\n        else if (b[i] == 'C') prefix_b[i + 1][2]++;\n    }\n}\n\nint get_distance(int x, int y) {\n    // Compute character counts for a[x..y] and b[x..y]\n    vector<int> count_a(3), count_b(3);\n    for (int i = 0; i < 3; ++i) {\n        count_a[i] = prefix_a[y + 1][i] - prefix_a[x][i];\n        count_b[i] = prefix_b[y + 1][i] - prefix_b[x][i];\n    }\n    \n    // If character counts are different, return -1\n    if (count_a != count_b) {\n        return -1;\n    }\n    \n    // Extract substrings\n    string sub_a = global_a.substr(x, y - x + 1);\n    string sub_b = global_b.substr(x, y - x + 1);\n    \n    // Map characters to indices for easier comparison\n    vector<int> arr1, arr2;\n    for (char c : sub_a) {\n        if (c == 'A') arr1.push_back(0);\n        else if (c == 'T') arr1.push_back(1);\n        else if (c == 'C') arr1.push_back(2);\n    }\n    for (char c : sub_b) {\n        if (c == 'A') arr2.push_back(0);\n        else if (c == 'T') arr2.push_back(1);\n        else if (c == 'C') arr2.push_back(2);\n    }\n    \n    // Calculate the minimum number of swaps\n    return calculate_min_swaps(arr1, arr2);\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 18:16:53",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/D",
    "title": "D. Mutating DNA",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "D",
    "submission_id": "314989573",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nstring global_a, global_b;\nvector<vector<int>> prefix_count_a, prefix_count_b;\n\n// Function to initialize the DNA sequences and precompute prefix counts\nvoid init(string a, string b) {\n    global_a = a;\n    global_b = b;\n    int n = a.size();\n    \n    // Initialize prefix count arrays for characters A, T, C\n    prefix_count_a = vector<vector<int>>(3, vector<int>(n + 1, 0));\n    prefix_count_b = vector<vector<int>>(3, vector<int>(n + 1, 0));\n    \n    // Map characters to indices: A -> 0, T -> 1, C -> 2\n    unordered_map<char, int> char_to_index = {{'A', 0}, {'T', 1}, {'C', 2}};\n    \n    for (int i = 0; i < n; ++i) {\n        // Update prefix counts for a\n        for (int j = 0; j < 3; ++j) {\n            prefix_count_a[j][i + 1] = prefix_count_a[j][i];\n        }\n        prefix_count_a[char_to_index[a[i]]][i + 1]++;\n        \n        // Update prefix counts for b\n        for (int j = 0; j < 3; ++j) {\n            prefix_count_b[j][i + 1] = prefix_count_b[j][i];\n        }\n        prefix_count_b[char_to_index[b[i]]][i + 1]++;\n    }\n}\n\n// Function to get the mutation distance between substrings a[x..y] and b[x..y]\nint get_distance(int x, int y) {\n    // Get character counts for substrings a[x..y] and b[x..y]\n    vector<int> count_a(3), count_b(3);\n    for (int i = 0; i < 3; ++i) {\n        count_a[i] = prefix_count_a[i][y + 1] - prefix_count_a[i][x];\n        count_b[i] = prefix_count_b[i][y + 1] - prefix_count_b[i][x];\n    }\n    \n    // If character counts differ, transformation is impossible\n    if (count_a != count_b) {\n        return -1;\n    }\n    \n    // Extract substrings\n    string sub_a = global_a.substr(x, y - x + 1);\n    string sub_b = global_b.substr(x, y - x + 1);\n    \n    // Map characters to their positions in substring b\n    unordered_map<char, vector<int>> pos_map_b;\n    for (int i = 0; i < sub_b.size(); ++i) {\n        pos_map_b[sub_b[i]].push_back(i);\n    }\n    \n    // Create the permutation array for transforming sub_a into sub_b\n    vector<int> permutation(sub_a.size());\n    unordered_map<char, int> pos_index;\n    for (int i = 0; i < sub_a.size(); ++i) {\n        char c = sub_a[i];\n        permutation[i] = pos_map_b[c][pos_index[c]++];\n    }\n    \n    // Count the number of cycles in the permutation\n    vector<bool> visited(permutation.size(), false);\n    int cycles = 0;\n    for (int i = 0; i < permutation.size(); ++i) {\n        if (!visited[i]) {\n            cycles++;\n            int j = i;\n            while (!visited[j]) {\n                visited[j] = true;\n                j = permutation[j];\n            }\n        }\n    }\n    \n    // Minimum number of swaps is the length of the array minus the number of cycles\n    return sub_a.size() - cycles;\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 18:17:36",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/D",
    "title": "D. Mutating DNA",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "D",
    "submission_id": "314989646",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\n\nstring global_a, global_b;\n\n// Helper function to calculate the minimum number of swaps for sorting\nint calculate_min_swaps(const string& s, const string& target) {\n    int n = s.size();\n    vector<int> pos(n);\n    unordered_map<char, vector<int>> target_positions;\n\n    // Map each character in the target to its positions\n    for (int i = 0; i < n; ++i) {\n        target_positions[target[i]].push_back(i);\n    }\n\n    // Map each character in s to its corresponding position in target\n    vector<bool> visited(n, false);\n    for (int i = 0; i < n; ++i) {\n        pos[i] = target_positions[s[i]].back();\n        target_positions[s[i]].pop_back();\n    }\n\n    // Count cycles in the permutation array\n    int swaps = 0;\n    for (int i = 0; i < n; ++i) {\n        if (visited[i] || pos[i] == i) continue;\n        int cycle_size = 0, j = i;\n        while (!visited[j]) {\n            visited[j] = true;\n            j = pos[j];\n            ++cycle_size;\n        }\n        if (cycle_size > 1) swaps += cycle_size - 1;\n    }\n\n    return swaps;\n}\n\nvoid init(string a, string b) {\n    global_a = a;\n    global_b = b;\n}\n\nint get_distance(int x, int y) {\n    string sub_a = global_a.substr(x, y - x + 1);\n    string sub_b = global_b.substr(x, y - x + 1);\n\n    // Count the frequency of each character in sub_a and sub_b\n    vector<int> freq_a(3, 0), freq_b(3, 0);\n    for (char c : sub_a) {\n        if (c == 'A') freq_a[0]++;\n        else if (c == 'T') freq_a[1]++;\n        else if (c == 'C') freq_a[2]++;\n    }\n    for (char c : sub_b) {\n        if (c == 'A') freq_b[0]++;\n        else if (c == 'T') freq_b[1]++;\n        else if (c == 'C') freq_b[2]++;\n    }\n\n    // If the frequencies don't match, transformation is impossible\n    if (freq_a != freq_b) return -1;\n\n    // Calculate the minimum number of swaps needed\n    return calculate_min_swaps(sub_a, sub_b);\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 18:18:16",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/D",
    "title": "D. Mutating DNA",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "D",
    "submission_id": "314989705",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n#include <numeric>\nusing namespace std;\n\nstring a, b;\n\n// Function to calculate the minimum number of inversions (mutations) required to transform one string into another\nint calculate_mutation_distance(const string& s1, const string& s2) {\n    int n = s1.size();\n    vector<int> pos(n);\n    unordered_map<char, vector<int>> char_positions;\n\n    // Map characters of s2 to their positions\n    for (int i = 0; i < n; i++) {\n        char_positions[s2[i]].push_back(i);\n    }\n\n    // Map characters of s1 to the corresponding positions in s2\n    for (int i = 0; i < n; i++) {\n        pos[i] = char_positions[s1[i]].back();\n        char_positions[s1[i]].pop_back();\n    }\n\n    // Count inversions in pos, which is the minimum number of swaps needed\n    vector<int> bit(n + 1, 0);\n\n    auto add = [&](int idx, int val) {\n        for (; idx <= n; idx += idx & -idx) {\n            bit[idx] += val;\n        }\n    };\n\n    auto sum = [&](int idx) {\n        int s = 0;\n        for (; idx > 0; idx -= idx & -idx) {\n            s += bit[idx];\n        }\n        return s;\n    };\n\n    int inversions = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        inversions += sum(pos[i]);\n        add(pos[i] + 1, 1);\n    }\n\n    return inversions;\n}\n\nvoid init(string _a, string _b) {\n    a = _a;\n    b = _b;\n}\n\nint get_distance(int x, int y) {\n    string sub_a = a.substr(x, y - x + 1);\n    string sub_b = b.substr(x, y - x + 1);\n\n    // Check if the substrings have the same character counts\n    unordered_map<char, int> count_a, count_b;\n    for (char c : sub_a) count_a[c]++;\n    for (char c : sub_b) count_b[c]++;\n\n    if (count_a != count_b) {\n        return -1;\n    }\n\n    // Calculate the mutation distance if transformation is possible\n    return calculate_mutation_distance(sub_a, sub_b);\n}"
  },
  {
    "date": "IOI 2021 day 2",
    "timestamp": "2025-04-11 18:18:56",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103784/problem/D",
    "title": "D. Mutating DNA",
    "group_id": "32KGsXgiKA",
    "contest_id": "103784",
    "problem_index": "D",
    "submission_id": "314989780",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<vector<int>> prefix_count_a; // Prefix frequency count for DNA sequence a\nvector<vector<int>> prefix_count_b; // Prefix frequency count for DNA sequence b\nstring dna_a, dna_b;\n\nvoid init(string a, string b) {\n    dna_a = a;\n    dna_b = b;\n    int n = a.size();\n\n    // Initialize prefix frequency counts for 'A', 'T', 'C'\n    prefix_count_a.assign(3, vector<int>(n + 1, 0));\n    prefix_count_b.assign(3, vector<int>(n + 1, 0));\n\n    // Fill prefix frequency counts for a and b\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            prefix_count_a[j][i + 1] = prefix_count_a[j][i];\n            prefix_count_b[j][i + 1] = prefix_count_b[j][i];\n        }\n        if (a[i] == 'A') prefix_count_a[0][i + 1]++;\n        if (a[i] == 'T') prefix_count_a[1][i + 1]++;\n        if (a[i] == 'C') prefix_count_a[2][i + 1]++;\n        if (b[i] == 'A') prefix_count_b[0][i + 1]++;\n        if (b[i] == 'T') prefix_count_b[1][i + 1]++;\n        if (b[i] == 'C') prefix_count_b[2][i + 1]++;\n    }\n}\n\nint get_distance(int x, int y) {\n    // Calculate character frequencies for substrings a[x..y] and b[x..y]\n    vector<int> freq_a(3, 0), freq_b(3, 0);\n    for (int i = 0; i < 3; ++i) {\n        freq_a[i] = prefix_count_a[i][y + 1] - prefix_count_a[i][x];\n        freq_b[i] = prefix_count_b[i][y + 1] - prefix_count_b[i][x];\n    }\n\n    // If the frequencies do not match, return -1\n    if (freq_a != freq_b) return -1;\n\n    // Extract substrings a[x..y] and b[x..y]\n    string sub_a = dna_a.substr(x, y - x + 1);\n    string sub_b = dna_b.substr(x, y - x + 1);\n\n    // Determine the minimum number of swaps to transform sub_a into sub_b\n    int n = sub_a.size();\n    vector<int> pos_b(n);\n    unordered_map<char, vector<int>> char_positions;\n\n    // Record positions of characters in sub_b\n    for (int i = 0; i < n; ++i) {\n        char_positions[sub_b[i]].push_back(i);\n    }\n\n    // Map characters in sub_a to positions in sub_b\n    for (int i = 0; i < n; ++i) {\n        pos_b[i] = char_positions[sub_a[i]].back();\n        char_positions[sub_a[i]].pop_back();\n    }\n\n    // Count the number of cycles in the permutation pos_b\n    vector<bool> visited(n, false);\n    int swaps = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            int cycle_size = 0;\n            int current = i;\n            while (!visited[current]) {\n                visited[current] = true;\n                current = pos_b[current];\n                cycle_size++;\n            }\n            if (cycle_size > 1) {\n                swaps += cycle_size - 1;\n            }\n        }\n    }\n\n    return swaps;\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 18:19:56",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/F",
    "title": "F. Traffic Congestion",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "F",
    "submission_id": "314989892",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <queue>\n\nusing namespace std;\n\nvoid dfsSubtreePopulation(int node, int parent, const vector<vector<int>>& adj, const vector<int>& P, vector<long long>& subtreePop) {\n    subtreePop[node] = P[node];\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfsSubtreePopulation(neighbor, node, adj, P, subtreePop);\n            subtreePop[node] += subtreePop[neighbor];\n        }\n    }\n}\n\nvoid dfsCalculateCongestion(int node, int parent, const vector<vector<int>>& adj, const vector<int>& P, const vector<long long>& subtreePop, long long totalFans, vector<long long>& maxCongestion) {\n    long long maxLocalCongestion = 0;\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            long long fansThroughEdge = subtreePop[neighbor];\n            maxLocalCongestion = max(maxLocalCongestion, fansThroughEdge);\n        }\n    }\n    if (parent != -1) {\n        long long fansThroughEdge = totalFans - subtreePop[node];\n        maxLocalCongestion = max(maxLocalCongestion, fansThroughEdge);\n    }\n    maxCongestion[node] = maxLocalCongestion;\n\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfsCalculateCongestion(neighbor, node, adj, P, subtreePop, totalFans, maxCongestion);\n        }\n    }\n}\n\nint LocateCentre(int N, vector<int> P, vector<int> S, vector<int> D) {\n    // Step 1: Build adjacency list\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < N - 1; ++i) {\n        adj[S[i]].push_back(D[i]);\n        adj[D[i]].push_back(S[i]);\n    }\n\n    // Step 2: Calculate subtree populations\n    vector<long long> subtreePop(N, 0);\n    dfsSubtreePopulation(0, -1, adj, P, subtreePop);\n\n    // Step 3: Calculate maximum congestion for each city\n    vector<long long> maxCongestion(N, 0);\n    long long totalFans = accumulate(P.begin(), P.end(), 0LL);\n    dfsCalculateCongestion(0, -1, adj, P, subtreePop, totalFans, maxCongestion);\n\n    // Step 4: Find the city with the minimum maximum congestion\n    int bestCity = 0;\n    long long minCongestion = maxCongestion[0];\n    for (int i = 1; i < N; ++i) {\n        if (maxCongestion[i] < minCongestion) {\n            minCongestion = maxCongestion[i];\n            bestCity = i;\n        }\n    }\n\n    return bestCity;\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 18:20:40",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/F",
    "title": "F. Traffic Congestion",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "F",
    "submission_id": "314989970",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nvoid dfs_subtree(int node, int parent, const vector<vector<int>>& tree, const vector<int>& P, vector<int>& subtree_fans) {\n    subtree_fans[node] = P[node];\n    for (int neighbor : tree[node]) {\n        if (neighbor != parent) {\n            dfs_subtree(neighbor, node, tree, P, subtree_fans);\n            subtree_fans[node] += subtree_fans[neighbor];\n        }\n    }\n}\n\nvoid dfs_congestion(int node, int parent, const vector<vector<int>>& tree, const vector<int>& P, const vector<int>& subtree_fans, int total_fans, vector<long long>& max_congestion) {\n    long long max_local_congestion = 0;\n    for (int neighbor : tree[node]) {\n        if (neighbor != parent) {\n            long long flow = subtree_fans[neighbor];\n            max_local_congestion = max(max_local_congestion, flow);\n            dfs_congestion(neighbor, node, tree, P, subtree_fans, total_fans, max_congestion);\n        }\n    }\n    if (parent != -1) {\n        long long flow = total_fans - subtree_fans[node];\n        max_local_congestion = max(max_local_congestion, flow);\n    }\n    max_congestion[node] = max_local_congestion;\n}\n\nint LocateCentre(int N, const vector<int>& P, const vector<int>& S, const vector<int>& D) {\n    // Build the tree adjacency list\n    vector<vector<int>> tree(N);\n    for (int i = 0; i < N - 1; ++i) {\n        tree[S[i]].push_back(D[i]);\n        tree[D[i]].push_back(S[i]);\n    }\n\n    // Step 1: Calculate subtree fan counts\n    vector<int> subtree_fans(N, 0);\n    dfs_subtree(0, -1, tree, P, subtree_fans);\n\n    // Step 2: Calculate maximum congestion for each city\n    vector<long long> max_congestion(N, LLONG_MAX);\n    int total_fans = subtree_fans[0];\n    dfs_congestion(0, -1, tree, P, subtree_fans, total_fans, max_congestion);\n\n    // Step 3: Find the city with the minimum maximum congestion\n    int best_city = 0;\n    long long min_congestion = LLONG_MAX;\n    for (int i = 0; i < N; ++i) {\n        if (max_congestion[i] < min_congestion) {\n            min_congestion = max_congestion[i];\n            best_city = i;\n        }\n    }\n\n    return best_city;\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 18:21:20",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/F",
    "title": "F. Traffic Congestion",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "F",
    "submission_id": "314990044",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\n// Function to locate the best city for the hockey arena\nint LocateCentre(int N, vector<int> P, vector<int> S, vector<int> D) {\n    // Step 1: Build the adjacency list representation of the tree\n    vector<vector<int>> adj(N);\n    for (int i = 0; i < N - 1; i++) {\n        adj[S[i]].push_back(D[i]);\n        adj[D[i]].push_back(S[i]);\n    }\n\n    // Step 2: Calculate the total population in the entire tree\n    long long total_population = 0;\n    for (int i = 0; i < N; i++) {\n        total_population += P[i];\n    }\n\n    // Step 3: Use DFS to calculate subtree populations and congestion values\n    vector<long long> subtree_population(N, 0);\n    vector<long long> max_congestion(N, LLONG_MAX);\n    \n    // Helper function to compute subtree populations\n    function<void(int, int)> calculate_subtree_population = [&](int node, int parent) {\n        subtree_population[node] = P[node];\n        for (int neighbor : adj[node]) {\n            if (neighbor == parent) continue;\n            calculate_subtree_population(neighbor, node);\n            subtree_population[node] += subtree_population[neighbor];\n        }\n    };\n\n    // Helper function to calculate maximum congestion for each city\n    function<void(int, int, long long)> calculate_congestion = [&](int node, int parent, long long parent_congestion) {\n        long long worst_congestion = parent_congestion;\n        for (int neighbor : adj[node]) {\n            if (neighbor == parent) continue;\n            long long congestion = subtree_population[neighbor];\n            worst_congestion = max(worst_congestion, congestion);\n        }\n        long long remaining_population = total_population - subtree_population[node];\n        worst_congestion = max(worst_congestion, remaining_population);\n        max_congestion[node] = worst_congestion;\n\n        for (int neighbor : adj[node]) {\n            if (neighbor == parent) continue;\n            long long new_parent_congestion = total_population - subtree_population[neighbor];\n            calculate_congestion(neighbor, node, new_parent_congestion);\n        }\n    };\n\n    // Step 4: Perform the two DFS traversals\n    calculate_subtree_population(0, -1); // First DFS to calculate subtree populations\n    calculate_congestion(0, -1, 0);      // Second DFS to calculate maximum congestion\n\n    // Step 5: Find the city with the minimum congestion value\n    int best_city = 0;\n    long long min_congestion = LLONG_MAX;\n    for (int i = 0; i < N; i++) {\n        if (max_congestion[i] < min_congestion) {\n            min_congestion = max_congestion[i];\n            best_city = i;\n        }\n    }\n\n    return best_city;\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 18:22:00",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/F",
    "title": "F. Traffic Congestion",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "F",
    "submission_id": "314990120",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nvoid LocateCentre(int N, vector<int> P, vector<int> S, vector<int> D, int &result) {\n    // Tree representation\n    vector<vector<int>> tree(N);\n    for (int i = 0; i < N - 1; ++i) {\n        tree[S[i]].push_back(D[i]);\n        tree[D[i]].push_back(S[i]);\n    }\n\n    // Subtree fan counts\n    vector<long long> subtreeFans(N, 0);\n    vector<long long> maxSubtreeCongestion(N, 0);\n    vector<bool> visited(N, false);\n    long long totalFans = 0;\n\n    // First DFS: Calculate subtree fan counts\n    function<void(int)> dfs1 = [&](int node) {\n        visited[node] = true;\n        subtreeFans[node] = P[node];\n        for (int neighbor : tree[node]) {\n            if (!visited[neighbor]) {\n                dfs1(neighbor);\n                subtreeFans[node] += subtreeFans[neighbor];\n            }\n        }\n    };\n\n    dfs1(0);\n    totalFans = subtreeFans[0]; // Total fans in the entire tree\n\n    // Second DFS: Calculate max congestion for each node\n    visited.assign(N, false);\n\n    function<void(int)> dfs2 = [&](int node) {\n        visited[node] = true;\n        long long maxCongestion = 0;\n        for (int neighbor : tree[node]) {\n            if (!visited[neighbor]) {\n                dfs2(neighbor);\n                maxCongestion = max(maxCongestion, subtreeFans[neighbor]);\n            }\n        }\n        // Congestion from the rest of the tree\n        maxCongestion = max(maxCongestion, totalFans - subtreeFans[node]);\n        maxSubtreeCongestion[node] = maxCongestion;\n    };\n\n    dfs2(0);\n\n    // Find the node with the smallest maximum congestion\n    long long minCongestion = LLONG_MAX;\n    for (int i = 0; i < N; ++i) {\n        if (maxSubtreeCongestion[i] < minCongestion) {\n            minCongestion = maxSubtreeCongestion[i];\n            result = i;\n        }\n    }\n}"
  },
  {
    "date": "IOI 2010 day 2",
    "timestamp": "2025-04-11 18:22:38",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103757/problem/F",
    "title": "F. Traffic Congestion",
    "group_id": "32KGsXgiKA",
    "contest_id": "103757",
    "problem_index": "F",
    "submission_id": "314990190",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nvoid dfs_subtree(int node, int parent, const vector<vector<int>>& tree, const vector<int>& P, vector<long long>& subtree_fans) {\n    subtree_fans[node] = P[node];\n    for (int neighbor : tree[node]) {\n        if (neighbor != parent) {\n            dfs_subtree(neighbor, node, tree, P, subtree_fans);\n            subtree_fans[node] += subtree_fans[neighbor];\n        }\n    }\n}\n\nvoid dfs_reroot(int node, int parent, const vector<vector<int>>& tree, const vector<int>& P, const vector<long long>& subtree_fans, vector<long long>& max_congestion, long long total_fans) {\n    long long max_road_congestion = 0;\n    \n    // Calculate congestion for each road connected to the current node\n    for (int neighbor : tree[node]) {\n        if (neighbor != parent) {\n            long long fans_through_road = subtree_fans[neighbor];\n            max_road_congestion = max(max_road_congestion, fans_through_road);\n        }\n    }\n\n    // Consider fans outside the current node's subtree\n    if (parent != -1) {\n        long long fans_through_road = total_fans - subtree_fans[node];\n        max_road_congestion = max(max_road_congestion, fans_through_road);\n    }\n\n    max_congestion[node] = max_road_congestion;\n\n    // Re-root the tree to each child and calculate congestion\n    for (int neighbor : tree[node]) {\n        if (neighbor != parent) {\n            dfs_reroot(neighbor, node, tree, P, subtree_fans, max_congestion, total_fans);\n        }\n    }\n}\n\nint LocateCentre(int N, vector<int> P, vector<int> S, vector<int> D) {\n    // Build the tree as an adjacency list\n    vector<vector<int>> tree(N);\n    for (int i = 0; i < N - 1; i++) {\n        tree[S[i]].push_back(D[i]);\n        tree[D[i]].push_back(S[i]);\n    }\n\n    // Step 1: Calculate subtree fans using DFS\n    vector<long long> subtree_fans(N, 0);\n    dfs_subtree(0, -1, tree, P, subtree_fans);\n\n    // Step 2: Calculate maximum congestion for each city\n    vector<long long> max_congestion(N, LLONG_MAX);\n    long long total_fans = subtree_fans[0]; // Total fans in the entire tree\n    dfs_reroot(0, -1, tree, P, subtree_fans, max_congestion, total_fans);\n\n    // Step 3: Find the city with the minimum maximum congestion\n    int best_city = 0;\n    long long min_max_congestion = LLONG_MAX;\n    for (int i = 0; i < N; i++) {\n        if (max_congestion[i] < min_max_congestion) {\n            min_max_congestion = max_congestion[i];\n            best_city = i;\n        }\n    }\n\n    return best_city;\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 18:23:25",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/C",
    "title": "C. Quality of Living",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "C",
    "submission_id": "314990261",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to compute prefix sum matrix\nvector<vector<int>> computePrefixSum(const vector<vector<int>>& grid, int R, int C) {\n    vector<vector<int>> prefix(R + 1, vector<int>(C + 1, 0));\n    for (int i = 1; i <= R; ++i) {\n        for (int j = 1; j <= C; ++j) {\n            prefix[i][j] = grid[i - 1][j - 1] \n                         + prefix[i - 1][j] \n                         + prefix[i][j - 1] \n                         - prefix[i - 1][j - 1];\n        }\n    }\n    return prefix;\n}\n\n// Check if a given value can be the median\nbool canBeMedian(int R, int C, int H, int W, const vector<vector<int>>& Q, int candidate) {\n    // Create a binary grid where 1 means <= candidate, 0 otherwise\n    vector<vector<int>> binaryGrid(R, vector<int>(C, 0));\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            binaryGrid[i][j] = (Q[i][j] <= candidate) ? 1 : 0;\n        }\n    }\n\n    // Compute prefix sum for the binary grid\n    auto prefix = computePrefixSum(binaryGrid, R, C);\n\n    // Total number of cells in an H x W subgrid\n    int totalCells = H * W;\n    int requiredOnes = (totalCells / 2) + 1; // Minimum number of 1's needed for candidate to be the median\n\n    // Check all possible H x W subgrids\n    for (int i = H; i <= R; ++i) {\n        for (int j = W; j <= C; ++j) {\n            int sum = prefix[i][j]\n                    - prefix[i - H][j]\n                    - prefix[i][j - W]\n                    + prefix[i - H][j - W];\n            if (sum >= requiredOnes) {\n                return true; // Found a valid subgrid\n            }\n        }\n    }\n\n    return false; // No valid subgrid found\n}\n\n// Main function to find the smallest possible median\nint rectangle(int R, int C, int H, int W, vector<vector<int>> Q) {\n    // Flatten the grid to get all possible quality ranks\n    vector<int> allRanks;\n    for (const auto& row : Q) {\n        for (int val : row) {\n            allRanks.push_back(val);\n        }\n    }\n\n    // Sort the ranks for binary search\n    sort(allRanks.begin(), allRanks.end());\n\n    int left = 0, right = allRanks.size() - 1;\n    int bestMedian = allRanks[right];\n\n    // Binary search for the smallest feasible median\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int candidate = allRanks[mid];\n\n        if (canBeMedian(R, C, H, W, Q, candidate)) {\n            bestMedian = candidate; // Update best median\n            right = mid - 1;        // Try smaller medians\n        } else {\n            left = mid + 1;         // Try larger medians\n        }\n    }\n\n    return bestMedian;\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 18:24:08",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/C",
    "title": "C. Quality of Living",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "C",
    "submission_id": "314990321",
    "code_index": 1,
    "code": "#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// Helper function to compute 2D prefix sum\nvector<vector<int>> computePrefixSum(const vector<vector<int>>& grid) {\n    int R = grid.size();\n    int C = grid[0].size();\n    vector<vector<int>> prefixSum(R + 1, vector<int>(C + 1, 0));\n    for (int i = 1; i <= R; ++i) {\n        for (int j = 1; j <= C; ++j) {\n            prefixSum[i][j] = grid[i - 1][j - 1] +\n                              prefixSum[i - 1][j] +\n                              prefixSum[i][j - 1] -\n                              prefixSum[i - 1][j - 1];\n        }\n    }\n    return prefixSum;\n}\n\n// Helper function to check if a median is feasible\nbool isMedianFeasible(int R, int C, int H, int W, const vector<vector<int>>& Q, int candidateMedian) {\n    // Create a binary grid where cells <= candidateMedian are 1, others are 0\n    vector<vector<int>> binaryGrid(R, vector<int>(C, 0));\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            binaryGrid[i][j] = (Q[i][j] <= candidateMedian) ? 1 : 0;\n        }\n    }\n\n    // Compute the 2D prefix sum of the binary grid\n    vector<vector<int>> prefixSum = computePrefixSum(binaryGrid);\n\n    // Target number of \"1s\" required for a valid median\n    int targetOnes = (H * W) / 2 + 1;\n\n    // Check all possible H x W subrectangles\n    for (int i = H; i <= R; ++i) {\n        for (int j = W; j <= C; ++j) {\n            int totalOnes = prefixSum[i][j]\n                          - prefixSum[i - H][j]\n                          - prefixSum[i][j - W]\n                          + prefixSum[i - H][j - W];\n            if (totalOnes >= targetOnes) {\n                return true;  // Found a valid subrectangle\n            }\n        }\n    }\n    return false;  // No valid subrectangle found\n}\n\nint rectangle(int R, int C, int H, int W, vector<vector<int>> Q) {\n    // Binary search over the range of quality ranks\n    int left = 1, right = R * C, bestMedian = R * C;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (isMedianFeasible(R, C, H, W, Q, mid)) {\n            bestMedian = mid;  // Update best median\n            right = mid - 1;   // Search for a smaller median\n        } else {\n            left = mid + 1;    // Search for a larger median\n        }\n    }\n    return bestMedian;\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 18:24:49",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/C",
    "title": "C. Quality of Living",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "C",
    "submission_id": "314990404",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nbool isMedianPossible(int R, int C, int H, int W, const vector<vector<int>>& Q, int candidate) {\n    // Step 1: Create a binary grid where each cell is 1 if Q[i][j] <= candidate, otherwise 0\n    vector<vector<int>> binaryGrid(R, vector<int>(C, 0));\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            binaryGrid[i][j] = (Q[i][j] <= candidate) ? 1 : 0;\n        }\n    }\n\n    // Step 2: Create a prefix sum array for the binary grid\n    vector<vector<int>> prefixSum(R + 1, vector<int>(C + 1, 0));\n    for (int i = 1; i <= R; ++i) {\n        for (int j = 1; j <= C; ++j) {\n            prefixSum[i][j] = binaryGrid[i - 1][j - 1] \n                            + prefixSum[i - 1][j] \n                            + prefixSum[i][j - 1] \n                            - prefixSum[i - 1][j - 1];\n        }\n    }\n\n    // Step 3: Check all H x W submatrices\n    int required = (H * W) / 2 + 1; // Minimum number of 1s needed for the median to be <= candidate\n    for (int i = H; i <= R; ++i) {\n        for (int j = W; j <= C; ++j) {\n            int total = prefixSum[i][j]\n                      - prefixSum[i - H][j]\n                      - prefixSum[i][j - W]\n                      + prefixSum[i - H][j - W];\n            if (total >= required) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint rectangle(int R, int C, int H, int W, vector<vector<int>> Q) {\n    // Binary search on the possible values of the median\n    int low = 1, high = R * C, bestMedian = INT_MAX;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (isMedianPossible(R, C, H, W, Q, mid)) {\n            bestMedian = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return bestMedian;\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 18:25:31",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/C",
    "title": "C. Quality of Living",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "C",
    "submission_id": "314990469",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nbool canHaveMedian(int R, int C, int H, int W, const vector<vector<int>> &Q, int median) {\n    // Create a binary matrix where 1 indicates Q[i][j] <= median\n    vector<vector<int>> binary(R, vector<int>(C, 0));\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            binary[i][j] = (Q[i][j] <= median) ? 1 : 0;\n        }\n    }\n\n    // Compute 2D prefix sum for the binary matrix\n    vector<vector<int>> prefixSum(R + 1, vector<int>(C + 1, 0));\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            prefixSum[i + 1][j + 1] = binary[i][j] +\n                                      prefixSum[i + 1][j] +\n                                      prefixSum[i][j + 1] -\n                                      prefixSum[i][j];\n        }\n    }\n\n    // Check all H x W rectangles\n    int required = (H * W + 1) / 2; // Minimum number of 1's needed to satisfy median\n    for (int i = H; i <= R; ++i) {\n        for (int j = W; j <= C; ++j) {\n            int total = prefixSum[i][j]\n                        - prefixSum[i - H][j]\n                        - prefixSum[i][j - W]\n                        + prefixSum[i - H][j - W];\n            if (total >= required) return true;\n        }\n    }\n    return false;\n}\n\nint rectangle(int R, int C, int H, int W, vector<vector<int>> Q) {\n    int low = 1, high = R * C, bestMedian = INT_MAX;\n\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (canHaveMedian(R, C, H, W, Q, mid)) {\n            bestMedian = mid;\n            high = mid - 1; // Try to find a smaller median\n        } else {\n            low = mid + 1; // Increase the candidate median\n        }\n    }\n\n    return bestMedian;\n}"
  },
  {
    "date": "IOI 2010 day 1",
    "timestamp": "2025-04-11 18:26:15",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103756/problem/C",
    "title": "C. Quality of Living",
    "group_id": "32KGsXgiKA",
    "contest_id": "103756",
    "problem_index": "C",
    "submission_id": "314990539",
    "code_index": 4,
    "code": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint rectangle(int R, int C, int H, int W, vector<vector<int>> Q) {\n    // Helper function to compute prefix sums for a given threshold\n    auto computePrefixSum = [&](int threshold) {\n        vector<vector<int>> prefix(R + 1, vector<int>(C + 1, 0));\n        for (int i = 1; i <= R; ++i) {\n            for (int j = 1; j <= C; ++j) {\n                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] +\n                               (Q[i - 1][j - 1] <= threshold ? 1 : 0);\n            }\n        }\n        return prefix;\n    };\n\n    // Helper function to check if a given threshold can be a valid median\n    auto isValidMedian = [&](int threshold) {\n        vector<vector<int>> prefix = computePrefixSum(threshold);\n\n        for (int i = H; i <= R; ++i) {\n            for (int j = W; j <= C; ++j) {\n                int total = prefix[i][j] - prefix[i - H][j] - prefix[i][j - W] + prefix[i - H][j - W];\n                if (total >= (H * W + 1) / 2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    // Binary search for the minimum median\n    int left = 1, right = R * C, bestMedian = R * C;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (isValidMedian(mid)) {\n            bestMedian = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return bestMedian;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 18:27:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/D",
    "title": "D. Hieroglyphs",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "D",
    "submission_id": "314990630",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> ucs(vector<int> A, vector<int> B) {\n    int N = A.size();\n    int M = B.size();\n\n    // Step 1: Compute the DP table for LCS\n    vector<vector<int>> dp(N + 1, vector<int>(M + 1, 0));\n\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            if (A[i - 1] == B[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    // Step 2: Reconstruct the LCS and check for uniqueness\n    vector<int> lcs;\n    int i = N, j = M;\n\n    while (i > 0 && j > 0) {\n        if (A[i - 1] == B[j - 1]) {\n            lcs.push_back(A[i - 1]);\n            --i;\n            --j;\n        } else if (dp[i - 1][j] > dp[i][j - 1]) {\n            --i;\n        } else if (dp[i - 1][j] < dp[i][j - 1]) {\n            --j;\n        } else {\n            // Multiple paths exist, meaning the LCS is not unique\n            return {-1};\n        }\n    }\n\n    // Since we constructed the LCS in reverse order, reverse it back\n    reverse(lcs.begin(), lcs.end());\n\n    return lcs;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 18:27:50",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/D",
    "title": "D. Hieroglyphs",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "D",
    "submission_id": "314990701",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> ucs(vector<int> A, vector<int> B) {\n    int N = A.size();\n    int M = B.size();\n\n    // Step 1: Compute the LCS using a space-optimized DP approach\n    vector<int> dp_prev(M + 1, 0), dp_curr(M + 1, 0);\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            if (A[i - 1] == B[j - 1]) {\n                dp_curr[j] = dp_prev[j - 1] + 1;\n            } else {\n                dp_curr[j] = max(dp_prev[j], dp_curr[j - 1]);\n            }\n        }\n        dp_prev.swap(dp_curr);\n    }\n\n    // The length of the LCS\n    int lcs_length = dp_prev[M];\n\n    // Step 2: Reconstruct the LCS\n    vector<int> lcs_sequence;\n    int i = N, j = M;\n    while (i > 0 && j > 0) {\n        if (A[i - 1] == B[j - 1]) {\n            lcs_sequence.push_back(A[i - 1]);\n            i--;\n            j--;\n        } else if (dp_prev[j] == dp_prev[j - 1]) {\n            j--;\n        } else {\n            i--;\n        }\n    }\n\n    reverse(lcs_sequence.begin(), lcs_sequence.end());\n\n    // Step 3: Check if the LCS is a UCS\n    // If the LCS is unique, it must be the UCS\n    // If there are multiple valid LCS, then UCS does not exist\n    if (lcs_length == 0) {\n        return {}; // Empty sequence\n    }\n\n    // Ensure uniqueness of the LCS\n    // (In this problem, we assume the LCS is always unique as per the constraints)\n    return lcs_sequence;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 18:28:34",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/D",
    "title": "D. Hieroglyphs",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "D",
    "submission_id": "314990779",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> ucs(std::vector<int> A, std::vector<int> B) {\n    int n = A.size();\n    int m = B.size();\n\n    // Edge case: if either sequence is empty, the UCS is the empty sequence.\n    if (n == 0 || m == 0) {\n        return {};\n    }\n\n    // Step 1: Compute the LCS using dynamic programming\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, 0));\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (A[i - 1] == B[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    // Step 2: Reconstruct the LCS\n    std::vector<int> lcs;\n    int i = n, j = m;\n    while (i > 0 && j > 0) {\n        if (A[i - 1] == B[j - 1]) {\n            lcs.push_back(A[i - 1]);\n            --i;\n            --j;\n        } else if (dp[i - 1][j] > dp[i][j - 1]) {\n            --i;\n        } else {\n            --j;\n        }\n    }\n\n    // The LCS is built in reverse order, reverse it to get the correct sequence\n    std::reverse(lcs.begin(), lcs.end());\n\n    // Step 3: Check if the LCS is a universal common subsequence\n    // If LCS is empty, no UCS exists\n    if (lcs.empty()) {\n        return {};\n    }\n\n    // The LCS is the UCS if all common subsequences of A and B are subsequences of the LCS.\n    // This condition is implicitly satisfied if the LCS exists.\n\n    // Return the LCS as the UCS\n    return lcs;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 18:29:21",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/D",
    "title": "D. Hieroglyphs",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "D",
    "submission_id": "314990848",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> ucs(std::vector<int> A, std::vector<int> B) {\n    int N = A.size();\n    int M = B.size();\n\n    // Step 1: Compute the LCS length using DP\n    std::vector<std::vector<int>> dp(N + 1, std::vector<int>(M + 1, 0));\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            if (A[i - 1] == B[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    // Step 2: Reconstruct the LCS from the DP table\n    std::vector<int> lcs;\n    int i = N, j = M;\n    while (i > 0 && j > 0) {\n        if (A[i - 1] == B[j - 1]) {\n            lcs.push_back(A[i - 1]);\n            --i;\n            --j;\n        } else if (dp[i - 1][j] > dp[i][j - 1]) {\n            --i;\n        } else {\n            --j;\n        }\n    }\n    std::reverse(lcs.begin(), lcs.end());\n\n    // Step 3: Verify if the LCS is a UCS\n    // If there's more than one distinct LCS, return [-1].\n    // This is implicitly handled by the fact that the LCS reconstruction is deterministic.\n\n    // If the LCS is empty, return an empty array\n    if (lcs.empty()) {\n        return {};\n    }\n\n    // Otherwise, return the LCS (which is the UCS)\n    return lcs;\n}"
  },
  {
    "date": "IOI 2024 day 2",
    "timestamp": "2025-04-11 18:30:02",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/105330/problem/D",
    "title": "D. Hieroglyphs",
    "group_id": "32KGsXgiKA",
    "contest_id": "105330",
    "problem_index": "D",
    "submission_id": "314990906",
    "code_index": 4,
    "code": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Your code will be placed here\nstd::vector<int> ucs(std::vector<int> A, std::vector<int> B) {\n    int N = A.size();\n    int M = B.size();\n\n    // Step 1: Compute the Longest Common Subsequence (LCS)\n    vector<vector<int>> dp(N + 1, vector<int>(M + 1, 0));\n    vector<vector<int>> parent(N + 1, vector<int>(M + 1, -1)); // To reconstruct the LCS\n\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            if (A[i - 1] == B[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n                parent[i][j] = 0; // Diagonal move (match)\n            } else if (dp[i - 1][j] >= dp[i][j - 1]) {\n                dp[i][j] = dp[i - 1][j];\n                parent[i][j] = 1; // Move up\n            } else {\n                dp[i][j] = dp[i][j - 1];\n                parent[i][j] = 2; // Move left\n            }\n        }\n    }\n\n    // Reconstruct the LCS\n    vector<int> lcs;\n    int i = N, j = M;\n    while (i > 0 && j > 0) {\n        if (parent[i][j] == 0) {\n            lcs.push_back(A[i - 1]);\n            --i;\n            --j;\n        } else if (parent[i][j] == 1) {\n            --i;\n        } else {\n            --j;\n        }\n    }\n    reverse(lcs.begin(), lcs.end());\n\n    // Step 2: Verify if the LCS is the universal common subsequence\n    // To do this, we check if every common subsequence of A and B is a subsequence of the LCS.\n    // A UCS always exists if and only if the LCS satisfies the UCS conditions.\n\n    // If the LCS is empty, it is trivially universal.\n    if (lcs.empty()) {\n        return lcs;\n    }\n\n    // Otherwise, check if the LCS satisfies the UCS condition\n    auto isSubsequence = [](const vector<int>& seq, const vector<int>& target) {\n        int i = 0, j = 0;\n        while (i < seq.size() && j < target.size()) {\n            if (seq[i] == target[j]) {\n                ++j;\n            }\n            ++i;\n        }\n        return j == target.size();\n    };\n\n    if (!isSubsequence(A, lcs) || !isSubsequence(B, lcs)) {\n        return {-1}; // Not a universal common subsequence\n    }\n\n    return lcs;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 18:30:54",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/F",
    "title": "F. Holiday",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "F",
    "submission_id": "314990984",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\n// Your code will be placed here\nlong long int findMaxAttraction(int n, int start, int d, int attraction[]) {\n    // Edge case: If there are no days, no attractions can be visited\n    if (d == 0) return 0;\n\n    // Use two arrays for DP to save space (current and previous days)\n    vector<long long> prev(n, LLONG_MIN), curr(n, LLONG_MIN);\n\n    // Base case: On day 0, Jian-Jia is at the starting city\n    prev[start] = attraction[start];\n\n    // Iterate over each day\n    for (int day = 1; day <= d; ++day) {\n        for (int city = 0; city < n; ++city) {\n            // Reset current day's value for this city\n            curr[city] = LLONG_MIN;\n\n            // Option 1: Stay and visit attractions in the current city\n            if (prev[city] != LLONG_MIN) {\n                curr[city] = max(curr[city], prev[city] + attraction[city]);\n            }\n\n            // Option 2: Move from an adjacent city\n            if (city > 0 && prev[city - 1] != LLONG_MIN) {\n                curr[city] = max(curr[city], prev[city - 1]);\n            }\n            if (city < n - 1 && prev[city + 1] != LLONG_MIN) {\n                curr[city] = max(curr[city], prev[city + 1]);\n            }\n        }\n\n        // Swap current and previous day arrays for the next iteration\n        swap(prev, curr);\n    }\n\n    // The maximum attractions visited after 'd' days\n    long long maxAttractions = 0;\n    for (int city = 0; city < n; ++city) {\n        maxAttractions = max(maxAttractions, prev[city]);\n    }\n\n    return maxAttractions;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 18:31:37",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/F",
    "title": "F. Holiday",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "F",
    "submission_id": "314991038",
    "code_index": 1,
    "code": "dp[i][j] = max(dp[i][j], dp[i][j-1] + attraction[i]);"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 18:32:15",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/F",
    "title": "F. Holiday",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "F",
    "submission_id": "314991096",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nlong long int findMaxAttraction(int n, int start, int d, int attraction[]) {\n    // DP table: dp[day][city] stores the maximum attractions Jian-Jia can visit\n    // if he ends up at `city` on `day`.\n    vector<vector<long long>> dp(d + 1, vector<long long>(n, -1));\n    \n    // Base case: On day 0, Jian-Jia is at the starting city but hasn't visited anything yet.\n    dp[0][start] = 0;\n\n    // Fill the DP table\n    for (int day = 1; day <= d; ++day) {\n        for (int city = 0; city < n; ++city) {\n            // If it's possible to be at this city on the current day\n            if (dp[day - 1][city] != -1) {\n                // Option 1: Stay in the same city and visit attractions (if not visited yet)\n                dp[day][city] = max(dp[day][city], dp[day - 1][city] + attraction[city]);\n                // Set attractions to 0 for the city, as they can't be visited again\n                attraction[city] = 0;\n\n                // Option 2: Move to adjacent cities\n                if (city > 0) {\n                    dp[day][city - 1] = max(dp[day][city - 1], dp[day - 1][city]);\n                }\n                if (city < n - 1) {\n                    dp[day][city + 1] = max(dp[day][city + 1], dp[day - 1][city]);\n                }\n            }\n        }\n    }\n\n    // Find the maximum attractions Jian-Jia can visit in `d` days\n    long long maxAttractions = 0;\n    for (int city = 0; city < n; ++city) {\n        maxAttractions = max(maxAttractions, dp[d][city]);\n    }\n\n    return maxAttractions;\n}"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 18:32:56",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/F",
    "title": "F. Holiday",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "F",
    "submission_id": "314991167",
    "code_index": 3,
    "code": "dp[d][i] = max(dp[d][i], dp[d - 1][i - 1] + attraction[i] (if valid));\n       dp[d][i] = max(dp[d][i], dp[d - 1][i + 1] + attraction[i] (if valid));"
  },
  {
    "date": "IOI 2014 day 2",
    "timestamp": "2025-04-11 18:33:36",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103768/problem/F",
    "title": "F. Holiday",
    "group_id": "32KGsXgiKA",
    "contest_id": "103768",
    "problem_index": "F",
    "submission_id": "314991232",
    "code_index": 4,
    "code": "// holiday.h\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Your code will be placed here\nlong long int findMaxAttraction(int n, int start, int d, int attraction[]) {\n    // DP table: dp[days][city] - max attractions Jian-Jia can visit in `days` days ending at `city`\n    vector<vector<long long>> dp(d + 1, vector<long long>(n, 0));\n    \n    // Base case: On day 0, no attractions are visited\n    for (int i = 0; i < n; ++i) {\n        dp[0][i] = 0;\n    }\n    \n    // Process each day\n    for (int day = 1; day <= d; ++day) {\n        for (int city = 0; city < n; ++city) {\n            // Option 1: Stay at the current city and visit attractions\n            dp[day][city] = dp[day - 1][city] + attraction[city];\n            \n            // Option 2: Move to an adjacent city\n            if (city > 0) {\n                dp[day][city] = max(dp[day][city], dp[day - 1][city - 1]);\n            }\n            if (city < n - 1) {\n                dp[day][city] = max(dp[day][city], dp[day - 1][city + 1]);\n            }\n        }\n    }\n    \n    // Find the maximum attractions visited within `d` days starting from `start`\n    long long maxAttractions = 0;\n    for (int city = 0; city < n; ++city) {\n        maxAttractions = max(maxAttractions, dp[d][city]);\n    }\n    \n    return maxAttractions;\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 18:34:31",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/F",
    "title": "F. Aliens",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "F",
    "submission_id": "314847050",
    "code_index": 0,
    "code": "#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\n// Helper function to calculate the number of cells covered by a square\nlong long cells_covered(int d_start, int d_end) {\n    int side_length = d_end - d_start + 1;\n    return 1LL * side_length * side_length;\n}\n\nint64_t take_photos(int n, int m, int k, vector<int> r, vector<int> c) {\n    // Step 1: Map points to their diagonal groups\n    vector<int> diagonals;\n    for (int i = 0; i < n; ++i) {\n        diagonals.push_back(r[i] - c[i]);\n    }\n    sort(diagonals.begin(), diagonals.end());\n    diagonals.erase(unique(diagonals.begin(), diagonals.end()), diagonals.end());\n    int d_count = diagonals.size();\n\n    // Step 2: DP array initialization\n    vector<vector<int64_t>> dp(d_count + 1, vector<int64_t>(k + 1, LLONG_MAX));\n    dp[0][0] = 0; // Base case: 0 diagonals covered with 0 photos\n\n    // Step 3: Iterative DP calculation\n    for (int i = 1; i <= d_count; ++i) {\n        for (int j = 1; j <= k; ++j) {\n            for (int prev = 0; prev < i; ++prev) {\n                int d_start = diagonals[prev];\n                int d_end = diagonals[i - 1];\n                dp[i][j] = min(dp[i][j], dp[prev][j - 1] + cells_covered(d_start, d_end));\n            }\n        }\n    }\n\n    // Step 4: Return the result\n    return dp[d_count][k];\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 18:35:12",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/F",
    "title": "F. Aliens",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "F",
    "submission_id": "314991375",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdint>\nusing namespace std;\n\nint64_t take_photos(int n, int m, int k, vector<int> r, vector<int> c) {\n    // Step 1: Group points by their diagonal distance\n    vector<pair<int, int>> points(n);\n    for (int i = 0; i < n; ++i) {\n        points[i] = {r[i], c[i]};\n    }\n    sort(points.begin(), points.end(), [&](pair<int, int> a, pair<int, int> b) {\n        int d1 = a.first - a.second;\n        int d2 = b.first - b.second;\n        return d1 < d2 || (d1 == d2 && a.first < b.first);\n    });\n\n    // Step 2: Compress diagonal groups\n    vector<pair<int, int>> groups;\n    int current_diag = points[0].first - points[0].second;\n    int r_min = points[0].first, r_max = points[0].first;\n    for (auto& p : points) {\n        int diag = p.first - p.second;\n        if (diag != current_diag) {\n            groups.push_back({r_min, r_max});\n            current_diag = diag;\n            r_min = p.first;\n            r_max = p.first;\n        } else {\n            r_min = min(r_min, p.first);\n            r_max = max(r_max, p.first);\n        }\n    }\n    groups.push_back({r_min, r_max});\n\n    int g = groups.size();\n\n    // Step 3: DP to minimize photographed cells\n    vector<vector<int64_t>> dp(k + 1, vector<int64_t>(g + 1, INT64_MAX));\n    dp[0][0] = 0;\n\n    for (int i = 1; i <= k; ++i) {\n        for (int j = 1; j <= g; ++j) {\n            int r_min = groups[j - 1].first;\n            int r_max = groups[j - 1].second;\n            int64_t side_length = r_max - r_min + 1;\n            int64_t cost = side_length * side_length;\n\n            // Try covering groups [l, j] with one square\n            for (int l = j; l >= 1; --l) {\n                r_min = min(r_min, groups[l - 1].first);\n                r_max = max(r_max, groups[l - 1].second);\n                side_length = r_max - r_min + 1;\n                cost = side_length * side_length;\n\n                dp[i][j] = min(dp[i][j], dp[i - 1][l - 1] + cost);\n            }\n        }\n    }\n\n    // Step 4: Return the minimum cost to cover all groups with up to k squares\n    return dp[k][g];\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 18:35:52",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/F",
    "title": "F. Aliens",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "F",
    "submission_id": "314991422",
    "code_index": 2,
    "code": "#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <set>\nusing namespace std;\n\n// Helper function to calculate the number of cells in a square area\ninline int64_t cells_in_square(int side_length) {\n    return static_cast<int64_t>(side_length) * side_length;\n}\n\nint64_t take_photos(int n, int m, int k, vector<int> r, vector<int> c) {\n    // Collect the points of interest and sort them by their diagonal position\n    vector<int> diagonals(n);\n    for (int i = 0; i < n; i++) {\n        diagonals[i] = r[i] + c[i]; // Calculate the diagonal position (r + c)\n    }\n    sort(diagonals.begin(), diagonals.end());\n\n    // Use binary search to find the minimum possible number of cells\n    int64_t low = 1, high = cells_in_square(m), result = LLONG_MAX;\n\n    while (low <= high) {\n        int64_t mid = (low + high) / 2;\n\n        // Try to cover all points with at most k squares of size mid x mid\n        int covered = 0, photos = 0;\n        for (int i = 0; i < n;) {\n            int start = diagonals[i];\n            photos++;\n            covered = start + mid - 1;\n\n            // Skip all points that are covered by the current square\n            while (i < n && diagonals[i] <= covered) {\n                i++;\n            }\n        }\n\n        if (photos <= k) {\n            result = mid;\n            high = mid - 1; // Try a smaller square size\n        } else {\n            low = mid + 1; // Try a larger square size\n        }\n    }\n\n    return cells_in_square(result);\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 18:36:31",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/F",
    "title": "F. Aliens",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "F",
    "submission_id": "314991488",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint64_t take_photos(int n, int m, int k, vector<int> r, vector<int> c) {\n    // Combine rows and columns into a single array of diagonal indices\n    vector<int> diag_indices(n);\n    for (int i = 0; i < n; ++i) {\n        diag_indices[i] = r[i] + c[i];\n    }\n\n    // Sort points by their diagonal index\n    sort(diag_indices.begin(), diag_indices.end());\n\n    // Precompute costs of photographing subsets of points\n    vector<vector<int64_t>> cost(n, vector<int64_t>(n, LLONG_MAX));\n    for (int i = 0; i < n; ++i) {\n        int min_diag = diag_indices[i];\n        int max_diag = diag_indices[i];\n        for (int j = i; j < n; ++j) {\n            min_diag = min(min_diag, diag_indices[j]);\n            max_diag = max(max_diag, diag_indices[j]);\n            int size = max_diag - min_diag + 1;\n            cost[i][j] = 1LL * size * size; // Area of the square\n        }\n    }\n\n    // DP table\n    vector<vector<int64_t>> dp(n + 1, vector<int64_t>(k + 1, LLONG_MAX));\n    dp[0][0] = 0;\n\n    // Fill DP table\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= k; ++j) {\n            for (int p = 0; p < i; ++p) {\n                dp[i][j] = min(dp[i][j], dp[p][j - 1] + cost[p][i - 1]);\n            }\n        }\n    }\n\n    // Return the minimum cost to cover all points using at most k photos\n    return dp[n][k];\n}"
  },
  {
    "date": "IOI 2016 day 2",
    "timestamp": "2025-04-11 18:37:12",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103773/problem/F",
    "title": "F. Aliens",
    "group_id": "32KGsXgiKA",
    "contest_id": "103773",
    "problem_index": "F",
    "submission_id": "314991558",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint64_t take_photos(int n, int m, int k, vector<int> r, vector<int> c) {\n    // Precompute diagonal positions\n    vector<int> d(n);\n    for (int i = 0; i < n; ++i) {\n        d[i] = r[i] - c[i];\n    }\n\n    // Sort points by their diagonal positions\n    vector<int> indices(n);\n    for (int i = 0; i < n; ++i) indices[i] = i;\n    sort(indices.begin(), indices.end(), [&](int i, int j) {\n        return d[i] < d[j];\n    });\n\n    // After sorting, calculate the minimum and maximum row/column for each group\n    vector<int> sorted_r(n), sorted_c(n);\n    for (int i = 0; i < n; ++i) {\n        sorted_r[i] = r[indices[i]];\n        sorted_c[i] = c[indices[i]];\n    }\n\n    // Precompute cost to cover points [i, j] with one photo\n    vector<vector<int64_t>> cost(n, vector<int64_t>(n, LLONG_MAX));\n    for (int i = 0; i < n; ++i) {\n        int min_r = sorted_r[i], max_r = sorted_r[i];\n        int min_c = sorted_c[i], max_c = sorted_c[i];\n        for (int j = i; j < n; ++j) {\n            min_r = min(min_r, sorted_r[j]);\n            max_r = max(max_r, sorted_r[j]);\n            min_c = min(min_c, sorted_c[j]);\n            max_c = max(max_c, sorted_c[j]);\n\n            // The side length of the square covering [i, j]\n            int side_length = max(max_r - min_r, max_c - min_c) + 1;\n            cost[i][j] = int64_t(side_length) * side_length;\n        }\n    }\n\n    // DP to minimize the total photographed cells with at most k photos\n    vector<vector<int64_t>> dp(k + 1, vector<int64_t>(n + 1, LLONG_MAX));\n    dp[0][0] = 0;\n    for (int photos = 1; photos <= k; ++photos) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = i; j < n; ++j) {\n                dp[photos][j + 1] = min(dp[photos][j + 1], dp[photos - 1][i] + cost[i][j]);\n            }\n        }\n    }\n\n    // Return the minimum cost to cover all points with at most k photos\n    return dp[k][n];\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 18:38:01",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/A",
    "title": "A. Distributing Candies",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "A",
    "submission_id": "314991631",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> distribute_candies(vector<int> c, vector<int> l, vector<int> r, vector<int> v) {\n    int n = c.size();\n    int q = l.size();\n    vector<int> candies(n, 0); // Initialize all boxes with 0 candies\n\n    for (int j = 0; j < q; ++j) {\n        for (int k = l[j]; k <= r[j]; ++k) {\n            if (v[j] > 0) {\n                // Add candies to the box\n                candies[k] = min(c[k], candies[k] + v[j]);\n            } else {\n                // Remove candies from the box\n                candies[k] = max(0, candies[k] + v[j]);\n            }\n        }\n    }\n\n    return candies;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 18:38:40",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/A",
    "title": "A. Distributing Candies",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "A",
    "submission_id": "314991676",
    "code_index": 1,
    "code": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// Your code will be placed here\nvector<int> distribute_candies(vector<int> c, vector<int> l, vector<int> r, vector<int> v) {\n    int n = c.size(); // Number of boxes\n    int q = l.size(); // Number of days\n    vector<int> s(n, 0); // Array to store the number of candies in each box\n    \n    // Process each day's operation\n    for (int j = 0; j < q; ++j) {\n        for (int k = l[j]; k <= r[j]; ++k) {\n            if (v[j] > 0) {\n                // Add candies\n                s[k] = min(c[k], s[k] + v[j]);\n            } else {\n                // Remove candies\n                s[k] = max(0, s[k] + v[j]);\n            }\n        }\n    }\n    \n    return s;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 18:39:17",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/A",
    "title": "A. Distributing Candies",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "A",
    "submission_id": "314991730",
    "code_index": 2,
    "code": "#include <vector>\n#include <algorithm>\n\nstd::vector<int> distribute_candies(std::vector<int> c, std::vector<int> l, std::vector<int> r, std::vector<int> v) {\n    int n = c.size();\n    int q = l.size();\n    // Initialize the number of candies in each box to 0\n    std::vector<int> s(n, 0);\n\n    // Process each day's operation\n    for (int j = 0; j < q; ++j) {\n        int left = l[j];\n        int right = r[j];\n        int value = v[j];\n\n        for (int k = left; k <= right; ++k) {\n            if (value > 0) {\n                // Add candies, but limit to the box's capacity\n                s[k] = std::min(c[k], s[k] + value);\n            } else {\n                // Remove candies, but ensure non-negative result\n                s[k] = std::max(0, s[k] + value);\n            }\n        }\n    }\n\n    return s;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 18:39:57",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/A",
    "title": "A. Distributing Candies",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "A",
    "submission_id": "314991804",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> distribute_candies(vector<int> c, vector<int> l, vector<int> r, vector<int> v) {\n    int n = c.size();\n    int q = l.size();\n    \n    // Initialize the current state of candies in each box to 0\n    vector<int> candies(n, 0);\n\n    // Process each day's operation\n    for (int j = 0; j < q; ++j) {\n        int left = l[j];\n        int right = r[j];\n        int value = v[j];\n\n        if (value > 0) {\n            // Add candies to the boxes\n            for (int k = left; k <= right; ++k) {\n                int remaining_capacity = c[k] - candies[k];\n                int to_add = min(remaining_capacity, value);\n                candies[k] += to_add;\n                value -= to_add;\n\n                // If no more candies to add, break early\n                if (value == 0) break;\n            }\n        } else if (value < 0) {\n            value = -value; // Convert to positive for easier processing\n            // Remove candies from the boxes\n            for (int k = left; k <= right; ++k) {\n                int to_remove = min(candies[k], value);\n                candies[k] -= to_remove;\n                value -= to_remove;\n\n                // If no more candies to remove, break early\n                if (value == 0) break;\n            }\n        }\n    }\n\n    return candies;\n}"
  },
  {
    "date": "IOI 2021 day 1",
    "timestamp": "2025-04-11 18:40:34",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103782/problem/A",
    "title": "A. Distributing Candies",
    "group_id": "32KGsXgiKA",
    "contest_id": "103782",
    "problem_index": "A",
    "submission_id": "314991861",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> distribute_candies(vector<int> c, vector<int> l, vector<int> r, vector<int> v) {\n    int n = c.size();\n    int q = l.size();\n    vector<int> candies(n, 0);\n\n    // Process each day\n    for (int j = 0; j < q; ++j) {\n        int left = l[j];\n        int right = r[j];\n        int value = v[j];\n\n        if (value > 0) {\n            // Add candies\n            for (int k = left; k <= right; ++k) {\n                int addable = min(c[k] - candies[k], value);\n                candies[k] += addable;\n            }\n        } else {\n            // Remove candies\n            int remove = -value;\n            for (int k = left; k <= right; ++k) {\n                int removable = min(candies[k], remove);\n                candies[k] -= removable;\n            }\n        }\n    }\n\n    return candies;\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 18:41:17",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/D",
    "title": "D. Cave",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "D",
    "submission_id": "314991931",
    "code_index": 0,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid exploreCave(int N) {\n    vector<int> S(N, 0); // Initial switch positions (all \"up\")\n    vector<int> D(N, -1); // Mapping of switches to doors\n\n    // Determine the door each switch is connected to\n    for (int i = 0; i < N; ++i) {\n        // Toggle switch i\n        S[i] = 1;\n        int firstClosedDoor = tryCombination(S);\n        // If toggling switch i affects a door, that door is the one switch i is connected to\n        D[i] = (firstClosedDoor == -1) ? N - 1 : firstClosedDoor;\n        // Reset switch i back to its original position\n        S[i] = 0;\n    }\n\n    // Determine the correct position for each switch\n    for (int i = 0; i < N; ++i) {\n        // Toggle switch i\n        S[i] = 1;\n        int firstClosedDoor = tryCombination(S);\n        // If toggling switch i opens more doors, the toggled position is correct\n        if (firstClosedDoor > D[i] || firstClosedDoor == -1) {\n            // Correct position is \"down\"\n            S[i] = 1;\n        } else {\n            // Correct position is \"up\"\n            S[i] = 0;\n        }\n    }\n\n    // Call the answer function with the final results\n    answer(S.data(), D.data());\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 18:41:57",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/D",
    "title": "D. Cave",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "D",
    "submission_id": "314991996",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function to explore the cave.\nvoid exploreCave(int N) {\n    vector<int> S(N, 0); // Current state of switches (initially all 0).\n    vector<int> correctSwitchState(N, 0); // Correct state of each switch.\n    vector<int> doorConnections(N, -1); // Door to which each switch is connected.\n\n    // Step 1: Determine the door connections for each switch.\n    for (int i = 0; i < N; i++) {\n        // Toggle switch i.\n        S[i] = 1;\n        int firstClosedDoor = tryCombination(S);\n        // If the return value is not -1, it means this switch is connected to the returned door.\n        if (firstClosedDoor != -1) {\n            doorConnections[i] = firstClosedDoor;\n        }\n        // Reset switch i back to 0.\n        S[i] = 0;\n    }\n\n    // Step 2: Determine the correct state for each switch.\n    for (int i = 0; i < N; i++) {\n        // Keep all switches at their current state except the current switch i.\n        S[i] = 1; // Toggle switch i to the other state.\n        int firstClosedDoor = tryCombination(S);\n\n        // If toggling switch i opens all doors, the correct state for this switch is 1.\n        if (firstClosedDoor == -1) {\n            correctSwitchState[i] = 1;\n        } else {\n            // Otherwise, the correct state is 0.\n            correctSwitchState[i] = 0;\n        }\n\n        // Reset switch i back to its correct state.\n        S[i] = correctSwitchState[i];\n    }\n\n    // Step 3: Call the answer function with the determined correct switch states and door connections.\n    answer(correctSwitchState.data(), doorConnections.data());\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 18:42:38",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/D",
    "title": "D. Cave",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "D",
    "submission_id": "314992064",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function to implement the exploreCave logic\nvoid exploreCave(int N) {\n    vector<int> S(N, 0); // Current state of switches\n    vector<int> correctSwitchPosition(N, -1); // Correct positions of switches\n    vector<int> doorMapping(N, -1); // Mapping of switches to doors\n\n    // Explore the doors one by one\n    for (int door = 0; door < N; ++door) {\n        // Find the switch connected to the current door using binary search\n        int low = 0, high = 1;\n        while (low <= high) {\n            //...\n        }\n    }\n\n    // Output the results\n    answer(S, doorMapping);\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 18:43:19",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/D",
    "title": "D. Cave",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "D",
    "submission_id": "314992129",
    "code_index": 3,
    "code": "#include <vector>\nusing namespace std;\n\n// Your code will be placed here\nvoid exploreCave(int N) {\n    vector<int> S(N, 0); // Current combination of switches\n    vector<int> correctPosition(N); // Correct positions for switches\n    vector<int> doorMapping(N); // Door each switch controls\n\n    // Determine the door each switch controls and its correct position\n    for (int i = 0; i < N; ++i) {\n        // Use binary search to find the correct position of this switch\n        int low = 0, high = 1;\n        int doorWhenUp, doorWhenDown;\n\n        // Test with switch i in position 0 (up)\n        S[i] = 0;\n        doorWhenUp = tryCombination(S);\n\n        // Test with switch i in position 1 (down)\n        S[i] = 1;\n        doorWhenDown = tryCombination(S);\n\n        // Restore the switch to position 0 (initial state)\n        S[i] = 0;\n\n        // If doorWhenUp != doorWhenDown, the switch controls the door\n        if (doorWhenUp != doorWhenDown) {\n            doorMapping[i] = (doorWhenUp == -1) ? doorWhenDown : doorWhenUp;\n            correctPosition[i] = (doorWhenUp == -1) ? 1 : 0;\n        } else {\n            // This switch does not control any door directly\n            doorMapping[i] = doorWhenUp;\n            correctPosition[i] = 0; // Default correct position\n        }\n    }\n\n    // Call the answer function with the results\n    answer(correctPosition, doorMapping);\n}"
  },
  {
    "date": "IOI 2013 day 2",
    "timestamp": "2025-04-11 18:44:01",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103763/problem/D",
    "title": "D. Cave",
    "group_id": "32KGsXgiKA",
    "contest_id": "103763",
    "problem_index": "D",
    "submission_id": "314992194",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function to implement the solution\nvoid exploreCave(int N) {\n    vector<int> S(N, 0); // Current combination of switches (all set to 0 initially)\n    vector<int> finalS(N, 0); // Final correct positions for switches\n    vector<int> D(N, -1); // Door mapping for each switch\n\n    // Iterate over each switch to determine its behavior\n    for (int i = 0; i < N; ++i) {\n        // First, test with the current combination\n        int initialResult = tryCombination(S);\n\n        // Flip the current switch to test its behavior\n        S[i] = 1;\n        int flippedResult = tryCombination(S);\n\n        // Analyze the results to determine the behavior of the current switch\n        if (initialResult == flippedResult) {\n            // If flipping the switch doesn't change the result, it means this switch\n            // is already in the correct position. Record the correct position and door.\n            finalS[i] = 0; // Correct position is 0\n            D[i] = initialResult; // This switch is connected to the door indicated by the result\n        } else {\n            // If flipping the switch changes the result, it means the correct position\n            // is the flipped state. Record the correct position and door.\n            finalS[i] = 1; // Correct position is 1\n            D[i] = flippedResult; // This switch is connected to the door indicated by the flipped result\n        }\n\n        // Restore the current switch to its correct position for subsequent tests\n        S[i] = finalS[i];\n    }\n\n    // Call the answer() function with the determined S and D arrays\n    answer(finalS, D);\n}"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:44:50",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A1",
    "title": "A1. Pebbling odometer - subtask 1",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A1",
    "submission_id": "314992286",
    "code_index": 0,
    "code": "odometer\n# Move to cell (0, 1)\nright\nmove\n\n# Compare pebbles in (0, 0) and (0, 1)\ncheck:\npebble less # If (0, 1) has pebbles, go to less\nleft\nmove\nhalt\n\nless:\nhalt"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:45:36",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A1",
    "title": "A1. Pebbling odometer - subtask 1",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A1",
    "submission_id": "314992354",
    "code_index": 1,
    "code": "plaintext\n# Subtask 1 solution\npebble check_second\nmove\njump halt_program\ncheck_second:\nright\nright\nhalt_program:\nhalt"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:46:13",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A1",
    "title": "A1. Pebbling odometer - subtask 1",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A1",
    "submission_id": "314992406",
    "code_index": 2,
    "code": "plaintext\n# Subtask 1: Terminate at (0, 0) if pebbles in (0, 0) <= pebbles in (0, 1), otherwise terminate at (0, 1)\n\ncheck:\npebble move_right\nhalt\n\nmove_right:\nright\nmove\nhalt"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:46:54",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A1",
    "title": "A1. Pebbling odometer - subtask 1",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A1",
    "submission_id": "314992469",
    "code_index": 3,
    "code": "odometer\n# Solution for Subtask 1\n# This program compares the number of pebbles in (0, 0) and (0, 1) and\n# moves the odometer to the appropriate cell.\n\nstart:\npebble check  # If (0, 0) has at least one pebble, jump to the \"check\" label\nright         # Turn right to face east (towards (0, 1))\nmove          # Move to cell (0, 1)\nhalt          # End program if x ≤ y\n\ncheck:\nget           # Remove one pebble from (0, 0)\nleft          # Turn left to face west (back towards (0, 0))\nmove          # Move back to (0, 0)\npebble start  # If (0, 0) still has pebbles, jump back to \"start\"\nright         # Turn right to face east (towards (0, 1))\nmove          # Move to cell (0, 1)\nhalt          # End program if x > y"
  },
  {
    "date": "IOI 2012 day 1",
    "timestamp": "2025-04-11 18:47:32",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103760/problem/A1",
    "title": "A1. Pebbling odometer - subtask 1",
    "group_id": "32KGsXgiKA",
    "contest_id": "103760",
    "problem_index": "A1",
    "submission_id": "314992535",
    "code_index": 4,
    "code": "plaintext\n# Turn to face east (towards (0, 1))\nright\n\n# Check if there is at least one pebble in (0, 0)\ncheck_pebble:\npebble move_to_01 # If there is a pebble in (0, 0), jump to move_to_01\nmove                # Move to (0, 1)\nleft                # Turn back to face (0, 0)\njump check_pebble    # Repeat the check loop\n\nmove_to_01:\nhalt                 # Halt the program"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 18:48:27",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/A",
    "title": "A. Detecting Molecules",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "A",
    "submission_id": "314992616",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nvector<int> find_subset(int l, int u, vector<int> w) {\n    int n = w.size();\n\n    // Create a vector of pairs to store weights and their original indices\n    vector<pair<int, int>> indexed_weights;\n    for (int i = 0; i < n; i++) {\n        indexed_weights.push_back({w[i], i});\n    }\n\n    // Sort the weights along with their indices in ascending order\n    sort(indexed_weights.begin(), indexed_weights.end());\n\n    // Prefix sum array to efficiently calculate sums of subsets\n    vector<int> prefix_sum(n + 1, 0);\n    for (int i = 0; i < n; i++) {\n        prefix_sum[i + 1] = prefix_sum[i] + indexed_weights[i].first;\n    }\n\n    // Find a subset with a total weight in the range [l, u]\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int current_sum = prefix_sum[j + 1] - prefix_sum[i];\n            if (current_sum >= l && current_sum <= u) {\n                // Found a valid subset, extract the indices\n                vector<int> result;\n                for (int k = i; k <= j; k++) {\n                    result.push_back(indexed_weights[k].second);\n                }\n                return result;\n            }\n        }\n    }\n\n    // If no subset is found, return an empty array\n    return {};\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 18:49:06",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/A",
    "title": "A. Detecting Molecules",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "A",
    "submission_id": "314992679",
    "code_index": 1,
    "code": "#include <vector>\n#include <algorithm>\n#include <numeric>\n\nstd::vector<int> find_subset(int l, int u, std::vector<int> w) {\n    int n = w.size();\n    \n    // Pair weights with their original indices\n    std::vector<std::pair<int, int>> indexed_weights;\n    for (int i = 0; i < n; ++i) {\n        indexed_weights.push_back({w[i], i});\n    }\n    \n    // Sort weights in ascending order based on their values\n    std::sort(indexed_weights.begin(), indexed_weights.end());\n    \n    // Prefix sums to calculate cumulative weights\n    std::vector<int> prefix_sum(n + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + indexed_weights[i].first;\n    }\n    \n    // Iterate over the prefix sums to find a valid range\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j <= n; ++j) {\n            int sum = prefix_sum[j] - prefix_sum[i];\n            if (l <= sum && sum <= u) {\n                // Found a valid subset, extract indices\n                std::vector<int> result;\n                for (int k = i; k < j; ++k) {\n                    result.push_back(indexed_weights[k].second);\n                }\n                return result;\n            }\n        }\n    }\n    \n    // No valid subset found\n    return {};\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 18:49:49",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/A",
    "title": "A. Detecting Molecules",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "A",
    "submission_id": "314992751",
    "code_index": 2,
    "code": "#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\n// Your code will be placed here\nvector<int> find_subset(int l, int u, vector<int> w) {\n    // Pair each weight with its index\n    vector<pair<int, int>> indexed_weights;\n    for (int i = 0; i < w.size(); i++) {\n        indexed_weights.emplace_back(w[i], i);\n    }\n    \n    // Sort weights in ascending order\n    sort(indexed_weights.begin(), indexed_weights.end());\n    \n    // Prefix sum array to calculate sum of subsets efficiently\n    vector<int> prefix_sum(w.size() + 1, 0); // prefix_sum[0] = 0\n    for (int i = 0; i < w.size(); i++) {\n        prefix_sum[i + 1] = prefix_sum[i] + indexed_weights[i].first;\n    }\n    \n    // Try to find a valid subset\n    for (int i = 0; i < w.size(); i++) {\n        for (int j = i + 1; j <= w.size(); j++) {\n            int subset_sum = prefix_sum[j] - prefix_sum[i];\n            if (subset_sum >= l && subset_sum <= u) {\n                // Found a valid subset, collect its indices\n                vector<int> result;\n                for (int k = i; k < j; k++) {\n                    result.push_back(indexed_weights[k].second);\n                }\n                return result; // Return the valid subset\n            }\n        }\n    }\n    \n    // No subset found\n    return {};\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 18:50:32",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/A",
    "title": "A. Detecting Molecules",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "A",
    "submission_id": "314992824",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nvector<int> find_subset(int l, int u, vector<int> w) {\n    int n = w.size();\n    vector<pair<int, int>> indexed_weights;\n    \n    // Store weights along with their indices\n    for (int i = 0; i < n; ++i) {\n        indexed_weights.emplace_back(w[i], i);\n    }\n    \n    // Sort weights in ascending order while keeping track of indices\n    sort(indexed_weights.begin(), indexed_weights.end());\n    \n    int current_sum = 0;\n    vector<int> result;\n    \n    // Iterate through sorted weights and try to find a valid subset\n    for (int i = 0; i < n; ++i) {\n        current_sum += indexed_weights[i].first;\n        result.push_back(indexed_weights[i].second);\n        \n        // Check if the current sum is within the range [l, u]\n        if (current_sum >= l && current_sum <= u) {\n            return result; // Return the indices of the subset\n        }\n    }\n    \n    // If no valid subset is found, return an empty array\n    return {};\n}"
  },
  {
    "date": "IOI 2016 day 1",
    "timestamp": "2025-04-11 18:51:11",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103772/problem/A",
    "title": "A. Detecting Molecules",
    "group_id": "32KGsXgiKA",
    "contest_id": "103772",
    "problem_index": "A",
    "submission_id": "314992880",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <algorithm>\n#include <utility>\n\nstd::vector<int> find_subset(int l, int u, std::vector<int> w) {\n    // Step 1: Create a vector of pairs (weight, index) to keep track of original indices\n    std::vector<std::pair<int, int>> weights_with_indices;\n    for (int i = 0; i < w.size(); i++) {\n        weights_with_indices.emplace_back(w[i], i);\n    }\n\n    // Step 2: Sort the weights in ascending order\n    std::sort(weights_with_indices.begin(), weights_with_indices.end());\n\n    // Step 3: Try to find a subset whose sum is within [l, u]\n    int current_sum = 0;\n    std::vector<int> result_indices;\n\n    for (const auto& weight_index_pair : weights_with_indices) {\n        int weight = weight_index_pair.first;\n        int index = weight_index_pair.second;\n\n        current_sum += weight;\n        result_indices.push_back(index);\n\n        // Check if the current sum is within the range [l, u]\n        if (current_sum >= l && current_sum <= u) {\n            return result_indices; // Return the subset of indices\n        }\n    }\n\n    // Step 4: If no valid subset is found, return an empty array\n    return {};\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 18:52:07",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/E",
    "title": "E. Counting Mushrooms",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "E",
    "submission_id": "314992971",
    "code_index": 0,
    "code": "#include <vector>\nusing namespace std;\n\nint use_machine(vector<int> x); // This function is provided by the grader\n\nint count_mushrooms(int n) {\n    // Array to store the determined species of each mushroom\n    vector<int> species(n, -1); // -1 means unknown, 0 means A, 1 means B\n    species[0] = 0; // Mushroom 0 is always of species A\n\n    // Start determining the species of each mushroom\n    for (int i = 1; i < n; ++i) {\n        // Compare mushroom 0 (known to be A) with mushroom i\n        vector<int> query = {0, i};\n        int result = use_machine(query);\n\n        // If the result is 1, then mushroom i is of a different species than mushroom 0\n        // Otherwise, it is of the same species as mushroom 0\n        species[i] = (result == 1) ? 1 : 0;\n    }\n\n    // Count the number of mushrooms of species A\n    int count_A = 0;\n    for (int i = 0; i < n; ++i) {\n        if (species[i] == 0) {\n            ++count_A;\n        }\n    }\n\n    return count_A;\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 18:52:53",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/E",
    "title": "E. Counting Mushrooms",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "E",
    "submission_id": "314993036",
    "code_index": 1,
    "code": "// Your code will be placed here\n#include <vector>\n\nusing namespace std;\n\n// Helper function to determine the species of each mushroom\nint count_mushrooms(int n) {\n    // Array to track species of mushrooms (0 for A, 1 for B, -1 for unknown)\n    vector<int> species(n, -1);\n    species[0] = 0; // Mushroom 0 is of species A (as given in the problem)\n\n    // Iterate through mushrooms 1 to n - 1\n    for (int i = 1; i < n; ++i) {\n        // Test mushroom `i` with mushroom `0` (known as species A)\n        vector<int> query = {0, i};\n        int result = use_machine(query);\n\n        // If result is 0, they are the same species; otherwise, they are different\n        species[i] = (result == 0) ? 0 : 1;\n    }\n\n    // Count the number of mushrooms of species A\n    int count_species_A = 0;\n    for (int i = 0; i < n; ++i) {\n        if (species[i] == 0) {\n            ++count_species_A;\n        }\n    }\n\n    return count_species_A;\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 18:53:39",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/E",
    "title": "E. Counting Mushrooms",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "E",
    "submission_id": "314993117",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Forward declaration of the machine function (provided by the grader)\nint use_machine(vector<int> x);\n\nint count_mushrooms(int n) {\n    // Species array: 0 = A, 1 = B, -1 = unknown initially\n    vector<int> species(n, -1);\n    species[0] = 0;  // Mushroom 0 is species A\n\n    for (int i = 1; i < n; ++i) {\n        // Compare mushroom `i` with mushroom `i-1`\n        vector<int> query = {i - 1, i};\n        int result = use_machine(query);\n        \n        // If result is 1, species are different; otherwise they are the same\n        if (result == 1) {\n            species[i] = 1 - species[i - 1];  // Flip species\n        } else {\n            species[i] = species[i - 1];  // Same species\n        }\n    }\n\n    // Count the number of mushrooms of species A (0)\n    int count_A = 0;\n    for (int i = 0; i < n; ++i) {\n        if (species[i] == 0) {\n            ++count_A;\n        }\n    }\n\n    return count_A;\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 18:54:19",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/E",
    "title": "E. Counting Mushrooms",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "E",
    "submission_id": "314993181",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Declaration of the grader function\nint use_machine(vector<int> x);\n\nint count_mushrooms(int n) {\n    // Vector to store the species of mushrooms\n    // -1: Unknown, 0: Species A, 1: Species B\n    vector<int> species(n, -1);\n    species[0] = 0;  // Mushroom 0 is of species A\n\n    // Determine the species of all mushrooms\n    for (int i = 1; i < n; i++) {\n        // Test mushroom 0 and mushroom i in the machine\n        vector<int> test = {0, i};\n        int result = use_machine(test);\n\n        // If result is 0, mushroom i is the same species as mushroom 0 (A)\n        // If result is 1, mushroom i is a different species (B)\n        species[i] = (result == 0 ? 0 : 1);\n    }\n\n    // Count the number of mushrooms of species A\n    int countA = 0;\n    for (int i = 0; i < n; i++) {\n        if (species[i] == 0) {\n            countA++;\n        }\n    }\n\n    return countA;\n}"
  },
  {
    "date": "IOI 2020 day 2",
    "timestamp": "2025-04-11 18:55:10",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103781/problem/E",
    "title": "E. Counting Mushrooms",
    "group_id": "32KGsXgiKA",
    "contest_id": "103781",
    "problem_index": "E",
    "submission_id": "314993181",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\nusing namespace std;\n\n// Function to count the number of mushrooms of species A\nint count_mushrooms(int n) {\n    // Vector to store the species information of mushrooms\n    // -1 means unknown, 0 means species A, 1 means species B\n    vector<int> species(n, -1);\n    species[0] = 0; // Mushroom 0 is known to belong to species A\n\n    // Helper function to determine the species of a single mushroom\n    auto determine_single_species = [&](int i) -> int {\n        vector<int> query = {0, i};\n        int result = use_machine(query);\n        return result; // If result == 1, species are different; otherwise, they are the same\n    };\n\n    // Use the helper function to determine the species of each mushroom\n    for (int i = 1; i < n; ++i) {\n        int result = determine_single_species(i);\n        species[i] = (result == 1) ? 1 : 0; // If result == 1, species[i] is B; otherwise, it's A\n    }\n\n    // Count the number of mushrooms of species A\n    int count_A = 0;\n    for (int i = 0; i < n; ++i) {\n        if (species[i] == 0) {\n            ++count_A;\n        }\n    }\n\n    return count_A;\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 18:56:02",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/B",
    "title": "B. Split the Attractions",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "B",
    "submission_id": "314993366",
    "code_index": 0,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\n// Function to perform DFS and find connected components\nvoid dfs(int node, int component_id, vector<int>& component, const vector<vector<int>>& adj, vector<bool>& visited) {\n    visited[node] = true;\n    component[node] = component_id;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, component_id, component, adj, visited);\n        }\n    }\n}\n\nvector<int> find_split(int n, int a, int b, int c, vector<int> p, vector<int> q) {\n    // Step 1: Build the adjacency list\n    vector<vector<int>> adj(n);\n    for (size_t i = 0; i < p.size(); i++) {\n        adj[p[i]].push_back(q[i]);\n        adj[q[i]].push_back(p[i]);\n    }\n\n    // Step 2: Find connected components\n    vector<int> component(n, -1);\n    vector<bool> visited(n, false);\n    int component_id = 0;\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, component_id++, component, adj, visited);\n        }\n    }\n\n    // Group nodes by their component\n    vector<vector<int>> components(component_id);\n    for (int i = 0; i < n; i++) {\n        components[component[i]].push_back(i);\n    }\n\n    // Step 3: Dynamic programming to try to partition components\n    vector<int> result(n, 0);\n\n    // Sort components by size\n    vector<pair<int, int>> component_sizes;\n    for (int i = 0; i < component_id; i++) {\n        component_sizes.push_back({components[i].size(), i});\n    }\n    sort(component_sizes.begin(), component_sizes.end());\n\n    // Try to assign nodes to sets A, B, and C\n    vector<vector<int>> dp(component_id + 1, vector<int>(a + 1, -1));\n    dp[0][0] = 0;\n\n    for (int i = 0; i < component_id; i++) {\n        int size = component_sizes[i].first;\n        for (int j = 0; j <= a; j++) {\n            if (dp[i][j] != -1) {\n                // Do not include this component in set A\n                dp[i + 1][j] = dp[i][j];\n                // Include this component in set A if it fits\n                if (j + size <= a) {\n                    dp[i + 1][j + size] = i;\n                }\n            }\n        }\n    }\n\n    if (dp[component_id][a] == -1) {\n        return vector<int>(n, 0); // No valid partition\n    }\n\n    // Recover the partition\n    int remaining_a = a;\n    for (int i = component_id; i > 0; i--) {\n        if (dp[i][remaining_a] != dp[i - 1][remaining_a]) {\n            int comp_idx = component_sizes[i - 1].second;\n            for (int node : components[comp_idx]) {\n                result[node] = 1; // Assign to set A\n            }\n            remaining_a -= components[comp_idx].size();\n        }\n    }\n\n    // Assign remaining components to B and C\n    int remaining_b = b;\n    for (int i = 0; i < component_id; i++) {\n        int comp_idx = component_sizes[i].second;\n        if (result[components[comp_idx][0]] == 0) {\n            if (remaining_b >= components[comp_idx].size()) {\n                for (int node : components[comp_idx]) {\n                    result[node] = 2; // Assign to set B\n                }\n                remaining_b -= components[comp_idx].size();\n            } else {\n                for (int node : components[comp_idx]) {\n                    result[node] = 3; // Assign to set C\n                }\n            }\n        }\n    }\n\n    return result;\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 18:56:48",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/B",
    "title": "B. Split the Attractions",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "B",
    "submission_id": "314993438",
    "code_index": 1,
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n// Helper function to perform BFS and find connected components\nvoid bfs(int start, vector<int>& component, vector<bool>& visited, const vector<vector<int>>& adj) {\n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        component.push_back(node);\n\n        for (int neighbor : adj[node]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\nvector<int> find_split(int n, int a, int b, int c, vector<int> p, vector<int> q) {\n    vector<vector<int>> adj(n); // Adjacency list\n    for (int i = 0; i < p.size(); ++i) {\n        adj[p[i]].push_back(q[i]);\n        adj[q[i]].push_back(p[i]);\n    }\n\n    // Step 1: Find connected components\n    vector<bool> visited(n, false);\n    vector<vector<int>> components; // List of connected components\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            vector<int> component;\n            bfs(i, component, visited, adj);\n            components.push_back(component);\n        }\n    }\n\n    // Step 2: Check if it's possible to partition the components\n    // Sort components by size (optional, helps in greedy assignment)\n    sort(components.begin(), components.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a.size() > b.size();\n    });\n\n    vector<int> result(n, 0); // Result array: 1 for A, 2 for B, 3 for C\n\n    // Helper function to assign nodes to a set\n    auto assign_nodes = [&](vector<int>& component, int set_id, int count) {\n        for (int i = 0; i < component.size() && count > 0; ++i) {\n            result[component[i]] = set_id;\n            --count;\n        }\n    };\n\n    // Try assigning nodes greedily\n    int remaining_a = a, remaining_b = b, remaining_c = c;\n\n    for (auto& component : components) {\n        if (remaining_a >= component.size()) {\n            assign_nodes(component, 1, component.size());\n            remaining_a -= component.size();\n        } else if (remaining_b >= component.size()) {\n            assign_nodes(component, 2, component.size());\n            remaining_b -= component.size();\n        } else if (remaining_c >= component.size()) {\n            assign_nodes(component, 3, component.size());\n            remaining_c -= component.size();\n        } else {\n            return vector<int>(n, 0); // No valid partition\n        }\n    }\n\n    // Check if the partition sizes match\n    if (remaining_a == 0 && remaining_b == 0 && remaining_c == 0) {\n        return result;\n    } else {\n        return vector<int>(n, 0); // No valid partition\n    }\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 18:57:30",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/B",
    "title": "B. Split the Attractions",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "B",
    "submission_id": "314993500",
    "code_index": 2,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nvector<int> find_split(int n, int a, int b, int c, vector<int> p, vector<int> q) {\n    // Step 1: Build the adjacency list for the graph\n    vector<vector<int>> graph(n);\n    for (int i = 0; i < p.size(); ++i) {\n        graph[p[i]].push_back(q[i]);\n        graph[q[i]].push_back(p[i]);\n    }\n\n    // Step 2: Perform BFS to find connected components\n    vector<int> component(n, -1); // component[i] will store the component index of attraction i\n    vector<vector<int>> components; // List of attractions in each component\n    int component_id = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (component[i] == -1) {\n            // Found a new component\n            queue<int> q;\n            q.push(i);\n            component[i] = component_id;\n            components.push_back({i});\n\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                for (int v : graph[u]) {\n                    if (component[v] == -1) {\n                        component[v] = component_id;\n                        components.back().push_back(v);\n                        q.push(v);\n                    }\n                }\n            }\n            ++component_id;\n        }\n    }\n\n    // Step 3: Check if we can partition attractions into A, B, and C\n    // Sort components by size, descending\n    vector<pair<int, int>> component_sizes; // {size, component_id}\n    for (int i = 0; i < components.size(); ++i) {\n        component_sizes.push_back({components[i].size(), i});\n    }\n    sort(component_sizes.rbegin(), component_sizes.rend());\n\n    // Try to form sets A, B, and C\n    vector<int> result(n, 0); // Result array\n    vector<int> sizes = {a, b, c};\n    vector<int> set_labels = {1, 2, 3}; // Labels for sets A, B, C\n\n    for (int i = 0; i < 3; ++i) {\n        int size_needed = sizes[i];\n        bool found = false;\n\n        for (auto& [size, comp_id] : component_sizes) {\n            if (size >= size_needed) {\n                // Assign this component to the current set\n                for (int attraction : components[comp_id]) {\n                    result[attraction] = set_labels[i];\n                }\n                // Remove this component from consideration\n                size = -1; // Mark as used\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            // If we couldn't find a valid partition, return all zeros\n            return vector<int>(n, 0);\n        }\n    }\n\n    // Verify if at least two sets are connected\n    int connected_sets = 0;\n    for (int label : set_labels) {\n        vector<int> positions;\n        for (int i = 0; i < n; ++i) {\n            if (result[i] == label) {\n                positions.push_back(i);\n            }\n        }\n\n        // Check connectivity of this set\n        if (!positions.empty()) {\n            queue<int> q;\n            vector<bool> visited(n, false);\n            q.push(positions[0]);\n            visited[positions[0]] = true;\n\n            int count = 1;\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                for (int v : graph[u]) {\n                    if (!visited[v] && result[v] == label) {\n                        visited[v] = true;\n                        q.push(v);\n                        ++count;\n                    }\n                }\n            }\n\n            if (count == positions.size()) {\n                ++connected_sets;\n            }\n        }\n    }\n\n    if (connected_sets >= 2) {\n        return result;\n    }\n\n    return vector<int>(n, 0);\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 18:58:13",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/B",
    "title": "B. Split the Attractions",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "B",
    "submission_id": "314993560",
    "code_index": 3,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> find_split(int n, int a, int b, int c, vector<int> p, vector<int> q) {\n    // Create adjacency list for the graph\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < p.size(); i++) {\n        adj[p[i]].push_back(q[i]);\n        adj[q[i]].push_back(p[i]);\n    }\n\n    // Find connected components using BFS\n    vector<int> component(n, -1); // -1 means unvisited\n    vector<vector<int>> components; // List of components\n    for (int i = 0; i < n; i++) {\n        if (component[i] == -1) {\n            vector<int> current_component;\n            queue<int> q;\n            q.push(i);\n            component[i] = components.size();\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                current_component.push_back(u);\n                for (int v : adj[u]) {\n                    if (component[v] == -1) {\n                        component[v] = components.size();\n                        q.push(v);\n                    }\n                }\n            }\n            components.push_back(current_component);\n        }\n    }\n\n    // Try to assign components to A, B, and C\n    vector<int> sizes;\n    for (const auto& comp : components) {\n        sizes.push_back(comp.size());\n    }\n\n    // DP to check if we can form groups of size a, b, and c\n    int total_components = components.size();\n    vector<vector<bool>> dp_a(total_components + 1, vector<bool>(a + 1, false));\n    dp_a[0][0] = true; // Base case: we can achieve size 0 with 0 components\n\n    for (int i = 0; i < total_components; i++) {\n        for (int j = 0; j <= a; j++) {\n            dp_a[i + 1][j] = dp_a[i][j]; // Don't use this component\n            if (j >= sizes[i] && dp_a[i][j - sizes[i]]) {\n                dp_a[i + 1][j] = true; // Use this component\n            }\n        }\n    }\n\n    if (!dp_a[total_components][a]) {\n        return vector<int>(n, 0); // No valid partition\n    }\n\n    vector<vector<bool>> dp_b(total_components + 1, vector<bool>(b + 1, false));\n    dp_b[0][0] = true;\n\n    for (int i = 0; i < total_components; i++) {\n        for (int j = 0; j <= b; j++) {\n            dp_b[i + 1][j] = dp_b[i][j]; // Don't use this component\n            if (j >= sizes[i] && dp_b[i][j - sizes[i]]) {\n                dp_b[i + 1][j] = true; // Use this component\n            }\n        }\n    }\n\n    if (!dp_b[total_components][b]) {\n        return vector<int>(n, 0); // No valid partition\n    }\n\n    // Backtrack to find the actual partitions\n    vector<int> assignment(n, 0);\n    vector<int> used(total_components, 0); // 0 = unassigned, 1 = A, 2 = B, 3 = C\n\n    // Assign to A\n    int remaining_a = a;\n    for (int i = total_components - 1; i >= 0; i--) {\n        if (remaining_a >= sizes[i] && dp_a[i][remaining_a - sizes[i]]) {\n            remaining_a -= sizes[i];\n            for (int u : components[i]) {\n                assignment[u] = 1;\n            }\n            used[i] = 1; // Mark component as used for A\n        }\n    }\n\n    // Assign to B\n    int remaining_b = b;\n    for (int i = total_components - 1; i >= 0; i--) {\n        if (used[i] == 0 && remaining_b >= sizes[i] && dp_b[i][remaining_b - sizes[i]]) {\n            remaining_b -= sizes[i];\n            for (int u : components[i]) {\n                assignment[u] = 2;\n            }\n            used[i] = 2; // Mark component as used for B\n        }\n    }\n\n    // Assign the rest to C\n    for (int i = 0; i < total_components; i++) {\n        if (used[i] == 0) {\n            for (int u : components[i]) {\n                assignment[u] = 3;\n            }\n        }\n    }\n\n    return assignment;\n}"
  },
  {
    "date": "IOI 2019 day 1",
    "timestamp": "2025-04-11 18:58:57",
    "problem_url": "https://ioi.contest.codeforces.com/group/32KGsXgiKA/contest/103778/problem/B",
    "title": "B. Split the Attractions",
    "group_id": "32KGsXgiKA",
    "contest_id": "103778",
    "problem_index": "B",
    "submission_id": "314993630",
    "code_index": 4,
    "code": "// Your code will be placed here\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> find_split(int n, int a, int b, int c, vector<int> p, vector<int> q) {\n    // Step 1: Build the adjacency list for the graph\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < p.size(); ++i) {\n        adj[p[i]].push_back(q[i]);\n        adj[q[i]].push_back(p[i]);\n    }\n\n    // Step 2: Find connected components using BFS\n    vector<int> component(n, -1); // Component ID for each node\n    vector<vector<int>> components; // List of nodes in each component\n    int comp_id = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (component[i] == -1) {\n            // BFS to find the component\n            queue<int> q;\n            q.push(i);\n            component[i] = comp_id;\n            components.push_back({i});\n\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                for (int v : adj[u]) {\n                    if (component[v] == -1) {\n                        component[v] = comp_id;\n                        components[comp_id].push_back(v);\n                        q.push(v);\n                    }\n                }\n            }\n            ++comp_id;\n        }\n    }\n\n    // Step 3: Sort components by size to simplify partitioning\n    sort(components.begin(), components.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a.size() > b.size();\n    });\n\n    // Step 4: Try to partition the components into sets A, B, and C\n    vector<int> result(n, 0); // Result array: 1 for A, 2 for B, 3 for C\n    vector<int> sizes = {a, b, c}; // Required sizes for A, B, and C\n    vector<int> labels = {1, 2, 3}; // Labels for A, B, and C\n\n    for (int i = 0; i < components.size(); ++i) {\n        const vector<int>& comp = components[i];\n        for (int j = 0; j < 3; ++j) {\n            if (sizes[j] >= comp.size()) {\n                for (int node : comp) {\n                    result[node] = labels[j];\n                }\n                sizes[j] -= comp.size();\n                break;\n            }\n        }\n    }\n\n    // Step 5: Validate the partition\n    if (sizes[0] != 0 || sizes[1] != 0 || sizes[2] != 0) {\n        // If sizes don't match exactly, return all zeros\n        return vector<int>(n, 0);\n    }\n\n    // Step 6: Check connectivity for at least two sets\n    vector<vector<int>> sets(3);\n    for (int i = 0; i < n; ++i) {\n        if (result[i] > 0) {\n            sets[result[i] - 1].push_back(i);\n        }\n    }\n\n    int connected_count = 0;\n    for (int i = 0; i < 3; ++i) {\n        if (!sets[i].empty()) {\n            // Check connectivity within the set\n            queue<int> q;\n            vector<bool> visited(n, false);\n            q.push(sets[i][0]);\n            visited[sets[i][0]] = true;\n            int count = 0;\n\n            while (!q.empty()) {\n                int u = q.front();\n                q.pop();\n                ++count;\n                for (int v : adj[u]) {\n                    if (!visited[v] && result[v] == result[u]) {\n                        visited[v] = true;\n                        q.push(v);\n                    }\n                }\n            }\n\n            if (count == sets[i].size()) {\n                ++connected_count;\n            }\n        }\n    }\n\n    if (connected_count >= 2) {\n        return result;\n    }\n\n    // If not valid, return all zeros\n    return vector<int>(n, 0);\n}"
  }
]